
/**
 * Client
**/

import * as runtime from './runtime/binary.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model CheckIn
 * 
 */
export type CheckIn = $Result.DefaultSelection<Prisma.$CheckInPayload>
/**
 * Model Clan
 * 
 */
export type Clan = $Result.DefaultSelection<Prisma.$ClanPayload>
/**
 * Model ClanMember
 * 
 */
export type ClanMember = $Result.DefaultSelection<Prisma.$ClanMemberPayload>
/**
 * Model Territory
 * 
 */
export type Territory = $Result.DefaultSelection<Prisma.$TerritoryPayload>
/**
 * Model TerritoryEvent
 * 
 */
export type TerritoryEvent = $Result.DefaultSelection<Prisma.$TerritoryEventPayload>
/**
 * Model Tournament
 * 
 */
export type Tournament = $Result.DefaultSelection<Prisma.$TournamentPayload>
/**
 * Model TournamentParticipant
 * 
 */
export type TournamentParticipant = $Result.DefaultSelection<Prisma.$TournamentParticipantPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model MatchEvent
 * 
 */
export type MatchEvent = $Result.DefaultSelection<Prisma.$MatchEventPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model NFT
 * 
 */
export type NFT = $Result.DefaultSelection<Prisma.$NFTPayload>
/**
 * Model UserNFT
 * 
 */
export type UserNFT = $Result.DefaultSelection<Prisma.$UserNFTPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = $Result.DefaultSelection<Prisma.$DirectMessagePayload>
/**
 * Model ActivityEvent
 * 
 */
export type ActivityEvent = $Result.DefaultSelection<Prisma.$ActivityEventPayload>
/**
 * Model VenueQuest
 * 
 */
export type VenueQuest = $Result.DefaultSelection<Prisma.$VenueQuestPayload>
/**
 * Model GameSession
 * 
 */
export type GameSession = $Result.DefaultSelection<Prisma.$GameSessionPayload>
/**
 * Model MarketplaceItem
 * 
 */
export type MarketplaceItem = $Result.DefaultSelection<Prisma.$MarketplaceItemPayload>
/**
 * Model CommunityCosmeticItem
 * 
 */
export type CommunityCosmeticItem = $Result.DefaultSelection<Prisma.$CommunityCosmeticItemPayload>
/**
 * Model CosmeticItemLike
 * 
 */
export type CosmeticItemLike = $Result.DefaultSelection<Prisma.$CosmeticItemLikePayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model ShadowRun
 * 
 */
export type ShadowRun = $Result.DefaultSelection<Prisma.$ShadowRunPayload>
/**
 * Model DojoCheckIn
 * 
 */
export type DojoCheckIn = $Result.DefaultSelection<Prisma.$DojoCheckInPayload>
/**
 * Model VenueSpecial
 * 
 */
export type VenueSpecial = $Result.DefaultSelection<Prisma.$VenueSpecialPayload>
/**
 * Model UserInventoryItem
 * 
 */
export type UserInventoryItem = $Result.DefaultSelection<Prisma.$UserInventoryItemPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Content
 * 
 */
export type Content = $Result.DefaultSelection<Prisma.$ContentPayload>
/**
 * Model ContentLike
 * 
 */
export type ContentLike = $Result.DefaultSelection<Prisma.$ContentLikePayload>
/**
 * Model ContentShare
 * 
 */
export type ContentShare = $Result.DefaultSelection<Prisma.$ContentSharePayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  VENUE_ADMIN: 'VENUE_ADMIN',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TableStatus: {
  AVAILABLE: 'AVAILABLE',
  OCCUPIED: 'OCCUPIED',
  MAINTENANCE: 'MAINTENANCE'
};

export type TableStatus = (typeof TableStatus)[keyof typeof TableStatus]


export const CheckInMethod: {
  QR: 'QR',
  GEO: 'GEO',
  ADMIN: 'ADMIN'
};

export type CheckInMethod = (typeof CheckInMethod)[keyof typeof CheckInMethod]


export const ClanRole: {
  MEMBER: 'MEMBER',
  OFFICER: 'OFFICER',
  COLEADER: 'COLEADER',
  LEADER: 'LEADER'
};

export type ClanRole = (typeof ClanRole)[keyof typeof ClanRole]


export const TerritoryEventType: {
  CLAIM: 'CLAIM',
  DEFEND: 'DEFEND',
  LOSE: 'LOSE',
  UPGRADE: 'UPGRADE'
};

export type TerritoryEventType = (typeof TerritoryEventType)[keyof typeof TerritoryEventType]


export const TournamentStatus: {
  UPCOMING: 'UPCOMING',
  REGISTRATION: 'REGISTRATION',
  ACTIVE: 'ACTIVE',
  LIVE: 'LIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TournamentStatus = (typeof TournamentStatus)[keyof typeof TournamentStatus]


export const MatchStatus: {
  SCHEDULED: 'SCHEDULED',
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  LIVE: 'LIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  PAUSED: 'PAUSED'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]


export const MatchEventType: {
  SHOT: 'SHOT',
  FOUL: 'FOUL',
  RACK_START: 'RACK_START',
  RACK_END: 'RACK_END',
  COMMENTARY: 'COMMENTARY',
  SYSTEM: 'SYSTEM'
};

export type MatchEventType = (typeof MatchEventType)[keyof typeof MatchEventType]


export const ChallengeStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  EXPIRED: 'EXPIRED'
};

export type ChallengeStatus = (typeof ChallengeStatus)[keyof typeof ChallengeStatus]


export const TxType: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT',
  PRIZE: 'PRIZE',
  FEE: 'FEE',
  PURCHASE: 'PURCHASE'
};

export type TxType = (typeof TxType)[keyof typeof TxType]


export const FriendshipStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  BLOCKED: 'BLOCKED'
};

export type FriendshipStatus = (typeof FriendshipStatus)[keyof typeof FriendshipStatus]


export const CosmeticCategory: {
  CUE_SKIN: 'CUE_SKIN',
  BALL_SET: 'BALL_SET',
  TABLE_THEME: 'TABLE_THEME',
  TABLE_CLOTH: 'TABLE_CLOTH',
  AVATAR_FRAME: 'AVATAR_FRAME',
  PARTICLE_EFFECT: 'PARTICLE_EFFECT',
  SOUND_PACK: 'SOUND_PACK',
  OTHER: 'OTHER'
};

export type CosmeticCategory = (typeof CosmeticCategory)[keyof typeof CosmeticCategory]


export const SubmissionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  REQUIRES_CHANGES: 'REQUIRES_CHANGES'
};

export type SubmissionStatus = (typeof SubmissionStatus)[keyof typeof SubmissionStatus]


export const FeedbackCategory: {
  BUG: 'BUG',
  FEATURE_REQUEST: 'FEATURE_REQUEST',
  GENERAL_FEEDBACK: 'GENERAL_FEEDBACK',
  VENUE_ISSUE: 'VENUE_ISSUE',
  TECHNICAL_SUPPORT: 'TECHNICAL_SUPPORT',
  UI_UX_IMPROVEMENT: 'UI_UX_IMPROVEMENT',
  PERFORMANCE_ISSUE: 'PERFORMANCE_ISSUE'
};

export type FeedbackCategory = (typeof FeedbackCategory)[keyof typeof FeedbackCategory]


export const FeedbackStatus: {
  PENDING: 'PENDING',
  IN_REVIEW: 'IN_REVIEW',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  REJECTED: 'REJECTED'
};

export type FeedbackStatus = (typeof FeedbackStatus)[keyof typeof FeedbackStatus]


export const FeedbackPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type FeedbackPriority = (typeof FeedbackPriority)[keyof typeof FeedbackPriority]


export const ContentType: {
  MATCH_REPLAY: 'MATCH_REPLAY',
  CUSTOM_ITEM: 'CUSTOM_ITEM',
  HIGH_SCORE: 'HIGH_SCORE',
  ACHIEVEMENT: 'ACHIEVEMENT',
  TOURNAMENT_HIGHLIGHT: 'TOURNAMENT_HIGHLIGHT',
  VENUE_REVIEW: 'VENUE_REVIEW',
  GENERAL: 'GENERAL',
  EVENT: 'EVENT',
  NEWS_ARTICLE: 'NEWS_ARTICLE',
  SYSTEM_MESSAGE: 'SYSTEM_MESSAGE'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const ContentStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ARCHIVED: 'ARCHIVED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const ContentVisibility: {
  PUBLIC: 'PUBLIC',
  FRIENDS_ONLY: 'FRIENDS_ONLY',
  PRIVATE: 'PRIVATE'
};

export type ContentVisibility = (typeof ContentVisibility)[keyof typeof ContentVisibility]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TableStatus = $Enums.TableStatus

export const TableStatus: typeof $Enums.TableStatus

export type CheckInMethod = $Enums.CheckInMethod

export const CheckInMethod: typeof $Enums.CheckInMethod

export type ClanRole = $Enums.ClanRole

export const ClanRole: typeof $Enums.ClanRole

export type TerritoryEventType = $Enums.TerritoryEventType

export const TerritoryEventType: typeof $Enums.TerritoryEventType

export type TournamentStatus = $Enums.TournamentStatus

export const TournamentStatus: typeof $Enums.TournamentStatus

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

export type MatchEventType = $Enums.MatchEventType

export const MatchEventType: typeof $Enums.MatchEventType

export type ChallengeStatus = $Enums.ChallengeStatus

export const ChallengeStatus: typeof $Enums.ChallengeStatus

export type TxType = $Enums.TxType

export const TxType: typeof $Enums.TxType

export type FriendshipStatus = $Enums.FriendshipStatus

export const FriendshipStatus: typeof $Enums.FriendshipStatus

export type CosmeticCategory = $Enums.CosmeticCategory

export const CosmeticCategory: typeof $Enums.CosmeticCategory

export type SubmissionStatus = $Enums.SubmissionStatus

export const SubmissionStatus: typeof $Enums.SubmissionStatus

export type FeedbackCategory = $Enums.FeedbackCategory

export const FeedbackCategory: typeof $Enums.FeedbackCategory

export type FeedbackStatus = $Enums.FeedbackStatus

export const FeedbackStatus: typeof $Enums.FeedbackStatus

export type FeedbackPriority = $Enums.FeedbackPriority

export const FeedbackPriority: typeof $Enums.FeedbackPriority

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

export type ContentVisibility = $Enums.ContentVisibility

export const ContentVisibility: typeof $Enums.ContentVisibility

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => $Utils.JsPromise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs>;

  /**
   * `prisma.checkIn`: Exposes CRUD operations for the **CheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckIns
    * const checkIns = await prisma.checkIn.findMany()
    * ```
    */
  get checkIn(): Prisma.CheckInDelegate<ExtArgs>;

  /**
   * `prisma.clan`: Exposes CRUD operations for the **Clan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clans
    * const clans = await prisma.clan.findMany()
    * ```
    */
  get clan(): Prisma.ClanDelegate<ExtArgs>;

  /**
   * `prisma.clanMember`: Exposes CRUD operations for the **ClanMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClanMembers
    * const clanMembers = await prisma.clanMember.findMany()
    * ```
    */
  get clanMember(): Prisma.ClanMemberDelegate<ExtArgs>;

  /**
   * `prisma.territory`: Exposes CRUD operations for the **Territory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Territories
    * const territories = await prisma.territory.findMany()
    * ```
    */
  get territory(): Prisma.TerritoryDelegate<ExtArgs>;

  /**
   * `prisma.territoryEvent`: Exposes CRUD operations for the **TerritoryEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TerritoryEvents
    * const territoryEvents = await prisma.territoryEvent.findMany()
    * ```
    */
  get territoryEvent(): Prisma.TerritoryEventDelegate<ExtArgs>;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **Tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.TournamentDelegate<ExtArgs>;

  /**
   * `prisma.tournamentParticipant`: Exposes CRUD operations for the **TournamentParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentParticipants
    * const tournamentParticipants = await prisma.tournamentParticipant.findMany()
    * ```
    */
  get tournamentParticipant(): Prisma.TournamentParticipantDelegate<ExtArgs>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs>;

  /**
   * `prisma.matchEvent`: Exposes CRUD operations for the **MatchEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchEvents
    * const matchEvents = await prisma.matchEvent.findMany()
    * ```
    */
  get matchEvent(): Prisma.MatchEventDelegate<ExtArgs>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.nFT`: Exposes CRUD operations for the **NFT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NFTS
    * const nFTS = await prisma.nFT.findMany()
    * ```
    */
  get nFT(): Prisma.NFTDelegate<ExtArgs>;

  /**
   * `prisma.userNFT`: Exposes CRUD operations for the **UserNFT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNFTS
    * const userNFTS = await prisma.userNFT.findMany()
    * ```
    */
  get userNFT(): Prisma.UserNFTDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<ExtArgs>;

  /**
   * `prisma.activityEvent`: Exposes CRUD operations for the **ActivityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityEvents
    * const activityEvents = await prisma.activityEvent.findMany()
    * ```
    */
  get activityEvent(): Prisma.ActivityEventDelegate<ExtArgs>;

  /**
   * `prisma.venueQuest`: Exposes CRUD operations for the **VenueQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VenueQuests
    * const venueQuests = await prisma.venueQuest.findMany()
    * ```
    */
  get venueQuest(): Prisma.VenueQuestDelegate<ExtArgs>;

  /**
   * `prisma.gameSession`: Exposes CRUD operations for the **GameSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameSessions
    * const gameSessions = await prisma.gameSession.findMany()
    * ```
    */
  get gameSession(): Prisma.GameSessionDelegate<ExtArgs>;

  /**
   * `prisma.marketplaceItem`: Exposes CRUD operations for the **MarketplaceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceItems
    * const marketplaceItems = await prisma.marketplaceItem.findMany()
    * ```
    */
  get marketplaceItem(): Prisma.MarketplaceItemDelegate<ExtArgs>;

  /**
   * `prisma.communityCosmeticItem`: Exposes CRUD operations for the **CommunityCosmeticItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityCosmeticItems
    * const communityCosmeticItems = await prisma.communityCosmeticItem.findMany()
    * ```
    */
  get communityCosmeticItem(): Prisma.CommunityCosmeticItemDelegate<ExtArgs>;

  /**
   * `prisma.cosmeticItemLike`: Exposes CRUD operations for the **CosmeticItemLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CosmeticItemLikes
    * const cosmeticItemLikes = await prisma.cosmeticItemLike.findMany()
    * ```
    */
  get cosmeticItemLike(): Prisma.CosmeticItemLikeDelegate<ExtArgs>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs>;

  /**
   * `prisma.shadowRun`: Exposes CRUD operations for the **ShadowRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShadowRuns
    * const shadowRuns = await prisma.shadowRun.findMany()
    * ```
    */
  get shadowRun(): Prisma.ShadowRunDelegate<ExtArgs>;

  /**
   * `prisma.dojoCheckIn`: Exposes CRUD operations for the **DojoCheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DojoCheckIns
    * const dojoCheckIns = await prisma.dojoCheckIn.findMany()
    * ```
    */
  get dojoCheckIn(): Prisma.DojoCheckInDelegate<ExtArgs>;

  /**
   * `prisma.venueSpecial`: Exposes CRUD operations for the **VenueSpecial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VenueSpecials
    * const venueSpecials = await prisma.venueSpecial.findMany()
    * ```
    */
  get venueSpecial(): Prisma.VenueSpecialDelegate<ExtArgs>;

  /**
   * `prisma.userInventoryItem`: Exposes CRUD operations for the **UserInventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInventoryItems
    * const userInventoryItems = await prisma.userInventoryItem.findMany()
    * ```
    */
  get userInventoryItem(): Prisma.UserInventoryItemDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.content`: Exposes CRUD operations for the **Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.ContentDelegate<ExtArgs>;

  /**
   * `prisma.contentLike`: Exposes CRUD operations for the **ContentLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentLikes
    * const contentLikes = await prisma.contentLike.findMany()
    * ```
    */
  get contentLike(): Prisma.ContentLikeDelegate<ExtArgs>;

  /**
   * `prisma.contentShare`: Exposes CRUD operations for the **ContentShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentShares
    * const contentShares = await prisma.contentShare.findMany()
    * ```
    */
  get contentShare(): Prisma.ContentShareDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    User: 'User',
    Profile: 'Profile',
    UserSettings: 'UserSettings',
    Venue: 'Venue',
    Table: 'Table',
    CheckIn: 'CheckIn',
    Clan: 'Clan',
    ClanMember: 'ClanMember',
    Territory: 'Territory',
    TerritoryEvent: 'TerritoryEvent',
    Tournament: 'Tournament',
    TournamentParticipant: 'TournamentParticipant',
    Match: 'Match',
    MatchEvent: 'MatchEvent',
    Challenge: 'Challenge',
    Wallet: 'Wallet',
    Transaction: 'Transaction',
    NFT: 'NFT',
    UserNFT: 'UserNFT',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    Friendship: 'Friendship',
    DirectMessage: 'DirectMessage',
    ActivityEvent: 'ActivityEvent',
    VenueQuest: 'VenueQuest',
    GameSession: 'GameSession',
    MarketplaceItem: 'MarketplaceItem',
    CommunityCosmeticItem: 'CommunityCosmeticItem',
    CosmeticItemLike: 'CosmeticItemLike',
    Season: 'Season',
    ShadowRun: 'ShadowRun',
    DojoCheckIn: 'DojoCheckIn',
    VenueSpecial: 'VenueSpecial',
    UserInventoryItem: 'UserInventoryItem',
    Feedback: 'Feedback',
    Content: 'Content',
    ContentLike: 'ContentLike',
    ContentShare: 'ContentShare',
    RefreshToken: 'RefreshToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "account" | "session" | "verificationToken" | "user" | "profile" | "userSettings" | "venue" | "table" | "checkIn" | "clan" | "clanMember" | "territory" | "territoryEvent" | "tournament" | "tournamentParticipant" | "match" | "matchEvent" | "challenge" | "wallet" | "transaction" | "nFT" | "userNFT" | "achievement" | "userAchievement" | "notification" | "auditLog" | "friendship" | "directMessage" | "activityEvent" | "venueQuest" | "gameSession" | "marketplaceItem" | "communityCosmeticItem" | "cosmeticItemLike" | "season" | "shadowRun" | "dojoCheckIn" | "venueSpecial" | "userInventoryItem" | "feedback" | "content" | "contentLike" | "contentShare" | "refreshToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      CheckIn: {
        payload: Prisma.$CheckInPayload<ExtArgs>
        fields: Prisma.CheckInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          findFirst: {
            args: Prisma.CheckInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          findMany: {
            args: Prisma.CheckInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          create: {
            args: Prisma.CheckInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          createMany: {
            args: Prisma.CheckInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>[]
          }
          delete: {
            args: Prisma.CheckInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          update: {
            args: Prisma.CheckInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          deleteMany: {
            args: Prisma.CheckInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheckInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInPayload>
          }
          aggregate: {
            args: Prisma.CheckInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckIn>
          }
          groupBy: {
            args: Prisma.CheckInGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckInCountArgs<ExtArgs>
            result: $Utils.Optional<CheckInCountAggregateOutputType> | number
          }
        }
      }
      Clan: {
        payload: Prisma.$ClanPayload<ExtArgs>
        fields: Prisma.ClanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          findFirst: {
            args: Prisma.ClanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          findMany: {
            args: Prisma.ClanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>[]
          }
          create: {
            args: Prisma.ClanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          createMany: {
            args: Prisma.ClanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>[]
          }
          delete: {
            args: Prisma.ClanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          update: {
            args: Prisma.ClanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          deleteMany: {
            args: Prisma.ClanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          aggregate: {
            args: Prisma.ClanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClan>
          }
          groupBy: {
            args: Prisma.ClanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClanCountArgs<ExtArgs>
            result: $Utils.Optional<ClanCountAggregateOutputType> | number
          }
        }
      }
      ClanMember: {
        payload: Prisma.$ClanMemberPayload<ExtArgs>
        fields: Prisma.ClanMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClanMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClanMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>
          }
          findFirst: {
            args: Prisma.ClanMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClanMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>
          }
          findMany: {
            args: Prisma.ClanMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>[]
          }
          create: {
            args: Prisma.ClanMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>
          }
          createMany: {
            args: Prisma.ClanMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClanMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>[]
          }
          delete: {
            args: Prisma.ClanMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>
          }
          update: {
            args: Prisma.ClanMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>
          }
          deleteMany: {
            args: Prisma.ClanMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClanMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClanMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanMemberPayload>
          }
          aggregate: {
            args: Prisma.ClanMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClanMember>
          }
          groupBy: {
            args: Prisma.ClanMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClanMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClanMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ClanMemberCountAggregateOutputType> | number
          }
        }
      }
      Territory: {
        payload: Prisma.$TerritoryPayload<ExtArgs>
        fields: Prisma.TerritoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerritoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerritoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          findFirst: {
            args: Prisma.TerritoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerritoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          findMany: {
            args: Prisma.TerritoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>[]
          }
          create: {
            args: Prisma.TerritoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          createMany: {
            args: Prisma.TerritoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerritoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>[]
          }
          delete: {
            args: Prisma.TerritoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          update: {
            args: Prisma.TerritoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          deleteMany: {
            args: Prisma.TerritoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerritoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TerritoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryPayload>
          }
          aggregate: {
            args: Prisma.TerritoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerritory>
          }
          groupBy: {
            args: Prisma.TerritoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerritoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerritoryCountArgs<ExtArgs>
            result: $Utils.Optional<TerritoryCountAggregateOutputType> | number
          }
        }
      }
      TerritoryEvent: {
        payload: Prisma.$TerritoryEventPayload<ExtArgs>
        fields: Prisma.TerritoryEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerritoryEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerritoryEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>
          }
          findFirst: {
            args: Prisma.TerritoryEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerritoryEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>
          }
          findMany: {
            args: Prisma.TerritoryEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>[]
          }
          create: {
            args: Prisma.TerritoryEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>
          }
          createMany: {
            args: Prisma.TerritoryEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerritoryEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>[]
          }
          delete: {
            args: Prisma.TerritoryEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>
          }
          update: {
            args: Prisma.TerritoryEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>
          }
          deleteMany: {
            args: Prisma.TerritoryEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerritoryEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TerritoryEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerritoryEventPayload>
          }
          aggregate: {
            args: Prisma.TerritoryEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerritoryEvent>
          }
          groupBy: {
            args: Prisma.TerritoryEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerritoryEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerritoryEventCountArgs<ExtArgs>
            result: $Utils.Optional<TerritoryEventCountAggregateOutputType> | number
          }
        }
      }
      Tournament: {
        payload: Prisma.$TournamentPayload<ExtArgs>
        fields: Prisma.TournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findFirst: {
            args: Prisma.TournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findMany: {
            args: Prisma.TournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          create: {
            args: Prisma.TournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          createMany: {
            args: Prisma.TournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          delete: {
            args: Prisma.TournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          update: {
            args: Prisma.TournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          deleteMany: {
            args: Prisma.TournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          aggregate: {
            args: Prisma.TournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament>
          }
          groupBy: {
            args: Prisma.TournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentCountAggregateOutputType> | number
          }
        }
      }
      TournamentParticipant: {
        payload: Prisma.$TournamentParticipantPayload<ExtArgs>
        fields: Prisma.TournamentParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>
          }
          findFirst: {
            args: Prisma.TournamentParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>
          }
          findMany: {
            args: Prisma.TournamentParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>[]
          }
          create: {
            args: Prisma.TournamentParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>
          }
          createMany: {
            args: Prisma.TournamentParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>[]
          }
          delete: {
            args: Prisma.TournamentParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>
          }
          update: {
            args: Prisma.TournamentParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TournamentParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TournamentParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentParticipantPayload>
          }
          aggregate: {
            args: Prisma.TournamentParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentParticipant>
          }
          groupBy: {
            args: Prisma.TournamentParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentParticipantCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      MatchEvent: {
        payload: Prisma.$MatchEventPayload<ExtArgs>
        fields: Prisma.MatchEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          findFirst: {
            args: Prisma.MatchEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          findMany: {
            args: Prisma.MatchEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>[]
          }
          create: {
            args: Prisma.MatchEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          createMany: {
            args: Prisma.MatchEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>[]
          }
          delete: {
            args: Prisma.MatchEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          update: {
            args: Prisma.MatchEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          deleteMany: {
            args: Prisma.MatchEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchEventPayload>
          }
          aggregate: {
            args: Prisma.MatchEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchEvent>
          }
          groupBy: {
            args: Prisma.MatchEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchEventCountArgs<ExtArgs>
            result: $Utils.Optional<MatchEventCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      NFT: {
        payload: Prisma.$NFTPayload<ExtArgs>
        fields: Prisma.NFTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NFTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NFTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          findFirst: {
            args: Prisma.NFTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NFTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          findMany: {
            args: Prisma.NFTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>[]
          }
          create: {
            args: Prisma.NFTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          createMany: {
            args: Prisma.NFTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NFTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>[]
          }
          delete: {
            args: Prisma.NFTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          update: {
            args: Prisma.NFTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          deleteMany: {
            args: Prisma.NFTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NFTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NFTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          aggregate: {
            args: Prisma.NFTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNFT>
          }
          groupBy: {
            args: Prisma.NFTGroupByArgs<ExtArgs>
            result: $Utils.Optional<NFTGroupByOutputType>[]
          }
          count: {
            args: Prisma.NFTCountArgs<ExtArgs>
            result: $Utils.Optional<NFTCountAggregateOutputType> | number
          }
        }
      }
      UserNFT: {
        payload: Prisma.$UserNFTPayload<ExtArgs>
        fields: Prisma.UserNFTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNFTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNFTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>
          }
          findFirst: {
            args: Prisma.UserNFTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNFTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>
          }
          findMany: {
            args: Prisma.UserNFTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>[]
          }
          create: {
            args: Prisma.UserNFTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>
          }
          createMany: {
            args: Prisma.UserNFTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNFTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>[]
          }
          delete: {
            args: Prisma.UserNFTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>
          }
          update: {
            args: Prisma.UserNFTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>
          }
          deleteMany: {
            args: Prisma.UserNFTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNFTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserNFTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNFTPayload>
          }
          aggregate: {
            args: Prisma.UserNFTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNFT>
          }
          groupBy: {
            args: Prisma.UserNFTGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNFTGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNFTCountArgs<ExtArgs>
            result: $Utils.Optional<UserNFTCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      DirectMessage: {
        payload: Prisma.$DirectMessagePayload<ExtArgs>
        fields: Prisma.DirectMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirectMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirectMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findFirst: {
            args: Prisma.DirectMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirectMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findMany: {
            args: Prisma.DirectMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          create: {
            args: Prisma.DirectMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          createMany: {
            args: Prisma.DirectMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DirectMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          delete: {
            args: Prisma.DirectMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          update: {
            args: Prisma.DirectMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          deleteMany: {
            args: Prisma.DirectMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirectMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DirectMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          aggregate: {
            args: Prisma.DirectMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirectMessage>
          }
          groupBy: {
            args: Prisma.DirectMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirectMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageCountAggregateOutputType> | number
          }
        }
      }
      ActivityEvent: {
        payload: Prisma.$ActivityEventPayload<ExtArgs>
        fields: Prisma.ActivityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>
          }
          findFirst: {
            args: Prisma.ActivityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>
          }
          findMany: {
            args: Prisma.ActivityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>[]
          }
          create: {
            args: Prisma.ActivityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>
          }
          createMany: {
            args: Prisma.ActivityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>[]
          }
          delete: {
            args: Prisma.ActivityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>
          }
          update: {
            args: Prisma.ActivityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>
          }
          deleteMany: {
            args: Prisma.ActivityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityEventPayload>
          }
          aggregate: {
            args: Prisma.ActivityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityEvent>
          }
          groupBy: {
            args: Prisma.ActivityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityEventCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityEventCountAggregateOutputType> | number
          }
        }
      }
      VenueQuest: {
        payload: Prisma.$VenueQuestPayload<ExtArgs>
        fields: Prisma.VenueQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueQuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueQuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>
          }
          findFirst: {
            args: Prisma.VenueQuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueQuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>
          }
          findMany: {
            args: Prisma.VenueQuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>[]
          }
          create: {
            args: Prisma.VenueQuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>
          }
          createMany: {
            args: Prisma.VenueQuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueQuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>[]
          }
          delete: {
            args: Prisma.VenueQuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>
          }
          update: {
            args: Prisma.VenueQuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>
          }
          deleteMany: {
            args: Prisma.VenueQuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueQuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenueQuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueQuestPayload>
          }
          aggregate: {
            args: Prisma.VenueQuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenueQuest>
          }
          groupBy: {
            args: Prisma.VenueQuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueQuestCountArgs<ExtArgs>
            result: $Utils.Optional<VenueQuestCountAggregateOutputType> | number
          }
        }
      }
      GameSession: {
        payload: Prisma.$GameSessionPayload<ExtArgs>
        fields: Prisma.GameSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findFirst: {
            args: Prisma.GameSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findMany: {
            args: Prisma.GameSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          create: {
            args: Prisma.GameSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          createMany: {
            args: Prisma.GameSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          delete: {
            args: Prisma.GameSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          update: {
            args: Prisma.GameSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          deleteMany: {
            args: Prisma.GameSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          aggregate: {
            args: Prisma.GameSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameSession>
          }
          groupBy: {
            args: Prisma.GameSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameSessionCountArgs<ExtArgs>
            result: $Utils.Optional<GameSessionCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceItem: {
        payload: Prisma.$MarketplaceItemPayload<ExtArgs>
        fields: Prisma.MarketplaceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          findMany: {
            args: Prisma.MarketplaceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>[]
          }
          create: {
            args: Prisma.MarketplaceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          createMany: {
            args: Prisma.MarketplaceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>[]
          }
          delete: {
            args: Prisma.MarketplaceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          update: {
            args: Prisma.MarketplaceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceItem>
          }
          groupBy: {
            args: Prisma.MarketplaceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceItemCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceItemCountAggregateOutputType> | number
          }
        }
      }
      CommunityCosmeticItem: {
        payload: Prisma.$CommunityCosmeticItemPayload<ExtArgs>
        fields: Prisma.CommunityCosmeticItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityCosmeticItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityCosmeticItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>
          }
          findFirst: {
            args: Prisma.CommunityCosmeticItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityCosmeticItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>
          }
          findMany: {
            args: Prisma.CommunityCosmeticItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>[]
          }
          create: {
            args: Prisma.CommunityCosmeticItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>
          }
          createMany: {
            args: Prisma.CommunityCosmeticItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityCosmeticItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>[]
          }
          delete: {
            args: Prisma.CommunityCosmeticItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>
          }
          update: {
            args: Prisma.CommunityCosmeticItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>
          }
          deleteMany: {
            args: Prisma.CommunityCosmeticItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityCosmeticItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityCosmeticItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityCosmeticItemPayload>
          }
          aggregate: {
            args: Prisma.CommunityCosmeticItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityCosmeticItem>
          }
          groupBy: {
            args: Prisma.CommunityCosmeticItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityCosmeticItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCosmeticItemCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityCosmeticItemCountAggregateOutputType> | number
          }
        }
      }
      CosmeticItemLike: {
        payload: Prisma.$CosmeticItemLikePayload<ExtArgs>
        fields: Prisma.CosmeticItemLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CosmeticItemLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CosmeticItemLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>
          }
          findFirst: {
            args: Prisma.CosmeticItemLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CosmeticItemLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>
          }
          findMany: {
            args: Prisma.CosmeticItemLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>[]
          }
          create: {
            args: Prisma.CosmeticItemLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>
          }
          createMany: {
            args: Prisma.CosmeticItemLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CosmeticItemLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>[]
          }
          delete: {
            args: Prisma.CosmeticItemLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>
          }
          update: {
            args: Prisma.CosmeticItemLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>
          }
          deleteMany: {
            args: Prisma.CosmeticItemLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CosmeticItemLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CosmeticItemLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CosmeticItemLikePayload>
          }
          aggregate: {
            args: Prisma.CosmeticItemLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCosmeticItemLike>
          }
          groupBy: {
            args: Prisma.CosmeticItemLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CosmeticItemLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CosmeticItemLikeCountArgs<ExtArgs>
            result: $Utils.Optional<CosmeticItemLikeCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      ShadowRun: {
        payload: Prisma.$ShadowRunPayload<ExtArgs>
        fields: Prisma.ShadowRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShadowRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShadowRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>
          }
          findFirst: {
            args: Prisma.ShadowRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShadowRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>
          }
          findMany: {
            args: Prisma.ShadowRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>[]
          }
          create: {
            args: Prisma.ShadowRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>
          }
          createMany: {
            args: Prisma.ShadowRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShadowRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>[]
          }
          delete: {
            args: Prisma.ShadowRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>
          }
          update: {
            args: Prisma.ShadowRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>
          }
          deleteMany: {
            args: Prisma.ShadowRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShadowRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShadowRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShadowRunPayload>
          }
          aggregate: {
            args: Prisma.ShadowRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShadowRun>
          }
          groupBy: {
            args: Prisma.ShadowRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShadowRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShadowRunCountArgs<ExtArgs>
            result: $Utils.Optional<ShadowRunCountAggregateOutputType> | number
          }
        }
      }
      DojoCheckIn: {
        payload: Prisma.$DojoCheckInPayload<ExtArgs>
        fields: Prisma.DojoCheckInFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DojoCheckInFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DojoCheckInFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>
          }
          findFirst: {
            args: Prisma.DojoCheckInFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DojoCheckInFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>
          }
          findMany: {
            args: Prisma.DojoCheckInFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>[]
          }
          create: {
            args: Prisma.DojoCheckInCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>
          }
          createMany: {
            args: Prisma.DojoCheckInCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DojoCheckInCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>[]
          }
          delete: {
            args: Prisma.DojoCheckInDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>
          }
          update: {
            args: Prisma.DojoCheckInUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>
          }
          deleteMany: {
            args: Prisma.DojoCheckInDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DojoCheckInUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DojoCheckInUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DojoCheckInPayload>
          }
          aggregate: {
            args: Prisma.DojoCheckInAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDojoCheckIn>
          }
          groupBy: {
            args: Prisma.DojoCheckInGroupByArgs<ExtArgs>
            result: $Utils.Optional<DojoCheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.DojoCheckInCountArgs<ExtArgs>
            result: $Utils.Optional<DojoCheckInCountAggregateOutputType> | number
          }
        }
      }
      VenueSpecial: {
        payload: Prisma.$VenueSpecialPayload<ExtArgs>
        fields: Prisma.VenueSpecialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueSpecialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueSpecialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>
          }
          findFirst: {
            args: Prisma.VenueSpecialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueSpecialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>
          }
          findMany: {
            args: Prisma.VenueSpecialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>[]
          }
          create: {
            args: Prisma.VenueSpecialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>
          }
          createMany: {
            args: Prisma.VenueSpecialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueSpecialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>[]
          }
          delete: {
            args: Prisma.VenueSpecialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>
          }
          update: {
            args: Prisma.VenueSpecialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>
          }
          deleteMany: {
            args: Prisma.VenueSpecialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueSpecialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenueSpecialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueSpecialPayload>
          }
          aggregate: {
            args: Prisma.VenueSpecialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenueSpecial>
          }
          groupBy: {
            args: Prisma.VenueSpecialGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueSpecialGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueSpecialCountArgs<ExtArgs>
            result: $Utils.Optional<VenueSpecialCountAggregateOutputType> | number
          }
        }
      }
      UserInventoryItem: {
        payload: Prisma.$UserInventoryItemPayload<ExtArgs>
        fields: Prisma.UserInventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          findFirst: {
            args: Prisma.UserInventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          findMany: {
            args: Prisma.UserInventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>[]
          }
          create: {
            args: Prisma.UserInventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          createMany: {
            args: Prisma.UserInventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>[]
          }
          delete: {
            args: Prisma.UserInventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          update: {
            args: Prisma.UserInventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.UserInventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserInventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryItemPayload>
          }
          aggregate: {
            args: Prisma.UserInventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInventoryItem>
          }
          groupBy: {
            args: Prisma.UserInventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryItemCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Content: {
        payload: Prisma.$ContentPayload<ExtArgs>
        fields: Prisma.ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findFirst: {
            args: Prisma.ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findMany: {
            args: Prisma.ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          create: {
            args: Prisma.ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          createMany: {
            args: Prisma.ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          delete: {
            args: Prisma.ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          update: {
            args: Prisma.ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          deleteMany: {
            args: Prisma.ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          aggregate: {
            args: Prisma.ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContent>
          }
          groupBy: {
            args: Prisma.ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCountAggregateOutputType> | number
          }
        }
      }
      ContentLike: {
        payload: Prisma.$ContentLikePayload<ExtArgs>
        fields: Prisma.ContentLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>
          }
          findFirst: {
            args: Prisma.ContentLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>
          }
          findMany: {
            args: Prisma.ContentLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>[]
          }
          create: {
            args: Prisma.ContentLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>
          }
          createMany: {
            args: Prisma.ContentLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>[]
          }
          delete: {
            args: Prisma.ContentLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>
          }
          update: {
            args: Prisma.ContentLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>
          }
          deleteMany: {
            args: Prisma.ContentLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLikePayload>
          }
          aggregate: {
            args: Prisma.ContentLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentLike>
          }
          groupBy: {
            args: Prisma.ContentLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentLikeCountArgs<ExtArgs>
            result: $Utils.Optional<ContentLikeCountAggregateOutputType> | number
          }
        }
      }
      ContentShare: {
        payload: Prisma.$ContentSharePayload<ExtArgs>
        fields: Prisma.ContentShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>
          }
          findFirst: {
            args: Prisma.ContentShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>
          }
          findMany: {
            args: Prisma.ContentShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>[]
          }
          create: {
            args: Prisma.ContentShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>
          }
          createMany: {
            args: Prisma.ContentShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>[]
          }
          delete: {
            args: Prisma.ContentShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>
          }
          update: {
            args: Prisma.ContentShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>
          }
          deleteMany: {
            args: Prisma.ContentShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSharePayload>
          }
          aggregate: {
            args: Prisma.ContentShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentShare>
          }
          groupBy: {
            args: Prisma.ContentShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentShareCountArgs<ExtArgs>
            result: $Utils.Optional<ContentShareCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    wallets: number
    nfts: number
    achievements: number
    memberships: number
    territories: number
    checkIns: number
    challengesAsChallenger: number
    challengesAsDefender: number
    ledClans: number
    matchesAsPlayerA: number
    matchesAsPlayerB: number
    tournaments: number
    transactions: number
    notifications: number
    auditLogs: number
    venues: number
    friendshipsAsRequester: number
    friendshipsAsAddressee: number
    sentMessages: number
    receivedMessages: number
    activityEvents: number
    gameSessions: number
    shadowRuns: number
    dojoCheckIns: number
    inventoryItems: number
    feedback: number
    resolvedFeedback: number
    content: number
    moderatedContent: number
    contentLikes: number
    refreshTokens: number
    sharedContent: number
    receivedShares: number
    communityItems: number
    reviewedItems: number
    cosmeticLikes: number
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallets?: boolean | UserCountOutputTypeCountWalletsArgs
    nfts?: boolean | UserCountOutputTypeCountNftsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    territories?: boolean | UserCountOutputTypeCountTerritoriesArgs
    checkIns?: boolean | UserCountOutputTypeCountCheckInsArgs
    challengesAsChallenger?: boolean | UserCountOutputTypeCountChallengesAsChallengerArgs
    challengesAsDefender?: boolean | UserCountOutputTypeCountChallengesAsDefenderArgs
    ledClans?: boolean | UserCountOutputTypeCountLedClansArgs
    matchesAsPlayerA?: boolean | UserCountOutputTypeCountMatchesAsPlayerAArgs
    matchesAsPlayerB?: boolean | UserCountOutputTypeCountMatchesAsPlayerBArgs
    tournaments?: boolean | UserCountOutputTypeCountTournamentsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    venues?: boolean | UserCountOutputTypeCountVenuesArgs
    friendshipsAsRequester?: boolean | UserCountOutputTypeCountFriendshipsAsRequesterArgs
    friendshipsAsAddressee?: boolean | UserCountOutputTypeCountFriendshipsAsAddresseeArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    activityEvents?: boolean | UserCountOutputTypeCountActivityEventsArgs
    gameSessions?: boolean | UserCountOutputTypeCountGameSessionsArgs
    shadowRuns?: boolean | UserCountOutputTypeCountShadowRunsArgs
    dojoCheckIns?: boolean | UserCountOutputTypeCountDojoCheckInsArgs
    inventoryItems?: boolean | UserCountOutputTypeCountInventoryItemsArgs
    feedback?: boolean | UserCountOutputTypeCountFeedbackArgs
    resolvedFeedback?: boolean | UserCountOutputTypeCountResolvedFeedbackArgs
    content?: boolean | UserCountOutputTypeCountContentArgs
    moderatedContent?: boolean | UserCountOutputTypeCountModeratedContentArgs
    contentLikes?: boolean | UserCountOutputTypeCountContentLikesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    sharedContent?: boolean | UserCountOutputTypeCountSharedContentArgs
    receivedShares?: boolean | UserCountOutputTypeCountReceivedSharesArgs
    communityItems?: boolean | UserCountOutputTypeCountCommunityItemsArgs
    reviewedItems?: boolean | UserCountOutputTypeCountReviewedItemsArgs
    cosmeticLikes?: boolean | UserCountOutputTypeCountCosmeticLikesArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNFTWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClanMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTerritoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengesAsChallengerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengesAsDefenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLedClansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesAsPlayerAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesAsPlayerBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendshipsAsRequesterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendshipsAsAddresseeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShadowRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShadowRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDojoCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DojoCheckInWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResolvedFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModeratedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContentLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunityItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityCosmeticItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityCosmeticItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCosmeticLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CosmeticItemLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    tablesList: number
    tournaments: number
    territories: number
    checkIns: number
    challenges: number
    matches: number
    activityEvents: number
    quests: number
    specials: number
    dojoCheckIns: number
    shadowRuns: number
    gameSessions: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tablesList?: boolean | VenueCountOutputTypeCountTablesListArgs
    tournaments?: boolean | VenueCountOutputTypeCountTournamentsArgs
    territories?: boolean | VenueCountOutputTypeCountTerritoriesArgs
    checkIns?: boolean | VenueCountOutputTypeCountCheckInsArgs
    challenges?: boolean | VenueCountOutputTypeCountChallengesArgs
    matches?: boolean | VenueCountOutputTypeCountMatchesArgs
    activityEvents?: boolean | VenueCountOutputTypeCountActivityEventsArgs
    quests?: boolean | VenueCountOutputTypeCountQuestsArgs
    specials?: boolean | VenueCountOutputTypeCountSpecialsArgs
    dojoCheckIns?: boolean | VenueCountOutputTypeCountDojoCheckInsArgs
    shadowRuns?: boolean | VenueCountOutputTypeCountShadowRunsArgs
    gameSessions?: boolean | VenueCountOutputTypeCountGameSessionsArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountTablesListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountTournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountTerritoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoryWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountActivityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityEventWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueQuestWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountSpecialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueSpecialWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountDojoCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DojoCheckInWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountShadowRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShadowRunWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountGameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    matches: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matches?: boolean | TableCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }


  /**
   * Count Type ClanCountOutputType
   */

  export type ClanCountOutputType = {
    members: number
    territories: number
    controlledVenues: number
    activityEvents: number
    shadowRuns: number
  }

  export type ClanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ClanCountOutputTypeCountMembersArgs
    territories?: boolean | ClanCountOutputTypeCountTerritoriesArgs
    controlledVenues?: boolean | ClanCountOutputTypeCountControlledVenuesArgs
    activityEvents?: boolean | ClanCountOutputTypeCountActivityEventsArgs
    shadowRuns?: boolean | ClanCountOutputTypeCountShadowRunsArgs
  }

  // Custom InputTypes
  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanCountOutputType
     */
    select?: ClanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClanMemberWhereInput
  }

  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeCountTerritoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoryWhereInput
  }

  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeCountControlledVenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }

  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeCountActivityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityEventWhereInput
  }

  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeCountShadowRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShadowRunWhereInput
  }


  /**
   * Count Type TerritoryCountOutputType
   */

  export type TerritoryCountOutputType = {
    events: number
  }

  export type TerritoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | TerritoryCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * TerritoryCountOutputType without action
   */
  export type TerritoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryCountOutputType
     */
    select?: TerritoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TerritoryCountOutputType without action
   */
  export type TerritoryCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoryEventWhereInput
  }


  /**
   * Count Type TournamentCountOutputType
   */

  export type TournamentCountOutputType = {
    participants: number
    matches: number
    activityEvents: number
  }

  export type TournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | TournamentCountOutputTypeCountParticipantsArgs
    matches?: boolean | TournamentCountOutputTypeCountMatchesArgs
    activityEvents?: boolean | TournamentCountOutputTypeCountActivityEventsArgs
  }

  // Custom InputTypes
  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentCountOutputType
     */
    select?: TournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentParticipantWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountActivityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityEventWhereInput
  }


  /**
   * Count Type MatchCountOutputType
   */

  export type MatchCountOutputType = {
    events: number
    activityEvents: number
  }

  export type MatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | MatchCountOutputTypeCountEventsArgs
    activityEvents?: boolean | MatchCountOutputTypeCountActivityEventsArgs
  }

  // Custom InputTypes
  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchEventWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountActivityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityEventWhereInput
  }


  /**
   * Count Type NFTCountOutputType
   */

  export type NFTCountOutputType = {
    users: number
  }

  export type NFTCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | NFTCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * NFTCountOutputType without action
   */
  export type NFTCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTCountOutputType
     */
    select?: NFTCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NFTCountOutputType without action
   */
  export type NFTCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNFTWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    users: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AchievementCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type MarketplaceItemCountOutputType
   */

  export type MarketplaceItemCountOutputType = {
    inventoryItems: number
  }

  export type MarketplaceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | MarketplaceItemCountOutputTypeCountInventoryItemsArgs
  }

  // Custom InputTypes
  /**
   * MarketplaceItemCountOutputType without action
   */
  export type MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItemCountOutputType
     */
    select?: MarketplaceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketplaceItemCountOutputType without action
   */
  export type MarketplaceItemCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryItemWhereInput
  }


  /**
   * Count Type CommunityCosmeticItemCountOutputType
   */

  export type CommunityCosmeticItemCountOutputType = {
    likedBy: number
  }

  export type CommunityCosmeticItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likedBy?: boolean | CommunityCosmeticItemCountOutputTypeCountLikedByArgs
  }

  // Custom InputTypes
  /**
   * CommunityCosmeticItemCountOutputType without action
   */
  export type CommunityCosmeticItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItemCountOutputType
     */
    select?: CommunityCosmeticItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCosmeticItemCountOutputType without action
   */
  export type CommunityCosmeticItemCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CosmeticItemLikeWhereInput
  }


  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    likedBy: number
    sharedEntries: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likedBy?: boolean | ContentCountOutputTypeCountLikedByArgs
    sharedEntries?: boolean | ContentCountOutputTypeCountSharedEntriesArgs
  }

  // Custom InputTypes
  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentLikeWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountSharedEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentShareWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    dojoCoinBalance: number | null
  }

  export type UserSumAggregateOutputType = {
    dojoCoinBalance: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isBanned: boolean | null
    avatarUrl: string | null
    dojoCoinBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isBanned: boolean | null
    avatarUrl: string | null
    dojoCoinBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    role: number
    isBanned: number
    avatarUrl: number
    dojoCoinBalance: number
    createdAt: number
    updatedAt: number
    emailVerified: number
    image: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    dojoCoinBalance?: true
  }

  export type UserSumAggregateInputType = {
    dojoCoinBalance?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    isBanned?: true
    avatarUrl?: true
    dojoCoinBalance?: true
    createdAt?: true
    updatedAt?: true
    emailVerified?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    isBanned?: true
    avatarUrl?: true
    dojoCoinBalance?: true
    createdAt?: true
    updatedAt?: true
    emailVerified?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    role?: true
    isBanned?: true
    avatarUrl?: true
    dojoCoinBalance?: true
    createdAt?: true
    updatedAt?: true
    emailVerified?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    role: $Enums.UserRole
    isBanned: boolean
    avatarUrl: string | null
    dojoCoinBalance: number
    createdAt: Date
    updatedAt: Date
    emailVerified: Date | null
    image: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    isBanned?: boolean
    avatarUrl?: boolean
    dojoCoinBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerified?: boolean
    image?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    wallets?: boolean | User$walletsArgs<ExtArgs>
    nfts?: boolean | User$nftsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    territories?: boolean | User$territoriesArgs<ExtArgs>
    checkIns?: boolean | User$checkInsArgs<ExtArgs>
    challengesAsChallenger?: boolean | User$challengesAsChallengerArgs<ExtArgs>
    challengesAsDefender?: boolean | User$challengesAsDefenderArgs<ExtArgs>
    ledClans?: boolean | User$ledClansArgs<ExtArgs>
    matchesAsPlayerA?: boolean | User$matchesAsPlayerAArgs<ExtArgs>
    matchesAsPlayerB?: boolean | User$matchesAsPlayerBArgs<ExtArgs>
    tournaments?: boolean | User$tournamentsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    venues?: boolean | User$venuesArgs<ExtArgs>
    friendshipsAsRequester?: boolean | User$friendshipsAsRequesterArgs<ExtArgs>
    friendshipsAsAddressee?: boolean | User$friendshipsAsAddresseeArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    activityEvents?: boolean | User$activityEventsArgs<ExtArgs>
    gameSessions?: boolean | User$gameSessionsArgs<ExtArgs>
    shadowRuns?: boolean | User$shadowRunsArgs<ExtArgs>
    dojoCheckIns?: boolean | User$dojoCheckInsArgs<ExtArgs>
    inventoryItems?: boolean | User$inventoryItemsArgs<ExtArgs>
    feedback?: boolean | User$feedbackArgs<ExtArgs>
    resolvedFeedback?: boolean | User$resolvedFeedbackArgs<ExtArgs>
    content?: boolean | User$contentArgs<ExtArgs>
    moderatedContent?: boolean | User$moderatedContentArgs<ExtArgs>
    contentLikes?: boolean | User$contentLikesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    sharedContent?: boolean | User$sharedContentArgs<ExtArgs>
    receivedShares?: boolean | User$receivedSharesArgs<ExtArgs>
    communityItems?: boolean | User$communityItemsArgs<ExtArgs>
    reviewedItems?: boolean | User$reviewedItemsArgs<ExtArgs>
    cosmeticLikes?: boolean | User$cosmeticLikesArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    isBanned?: boolean
    avatarUrl?: boolean
    dojoCoinBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerified?: boolean
    image?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    role?: boolean
    isBanned?: boolean
    avatarUrl?: boolean
    dojoCoinBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emailVerified?: boolean
    image?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    wallets?: boolean | User$walletsArgs<ExtArgs>
    nfts?: boolean | User$nftsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    territories?: boolean | User$territoriesArgs<ExtArgs>
    checkIns?: boolean | User$checkInsArgs<ExtArgs>
    challengesAsChallenger?: boolean | User$challengesAsChallengerArgs<ExtArgs>
    challengesAsDefender?: boolean | User$challengesAsDefenderArgs<ExtArgs>
    ledClans?: boolean | User$ledClansArgs<ExtArgs>
    matchesAsPlayerA?: boolean | User$matchesAsPlayerAArgs<ExtArgs>
    matchesAsPlayerB?: boolean | User$matchesAsPlayerBArgs<ExtArgs>
    tournaments?: boolean | User$tournamentsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    venues?: boolean | User$venuesArgs<ExtArgs>
    friendshipsAsRequester?: boolean | User$friendshipsAsRequesterArgs<ExtArgs>
    friendshipsAsAddressee?: boolean | User$friendshipsAsAddresseeArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    activityEvents?: boolean | User$activityEventsArgs<ExtArgs>
    gameSessions?: boolean | User$gameSessionsArgs<ExtArgs>
    shadowRuns?: boolean | User$shadowRunsArgs<ExtArgs>
    dojoCheckIns?: boolean | User$dojoCheckInsArgs<ExtArgs>
    inventoryItems?: boolean | User$inventoryItemsArgs<ExtArgs>
    feedback?: boolean | User$feedbackArgs<ExtArgs>
    resolvedFeedback?: boolean | User$resolvedFeedbackArgs<ExtArgs>
    content?: boolean | User$contentArgs<ExtArgs>
    moderatedContent?: boolean | User$moderatedContentArgs<ExtArgs>
    contentLikes?: boolean | User$contentLikesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    sharedContent?: boolean | User$sharedContentArgs<ExtArgs>
    receivedShares?: boolean | User$receivedSharesArgs<ExtArgs>
    communityItems?: boolean | User$communityItemsArgs<ExtArgs>
    reviewedItems?: boolean | User$reviewedItemsArgs<ExtArgs>
    cosmeticLikes?: boolean | User$cosmeticLikesArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      wallets: Prisma.$WalletPayload<ExtArgs>[]
      nfts: Prisma.$UserNFTPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      memberships: Prisma.$ClanMemberPayload<ExtArgs>[]
      territories: Prisma.$TerritoryPayload<ExtArgs>[]
      checkIns: Prisma.$CheckInPayload<ExtArgs>[]
      challengesAsChallenger: Prisma.$ChallengePayload<ExtArgs>[]
      challengesAsDefender: Prisma.$ChallengePayload<ExtArgs>[]
      ledClans: Prisma.$ClanPayload<ExtArgs>[]
      matchesAsPlayerA: Prisma.$MatchPayload<ExtArgs>[]
      matchesAsPlayerB: Prisma.$MatchPayload<ExtArgs>[]
      tournaments: Prisma.$TournamentParticipantPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      venues: Prisma.$VenuePayload<ExtArgs>[]
      friendshipsAsRequester: Prisma.$FriendshipPayload<ExtArgs>[]
      friendshipsAsAddressee: Prisma.$FriendshipPayload<ExtArgs>[]
      sentMessages: Prisma.$DirectMessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$DirectMessagePayload<ExtArgs>[]
      activityEvents: Prisma.$ActivityEventPayload<ExtArgs>[]
      gameSessions: Prisma.$GameSessionPayload<ExtArgs>[]
      shadowRuns: Prisma.$ShadowRunPayload<ExtArgs>[]
      dojoCheckIns: Prisma.$DojoCheckInPayload<ExtArgs>[]
      inventoryItems: Prisma.$UserInventoryItemPayload<ExtArgs>[]
      feedback: Prisma.$FeedbackPayload<ExtArgs>[]
      resolvedFeedback: Prisma.$FeedbackPayload<ExtArgs>[]
      content: Prisma.$ContentPayload<ExtArgs>[]
      moderatedContent: Prisma.$ContentPayload<ExtArgs>[]
      contentLikes: Prisma.$ContentLikePayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      sharedContent: Prisma.$ContentSharePayload<ExtArgs>[]
      receivedShares: Prisma.$ContentSharePayload<ExtArgs>[]
      communityItems: Prisma.$CommunityCosmeticItemPayload<ExtArgs>[]
      reviewedItems: Prisma.$CommunityCosmeticItemPayload<ExtArgs>[]
      cosmeticLikes: Prisma.$CosmeticItemLikePayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      role: $Enums.UserRole
      isBanned: boolean
      avatarUrl: string | null
      dojoCoinBalance: number
      createdAt: Date
      updatedAt: Date
      emailVerified: Date | null
      image: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    wallets<T extends User$walletsArgs<ExtArgs> = {}>(args?: Subset<T, User$walletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany"> | Null>
    nfts<T extends User$nftsArgs<ExtArgs> = {}>(args?: Subset<T, User$nftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "findMany"> | Null>
    territories<T extends User$territoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$territoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findMany"> | Null>
    checkIns<T extends User$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, User$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany"> | Null>
    challengesAsChallenger<T extends User$challengesAsChallengerArgs<ExtArgs> = {}>(args?: Subset<T, User$challengesAsChallengerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany"> | Null>
    challengesAsDefender<T extends User$challengesAsDefenderArgs<ExtArgs> = {}>(args?: Subset<T, User$challengesAsDefenderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany"> | Null>
    ledClans<T extends User$ledClansArgs<ExtArgs> = {}>(args?: Subset<T, User$ledClansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findMany"> | Null>
    matchesAsPlayerA<T extends User$matchesAsPlayerAArgs<ExtArgs> = {}>(args?: Subset<T, User$matchesAsPlayerAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany"> | Null>
    matchesAsPlayerB<T extends User$matchesAsPlayerBArgs<ExtArgs> = {}>(args?: Subset<T, User$matchesAsPlayerBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany"> | Null>
    tournaments<T extends User$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, User$tournamentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    venues<T extends User$venuesArgs<ExtArgs> = {}>(args?: Subset<T, User$venuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany"> | Null>
    friendshipsAsRequester<T extends User$friendshipsAsRequesterArgs<ExtArgs> = {}>(args?: Subset<T, User$friendshipsAsRequesterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    friendshipsAsAddressee<T extends User$friendshipsAsAddresseeArgs<ExtArgs> = {}>(args?: Subset<T, User$friendshipsAsAddresseeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany"> | Null>
    activityEvents<T extends User$activityEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findMany"> | Null>
    gameSessions<T extends User$gameSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$gameSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany"> | Null>
    shadowRuns<T extends User$shadowRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$shadowRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findMany"> | Null>
    dojoCheckIns<T extends User$dojoCheckInsArgs<ExtArgs> = {}>(args?: Subset<T, User$dojoCheckInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryItems<T extends User$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    feedback<T extends User$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    resolvedFeedback<T extends User$resolvedFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, User$resolvedFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    content<T extends User$contentArgs<ExtArgs> = {}>(args?: Subset<T, User$contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany"> | Null>
    moderatedContent<T extends User$moderatedContentArgs<ExtArgs> = {}>(args?: Subset<T, User$moderatedContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany"> | Null>
    contentLikes<T extends User$contentLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$contentLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "findMany"> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    sharedContent<T extends User$sharedContentArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findMany"> | Null>
    receivedShares<T extends User$receivedSharesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findMany"> | Null>
    communityItems<T extends User$communityItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$communityItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findMany"> | Null>
    reviewedItems<T extends User$reviewedItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findMany"> | Null>
    cosmeticLikes<T extends User$cosmeticLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$cosmeticLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly dojoCoinBalance: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.wallets
   */
  export type User$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    cursor?: WalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * User.nfts
   */
  export type User$nftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    where?: UserNFTWhereInput
    orderBy?: UserNFTOrderByWithRelationInput | UserNFTOrderByWithRelationInput[]
    cursor?: UserNFTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNFTScalarFieldEnum | UserNFTScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    where?: ClanMemberWhereInput
    orderBy?: ClanMemberOrderByWithRelationInput | ClanMemberOrderByWithRelationInput[]
    cursor?: ClanMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClanMemberScalarFieldEnum | ClanMemberScalarFieldEnum[]
  }

  /**
   * User.territories
   */
  export type User$territoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    where?: TerritoryWhereInput
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    cursor?: TerritoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * User.checkIns
   */
  export type User$checkInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    cursor?: CheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * User.challengesAsChallenger
   */
  export type User$challengesAsChallengerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * User.challengesAsDefender
   */
  export type User$challengesAsDefenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * User.ledClans
   */
  export type User$ledClansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    where?: ClanWhereInput
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    cursor?: ClanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClanScalarFieldEnum | ClanScalarFieldEnum[]
  }

  /**
   * User.matchesAsPlayerA
   */
  export type User$matchesAsPlayerAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.matchesAsPlayerB
   */
  export type User$matchesAsPlayerBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.tournaments
   */
  export type User$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    where?: TournamentParticipantWhereInput
    orderBy?: TournamentParticipantOrderByWithRelationInput | TournamentParticipantOrderByWithRelationInput[]
    cursor?: TournamentParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentParticipantScalarFieldEnum | TournamentParticipantScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.venues
   */
  export type User$venuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * User.friendshipsAsRequester
   */
  export type User$friendshipsAsRequesterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.friendshipsAsAddressee
   */
  export type User$friendshipsAsAddresseeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * User.activityEvents
   */
  export type User$activityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    where?: ActivityEventWhereInput
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    cursor?: ActivityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * User.gameSessions
   */
  export type User$gameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * User.shadowRuns
   */
  export type User$shadowRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    where?: ShadowRunWhereInput
    orderBy?: ShadowRunOrderByWithRelationInput | ShadowRunOrderByWithRelationInput[]
    cursor?: ShadowRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShadowRunScalarFieldEnum | ShadowRunScalarFieldEnum[]
  }

  /**
   * User.dojoCheckIns
   */
  export type User$dojoCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    where?: DojoCheckInWhereInput
    orderBy?: DojoCheckInOrderByWithRelationInput | DojoCheckInOrderByWithRelationInput[]
    cursor?: DojoCheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DojoCheckInScalarFieldEnum | DojoCheckInScalarFieldEnum[]
  }

  /**
   * User.inventoryItems
   */
  export type User$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    where?: UserInventoryItemWhereInput
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    cursor?: UserInventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * User.feedback
   */
  export type User$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.resolvedFeedback
   */
  export type User$resolvedFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.content
   */
  export type User$contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * User.moderatedContent
   */
  export type User$moderatedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    cursor?: ContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * User.contentLikes
   */
  export type User$contentLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    where?: ContentLikeWhereInput
    orderBy?: ContentLikeOrderByWithRelationInput | ContentLikeOrderByWithRelationInput[]
    cursor?: ContentLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentLikeScalarFieldEnum | ContentLikeScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.sharedContent
   */
  export type User$sharedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    where?: ContentShareWhereInput
    orderBy?: ContentShareOrderByWithRelationInput | ContentShareOrderByWithRelationInput[]
    cursor?: ContentShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentShareScalarFieldEnum | ContentShareScalarFieldEnum[]
  }

  /**
   * User.receivedShares
   */
  export type User$receivedSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    where?: ContentShareWhereInput
    orderBy?: ContentShareOrderByWithRelationInput | ContentShareOrderByWithRelationInput[]
    cursor?: ContentShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentShareScalarFieldEnum | ContentShareScalarFieldEnum[]
  }

  /**
   * User.communityItems
   */
  export type User$communityItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    where?: CommunityCosmeticItemWhereInput
    orderBy?: CommunityCosmeticItemOrderByWithRelationInput | CommunityCosmeticItemOrderByWithRelationInput[]
    cursor?: CommunityCosmeticItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityCosmeticItemScalarFieldEnum | CommunityCosmeticItemScalarFieldEnum[]
  }

  /**
   * User.reviewedItems
   */
  export type User$reviewedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    where?: CommunityCosmeticItemWhereInput
    orderBy?: CommunityCosmeticItemOrderByWithRelationInput | CommunityCosmeticItemOrderByWithRelationInput[]
    cursor?: CommunityCosmeticItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityCosmeticItemScalarFieldEnum | CommunityCosmeticItemScalarFieldEnum[]
  }

  /**
   * User.cosmeticLikes
   */
  export type User$cosmeticLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    where?: CosmeticItemLikeWhereInput
    orderBy?: CosmeticItemLikeOrderByWithRelationInput | CosmeticItemLikeOrderByWithRelationInput[]
    cursor?: CosmeticItemLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CosmeticItemLikeScalarFieldEnum | CosmeticItemLikeScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    skillRating: number | null
  }

  export type ProfileSumAggregateOutputType = {
    skillRating: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    avatarUrl: string | null
    location: string | null
    skillRating: number | null
    clanTitle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    avatarUrl: string | null
    location: string | null
    skillRating: number | null
    clanTitle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    bio: number
    avatarUrl: number
    location: number
    skillRating: number
    clanTitle: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    skillRating?: true
  }

  export type ProfileSumAggregateInputType = {
    skillRating?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    avatarUrl?: true
    location?: true
    skillRating?: true
    clanTitle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    avatarUrl?: true
    location?: true
    skillRating?: true
    clanTitle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    avatarUrl?: true
    location?: true
    skillRating?: true
    clanTitle?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string | null
    bio: string | null
    avatarUrl: string | null
    location: string | null
    skillRating: number
    clanTitle: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    avatarUrl?: boolean
    location?: boolean
    skillRating?: boolean
    clanTitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    avatarUrl?: boolean
    location?: boolean
    skillRating?: boolean
    clanTitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    avatarUrl?: boolean
    location?: boolean
    skillRating?: boolean
    clanTitle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string | null
      bio: string | null
      avatarUrl: string | null
      location: string | null
      skillRating: number
      clanTitle: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly displayName: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly avatarUrl: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly skillRating: FieldRef<"Profile", 'Int'>
    readonly clanTitle: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    pushNotifications: boolean | null
    darkMode: boolean | null
    language: string | null
    timezone: string | null
    privacySettings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotifications: boolean | null
    pushNotifications: boolean | null
    darkMode: boolean | null
    language: string | null
    timezone: string | null
    privacySettings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    emailNotifications: number
    pushNotifications: number
    darkMode: number
    language: number
    timezone: number
    privacySettings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    pushNotifications?: true
    darkMode?: true
    language?: true
    timezone?: true
    privacySettings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    pushNotifications?: true
    darkMode?: true
    language?: true
    timezone?: true
    privacySettings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    emailNotifications?: true
    pushNotifications?: true
    darkMode?: true
    language?: true
    timezone?: true
    privacySettings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    emailNotifications: boolean
    pushNotifications: boolean
    darkMode: boolean
    language: string
    timezone: string
    privacySettings: string
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: boolean
    timezone?: boolean
    privacySettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: boolean
    timezone?: boolean
    privacySettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: boolean
    timezone?: boolean
    privacySettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailNotifications: boolean
      pushNotifications: boolean
      darkMode: boolean
      language: string
      timezone: string
      privacySettings: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */ 
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly emailNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly pushNotifications: FieldRef<"UserSettings", 'Boolean'>
    readonly darkMode: FieldRef<"UserSettings", 'Boolean'>
    readonly language: FieldRef<"UserSettings", 'String'>
    readonly timezone: FieldRef<"UserSettings", 'String'>
    readonly privacySettings: FieldRef<"UserSettings", 'String'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
    incomeModifier: number | null
    defenseLevel: number | null
    rating: number | null
    tables: number | null
  }

  export type VenueSumAggregateOutputType = {
    lat: number | null
    lng: number | null
    incomeModifier: number | null
    defenseLevel: number | null
    rating: number | null
    tables: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    lat: number | null
    lng: number | null
    address: string | null
    ownerId: string | null
    controllingClanId: string | null
    incomeModifier: number | null
    defenseLevel: number | null
    status: string | null
    photos: string | null
    rating: number | null
    features: string | null
    tables: number | null
    reviews: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    lat: number | null
    lng: number | null
    address: string | null
    ownerId: string | null
    controllingClanId: string | null
    incomeModifier: number | null
    defenseLevel: number | null
    status: string | null
    photos: string | null
    rating: number | null
    features: string | null
    tables: number | null
    reviews: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    name: number
    description: number
    lat: number
    lng: number
    address: number
    ownerId: number
    controllingClanId: number
    incomeModifier: number
    defenseLevel: number
    status: number
    photos: number
    rating: number
    features: number
    tables: number
    reviews: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    lat?: true
    lng?: true
    incomeModifier?: true
    defenseLevel?: true
    rating?: true
    tables?: true
  }

  export type VenueSumAggregateInputType = {
    lat?: true
    lng?: true
    incomeModifier?: true
    defenseLevel?: true
    rating?: true
    tables?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lat?: true
    lng?: true
    address?: true
    ownerId?: true
    controllingClanId?: true
    incomeModifier?: true
    defenseLevel?: true
    status?: true
    photos?: true
    rating?: true
    features?: true
    tables?: true
    reviews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lat?: true
    lng?: true
    address?: true
    ownerId?: true
    controllingClanId?: true
    incomeModifier?: true
    defenseLevel?: true
    status?: true
    photos?: true
    rating?: true
    features?: true
    tables?: true
    reviews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lat?: true
    lng?: true
    address?: true
    ownerId?: true
    controllingClanId?: true
    incomeModifier?: true
    defenseLevel?: true
    status?: true
    photos?: true
    rating?: true
    features?: true
    tables?: true
    reviews?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: string
    name: string
    description: string | null
    lat: number
    lng: number
    address: string | null
    ownerId: string | null
    controllingClanId: string | null
    incomeModifier: number
    defenseLevel: number
    status: string
    photos: string
    rating: number
    features: string
    tables: number
    reviews: string
    createdAt: Date
    updatedAt: Date
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    lat?: boolean
    lng?: boolean
    address?: boolean
    ownerId?: boolean
    controllingClanId?: boolean
    incomeModifier?: boolean
    defenseLevel?: boolean
    status?: boolean
    photos?: boolean
    rating?: boolean
    features?: boolean
    tables?: boolean
    reviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Venue$ownerArgs<ExtArgs>
    controllingClan?: boolean | Venue$controllingClanArgs<ExtArgs>
    tablesList?: boolean | Venue$tablesListArgs<ExtArgs>
    tournaments?: boolean | Venue$tournamentsArgs<ExtArgs>
    territories?: boolean | Venue$territoriesArgs<ExtArgs>
    checkIns?: boolean | Venue$checkInsArgs<ExtArgs>
    challenges?: boolean | Venue$challengesArgs<ExtArgs>
    matches?: boolean | Venue$matchesArgs<ExtArgs>
    activityEvents?: boolean | Venue$activityEventsArgs<ExtArgs>
    quests?: boolean | Venue$questsArgs<ExtArgs>
    specials?: boolean | Venue$specialsArgs<ExtArgs>
    dojoCheckIns?: boolean | Venue$dojoCheckInsArgs<ExtArgs>
    shadowRuns?: boolean | Venue$shadowRunsArgs<ExtArgs>
    gameSessions?: boolean | Venue$gameSessionsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    lat?: boolean
    lng?: boolean
    address?: boolean
    ownerId?: boolean
    controllingClanId?: boolean
    incomeModifier?: boolean
    defenseLevel?: boolean
    status?: boolean
    photos?: boolean
    rating?: boolean
    features?: boolean
    tables?: boolean
    reviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | Venue$ownerArgs<ExtArgs>
    controllingClan?: boolean | Venue$controllingClanArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    lat?: boolean
    lng?: boolean
    address?: boolean
    ownerId?: boolean
    controllingClanId?: boolean
    incomeModifier?: boolean
    defenseLevel?: boolean
    status?: boolean
    photos?: boolean
    rating?: boolean
    features?: boolean
    tables?: boolean
    reviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Venue$ownerArgs<ExtArgs>
    controllingClan?: boolean | Venue$controllingClanArgs<ExtArgs>
    tablesList?: boolean | Venue$tablesListArgs<ExtArgs>
    tournaments?: boolean | Venue$tournamentsArgs<ExtArgs>
    territories?: boolean | Venue$territoriesArgs<ExtArgs>
    checkIns?: boolean | Venue$checkInsArgs<ExtArgs>
    challenges?: boolean | Venue$challengesArgs<ExtArgs>
    matches?: boolean | Venue$matchesArgs<ExtArgs>
    activityEvents?: boolean | Venue$activityEventsArgs<ExtArgs>
    quests?: boolean | Venue$questsArgs<ExtArgs>
    specials?: boolean | Venue$specialsArgs<ExtArgs>
    dojoCheckIns?: boolean | Venue$dojoCheckInsArgs<ExtArgs>
    shadowRuns?: boolean | Venue$shadowRunsArgs<ExtArgs>
    gameSessions?: boolean | Venue$gameSessionsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Venue$ownerArgs<ExtArgs>
    controllingClan?: boolean | Venue$controllingClanArgs<ExtArgs>
  }

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      controllingClan: Prisma.$ClanPayload<ExtArgs> | null
      tablesList: Prisma.$TablePayload<ExtArgs>[]
      tournaments: Prisma.$TournamentPayload<ExtArgs>[]
      territories: Prisma.$TerritoryPayload<ExtArgs>[]
      checkIns: Prisma.$CheckInPayload<ExtArgs>[]
      challenges: Prisma.$ChallengePayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
      activityEvents: Prisma.$ActivityEventPayload<ExtArgs>[]
      quests: Prisma.$VenueQuestPayload<ExtArgs>[]
      specials: Prisma.$VenueSpecialPayload<ExtArgs>[]
      dojoCheckIns: Prisma.$DojoCheckInPayload<ExtArgs>[]
      shadowRuns: Prisma.$ShadowRunPayload<ExtArgs>[]
      gameSessions: Prisma.$GameSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      lat: number
      lng: number
      address: string | null
      ownerId: string | null
      controllingClanId: string | null
      incomeModifier: number
      defenseLevel: number
      status: string
      photos: string
      rating: number
      features: string
      tables: number
      reviews: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Venues and returns the data saved in the database.
     * @param {VenueCreateManyAndReturnArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Venues and only return the `id`
     * const venueWithIdOnly = await prisma.venue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends Venue$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Venue$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    controllingClan<T extends Venue$controllingClanArgs<ExtArgs> = {}>(args?: Subset<T, Venue$controllingClanArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tablesList<T extends Venue$tablesListArgs<ExtArgs> = {}>(args?: Subset<T, Venue$tablesListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany"> | Null>
    tournaments<T extends Venue$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$tournamentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany"> | Null>
    territories<T extends Venue$territoriesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$territoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findMany"> | Null>
    checkIns<T extends Venue$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany"> | Null>
    challenges<T extends Venue$challengesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany"> | Null>
    matches<T extends Venue$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany"> | Null>
    activityEvents<T extends Venue$activityEventsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$activityEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findMany"> | Null>
    quests<T extends Venue$questsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "findMany"> | Null>
    specials<T extends Venue$specialsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$specialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "findMany"> | Null>
    dojoCheckIns<T extends Venue$dojoCheckInsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$dojoCheckInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "findMany"> | Null>
    shadowRuns<T extends Venue$shadowRunsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$shadowRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findMany"> | Null>
    gameSessions<T extends Venue$gameSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$gameSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */ 
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'String'>
    readonly name: FieldRef<"Venue", 'String'>
    readonly description: FieldRef<"Venue", 'String'>
    readonly lat: FieldRef<"Venue", 'Float'>
    readonly lng: FieldRef<"Venue", 'Float'>
    readonly address: FieldRef<"Venue", 'String'>
    readonly ownerId: FieldRef<"Venue", 'String'>
    readonly controllingClanId: FieldRef<"Venue", 'String'>
    readonly incomeModifier: FieldRef<"Venue", 'Float'>
    readonly defenseLevel: FieldRef<"Venue", 'Int'>
    readonly status: FieldRef<"Venue", 'String'>
    readonly photos: FieldRef<"Venue", 'String'>
    readonly rating: FieldRef<"Venue", 'Float'>
    readonly features: FieldRef<"Venue", 'String'>
    readonly tables: FieldRef<"Venue", 'Int'>
    readonly reviews: FieldRef<"Venue", 'String'>
    readonly createdAt: FieldRef<"Venue", 'DateTime'>
    readonly updatedAt: FieldRef<"Venue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue createManyAndReturn
   */
  export type VenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
  }

  /**
   * Venue.owner
   */
  export type Venue$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Venue.controllingClan
   */
  export type Venue$controllingClanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    where?: ClanWhereInput
  }

  /**
   * Venue.tablesList
   */
  export type Venue$tablesListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Venue.tournaments
   */
  export type Venue$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    cursor?: TournamentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Venue.territories
   */
  export type Venue$territoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    where?: TerritoryWhereInput
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    cursor?: TerritoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Venue.checkIns
   */
  export type Venue$checkInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    cursor?: CheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * Venue.challenges
   */
  export type Venue$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Venue.matches
   */
  export type Venue$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Venue.activityEvents
   */
  export type Venue$activityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    where?: ActivityEventWhereInput
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    cursor?: ActivityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * Venue.quests
   */
  export type Venue$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    where?: VenueQuestWhereInput
    orderBy?: VenueQuestOrderByWithRelationInput | VenueQuestOrderByWithRelationInput[]
    cursor?: VenueQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueQuestScalarFieldEnum | VenueQuestScalarFieldEnum[]
  }

  /**
   * Venue.specials
   */
  export type Venue$specialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    where?: VenueSpecialWhereInput
    orderBy?: VenueSpecialOrderByWithRelationInput | VenueSpecialOrderByWithRelationInput[]
    cursor?: VenueSpecialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueSpecialScalarFieldEnum | VenueSpecialScalarFieldEnum[]
  }

  /**
   * Venue.dojoCheckIns
   */
  export type Venue$dojoCheckInsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    where?: DojoCheckInWhereInput
    orderBy?: DojoCheckInOrderByWithRelationInput | DojoCheckInOrderByWithRelationInput[]
    cursor?: DojoCheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DojoCheckInScalarFieldEnum | DojoCheckInScalarFieldEnum[]
  }

  /**
   * Venue.shadowRuns
   */
  export type Venue$shadowRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    where?: ShadowRunWhereInput
    orderBy?: ShadowRunOrderByWithRelationInput | ShadowRunOrderByWithRelationInput[]
    cursor?: ShadowRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShadowRunScalarFieldEnum | ShadowRunScalarFieldEnum[]
  }

  /**
   * Venue.gameSessions
   */
  export type Venue$gameSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    name: string | null
    status: $Enums.TableStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    name: string | null
    status: $Enums.TableStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    venueId: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TableMinAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: string
    venueId: string
    name: string
    status: $Enums.TableStatus
    createdAt: Date
    updatedAt: Date
    _count: TableCountAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    matches?: boolean | Table$matchesArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectScalar = {
    id?: boolean
    venueId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    matches?: boolean | Table$matchesArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
      matches: Prisma.$MatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      name: string
      status: $Enums.TableStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tables and returns the data saved in the database.
     * @param {TableCreateManyAndReturnArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tables and only return the `id`
     * const tableWithIdOnly = await prisma.table.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableCreateManyAndReturnArgs>(args?: SelectSubset<T, TableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    matches<T extends Table$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Table$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */ 
  interface TableFieldRefs {
    readonly id: FieldRef<"Table", 'String'>
    readonly venueId: FieldRef<"Table", 'String'>
    readonly name: FieldRef<"Table", 'String'>
    readonly status: FieldRef<"Table", 'TableStatus'>
    readonly createdAt: FieldRef<"Table", 'DateTime'>
    readonly updatedAt: FieldRef<"Table", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Table createManyAndReturn
   */
  export type TableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
  }

  /**
   * Table.matches
   */
  export type Table$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model CheckIn
   */

  export type AggregateCheckIn = {
    _count: CheckInCountAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  export type CheckInMinAggregateOutputType = {
    id: string | null
    userId: string | null
    venueId: string | null
    via: $Enums.CheckInMethod | null
    createdAt: Date | null
  }

  export type CheckInMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    venueId: string | null
    via: $Enums.CheckInMethod | null
    createdAt: Date | null
  }

  export type CheckInCountAggregateOutputType = {
    id: number
    userId: number
    venueId: number
    via: number
    createdAt: number
    _all: number
  }


  export type CheckInMinAggregateInputType = {
    id?: true
    userId?: true
    venueId?: true
    via?: true
    createdAt?: true
  }

  export type CheckInMaxAggregateInputType = {
    id?: true
    userId?: true
    venueId?: true
    via?: true
    createdAt?: true
  }

  export type CheckInCountAggregateInputType = {
    id?: true
    userId?: true
    venueId?: true
    via?: true
    createdAt?: true
    _all?: true
  }

  export type CheckInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIn to aggregate.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckIns
    **/
    _count?: true | CheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckInMaxAggregateInputType
  }

  export type GetCheckInAggregateType<T extends CheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckIn[P]>
      : GetScalarType<T[P], AggregateCheckIn[P]>
  }




  export type CheckInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
    orderBy?: CheckInOrderByWithAggregationInput | CheckInOrderByWithAggregationInput[]
    by: CheckInScalarFieldEnum[] | CheckInScalarFieldEnum
    having?: CheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckInCountAggregateInputType | true
    _min?: CheckInMinAggregateInputType
    _max?: CheckInMaxAggregateInputType
  }

  export type CheckInGroupByOutputType = {
    id: string
    userId: string
    venueId: string
    via: $Enums.CheckInMethod
    createdAt: Date
    _count: CheckInCountAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  type GetCheckInGroupByPayload<T extends CheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckInGroupByOutputType[P]>
            : GetScalarType<T[P], CheckInGroupByOutputType[P]>
        }
      >
    >


  export type CheckInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    venueId?: boolean
    via?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    venueId?: boolean
    via?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectScalar = {
    id?: boolean
    userId?: boolean
    venueId?: boolean
    via?: boolean
    createdAt?: boolean
  }

  export type CheckInInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type CheckInIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $CheckInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckIn"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      venueId: string
      via: $Enums.CheckInMethod
      createdAt: Date
    }, ExtArgs["result"]["checkIn"]>
    composites: {}
  }

  type CheckInGetPayload<S extends boolean | null | undefined | CheckInDefaultArgs> = $Result.GetResult<Prisma.$CheckInPayload, S>

  type CheckInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckInFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheckInCountAggregateInputType | true
    }

  export interface CheckInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckIn'], meta: { name: 'CheckIn' } }
    /**
     * Find zero or one CheckIn that matches the filter.
     * @param {CheckInFindUniqueArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckInFindUniqueArgs>(args: SelectSubset<T, CheckInFindUniqueArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CheckIn that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheckInFindUniqueOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckInFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckInFindFirstArgs>(args?: SelectSubset<T, CheckInFindFirstArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CheckIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckInFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckInFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckIns
     * const checkIns = await prisma.checkIn.findMany()
     * 
     * // Get first 10 CheckIns
     * const checkIns = await prisma.checkIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkInWithIdOnly = await prisma.checkIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckInFindManyArgs>(args?: SelectSubset<T, CheckInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CheckIn.
     * @param {CheckInCreateArgs} args - Arguments to create a CheckIn.
     * @example
     * // Create one CheckIn
     * const CheckIn = await prisma.checkIn.create({
     *   data: {
     *     // ... data to create a CheckIn
     *   }
     * })
     * 
     */
    create<T extends CheckInCreateArgs>(args: SelectSubset<T, CheckInCreateArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CheckIns.
     * @param {CheckInCreateManyArgs} args - Arguments to create many CheckIns.
     * @example
     * // Create many CheckIns
     * const checkIn = await prisma.checkIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckInCreateManyArgs>(args?: SelectSubset<T, CheckInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheckIns and returns the data saved in the database.
     * @param {CheckInCreateManyAndReturnArgs} args - Arguments to create many CheckIns.
     * @example
     * // Create many CheckIns
     * const checkIn = await prisma.checkIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheckIns and only return the `id`
     * const checkInWithIdOnly = await prisma.checkIn.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckInCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CheckIn.
     * @param {CheckInDeleteArgs} args - Arguments to delete one CheckIn.
     * @example
     * // Delete one CheckIn
     * const CheckIn = await prisma.checkIn.delete({
     *   where: {
     *     // ... filter to delete one CheckIn
     *   }
     * })
     * 
     */
    delete<T extends CheckInDeleteArgs>(args: SelectSubset<T, CheckInDeleteArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CheckIn.
     * @param {CheckInUpdateArgs} args - Arguments to update one CheckIn.
     * @example
     * // Update one CheckIn
     * const checkIn = await prisma.checkIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckInUpdateArgs>(args: SelectSubset<T, CheckInUpdateArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CheckIns.
     * @param {CheckInDeleteManyArgs} args - Arguments to filter CheckIns to delete.
     * @example
     * // Delete a few CheckIns
     * const { count } = await prisma.checkIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckInDeleteManyArgs>(args?: SelectSubset<T, CheckInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckIns
     * const checkIn = await prisma.checkIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckInUpdateManyArgs>(args: SelectSubset<T, CheckInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckIn.
     * @param {CheckInUpsertArgs} args - Arguments to update or create a CheckIn.
     * @example
     * // Update or create a CheckIn
     * const checkIn = await prisma.checkIn.upsert({
     *   create: {
     *     // ... data to create a CheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckIn we want to update
     *   }
     * })
     */
    upsert<T extends CheckInUpsertArgs>(args: SelectSubset<T, CheckInUpsertArgs<ExtArgs>>): Prisma__CheckInClient<$Result.GetResult<Prisma.$CheckInPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInCountArgs} args - Arguments to filter CheckIns to count.
     * @example
     * // Count the number of CheckIns
     * const count = await prisma.checkIn.count({
     *   where: {
     *     // ... the filter for the CheckIns we want to count
     *   }
     * })
    **/
    count<T extends CheckInCountArgs>(
      args?: Subset<T, CheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckInAggregateArgs>(args: Subset<T, CheckInAggregateArgs>): Prisma.PrismaPromise<GetCheckInAggregateType<T>>

    /**
     * Group by CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckInGroupByArgs['orderBy'] }
        : { orderBy?: CheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckIn model
   */
  readonly fields: CheckInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckIn model
   */ 
  interface CheckInFieldRefs {
    readonly id: FieldRef<"CheckIn", 'String'>
    readonly userId: FieldRef<"CheckIn", 'String'>
    readonly venueId: FieldRef<"CheckIn", 'String'>
    readonly via: FieldRef<"CheckIn", 'CheckInMethod'>
    readonly createdAt: FieldRef<"CheckIn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CheckIn findUnique
   */
  export type CheckInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn findUniqueOrThrow
   */
  export type CheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn findFirst
   */
  export type CheckInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn findFirstOrThrow
   */
  export type CheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn findMany
   */
  export type CheckInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIns to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: CheckInOrderByWithRelationInput | CheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    distinct?: CheckInScalarFieldEnum | CheckInScalarFieldEnum[]
  }

  /**
   * CheckIn create
   */
  export type CheckInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckIn.
     */
    data: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
  }

  /**
   * CheckIn createMany
   */
  export type CheckInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckIns.
     */
    data: CheckInCreateManyInput | CheckInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckIn createManyAndReturn
   */
  export type CheckInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CheckIns.
     */
    data: CheckInCreateManyInput | CheckInCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CheckIn update
   */
  export type CheckInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckIn.
     */
    data: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
    /**
     * Choose, which CheckIn to update.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn updateMany
   */
  export type CheckInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckIns.
     */
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyInput>
    /**
     * Filter which CheckIns to update
     */
    where?: CheckInWhereInput
  }

  /**
   * CheckIn upsert
   */
  export type CheckInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckIn to update in case it exists.
     */
    where: CheckInWhereUniqueInput
    /**
     * In case the CheckIn found by the `where` argument doesn't exist, create a new CheckIn with this data.
     */
    create: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
    /**
     * In case the CheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
  }

  /**
   * CheckIn delete
   */
  export type CheckInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter which CheckIn to delete.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn deleteMany
   */
  export type CheckInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIns to delete
     */
    where?: CheckInWhereInput
  }

  /**
   * CheckIn without action
   */
  export type CheckInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInInclude<ExtArgs> | null
  }


  /**
   * Model Clan
   */

  export type AggregateClan = {
    _count: ClanCountAggregateOutputType | null
    _avg: ClanAvgAggregateOutputType | null
    _sum: ClanSumAggregateOutputType | null
    _min: ClanMinAggregateOutputType | null
    _max: ClanMaxAggregateOutputType | null
  }

  export type ClanAvgAggregateOutputType = {
    maxMembers: number | null
    dojoCoinBalance: number | null
    seasonalPoints: number | null
    level: number | null
    experience: number | null
    reputation: number | null
  }

  export type ClanSumAggregateOutputType = {
    maxMembers: number | null
    dojoCoinBalance: number | null
    seasonalPoints: number | null
    level: number | null
    experience: number | null
    reputation: number | null
  }

  export type ClanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tag: string | null
    leaderId: string | null
    maxMembers: number | null
    dojoCoinBalance: number | null
    seasonalPoints: number | null
    bannerUrl: string | null
    color: string | null
    level: number | null
    experience: number | null
    reputation: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tag: string | null
    leaderId: string | null
    maxMembers: number | null
    dojoCoinBalance: number | null
    seasonalPoints: number | null
    bannerUrl: string | null
    color: string | null
    level: number | null
    experience: number | null
    reputation: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tag: number
    leaderId: number
    maxMembers: number
    dojoCoinBalance: number
    seasonalPoints: number
    bannerUrl: number
    color: number
    level: number
    experience: number
    reputation: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClanAvgAggregateInputType = {
    maxMembers?: true
    dojoCoinBalance?: true
    seasonalPoints?: true
    level?: true
    experience?: true
    reputation?: true
  }

  export type ClanSumAggregateInputType = {
    maxMembers?: true
    dojoCoinBalance?: true
    seasonalPoints?: true
    level?: true
    experience?: true
    reputation?: true
  }

  export type ClanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tag?: true
    leaderId?: true
    maxMembers?: true
    dojoCoinBalance?: true
    seasonalPoints?: true
    bannerUrl?: true
    color?: true
    level?: true
    experience?: true
    reputation?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tag?: true
    leaderId?: true
    maxMembers?: true
    dojoCoinBalance?: true
    seasonalPoints?: true
    bannerUrl?: true
    color?: true
    level?: true
    experience?: true
    reputation?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tag?: true
    leaderId?: true
    maxMembers?: true
    dojoCoinBalance?: true
    seasonalPoints?: true
    bannerUrl?: true
    color?: true
    level?: true
    experience?: true
    reputation?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clan to aggregate.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clans
    **/
    _count?: true | ClanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClanMaxAggregateInputType
  }

  export type GetClanAggregateType<T extends ClanAggregateArgs> = {
        [P in keyof T & keyof AggregateClan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClan[P]>
      : GetScalarType<T[P], AggregateClan[P]>
  }




  export type ClanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClanWhereInput
    orderBy?: ClanOrderByWithAggregationInput | ClanOrderByWithAggregationInput[]
    by: ClanScalarFieldEnum[] | ClanScalarFieldEnum
    having?: ClanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClanCountAggregateInputType | true
    _avg?: ClanAvgAggregateInputType
    _sum?: ClanSumAggregateInputType
    _min?: ClanMinAggregateInputType
    _max?: ClanMaxAggregateInputType
  }

  export type ClanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tag: string
    leaderId: string
    maxMembers: number
    dojoCoinBalance: number
    seasonalPoints: number
    bannerUrl: string | null
    color: string
    level: number
    experience: number
    reputation: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClanCountAggregateOutputType | null
    _avg: ClanAvgAggregateOutputType | null
    _sum: ClanSumAggregateOutputType | null
    _min: ClanMinAggregateOutputType | null
    _max: ClanMaxAggregateOutputType | null
  }

  type GetClanGroupByPayload<T extends ClanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClanGroupByOutputType[P]>
            : GetScalarType<T[P], ClanGroupByOutputType[P]>
        }
      >
    >


  export type ClanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tag?: boolean
    leaderId?: boolean
    maxMembers?: boolean
    dojoCoinBalance?: boolean
    seasonalPoints?: boolean
    bannerUrl?: boolean
    color?: boolean
    level?: boolean
    experience?: boolean
    reputation?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leader?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Clan$membersArgs<ExtArgs>
    territories?: boolean | Clan$territoriesArgs<ExtArgs>
    controlledVenues?: boolean | Clan$controlledVenuesArgs<ExtArgs>
    activityEvents?: boolean | Clan$activityEventsArgs<ExtArgs>
    shadowRuns?: boolean | Clan$shadowRunsArgs<ExtArgs>
    _count?: boolean | ClanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan"]>

  export type ClanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tag?: boolean
    leaderId?: boolean
    maxMembers?: boolean
    dojoCoinBalance?: boolean
    seasonalPoints?: boolean
    bannerUrl?: boolean
    color?: boolean
    level?: boolean
    experience?: boolean
    reputation?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan"]>

  export type ClanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tag?: boolean
    leaderId?: boolean
    maxMembers?: boolean
    dojoCoinBalance?: boolean
    seasonalPoints?: boolean
    bannerUrl?: boolean
    color?: boolean
    level?: boolean
    experience?: boolean
    reputation?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leader?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Clan$membersArgs<ExtArgs>
    territories?: boolean | Clan$territoriesArgs<ExtArgs>
    controlledVenues?: boolean | Clan$controlledVenuesArgs<ExtArgs>
    activityEvents?: boolean | Clan$activityEventsArgs<ExtArgs>
    shadowRuns?: boolean | Clan$shadowRunsArgs<ExtArgs>
    _count?: boolean | ClanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clan"
    objects: {
      leader: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ClanMemberPayload<ExtArgs>[]
      territories: Prisma.$TerritoryPayload<ExtArgs>[]
      controlledVenues: Prisma.$VenuePayload<ExtArgs>[]
      activityEvents: Prisma.$ActivityEventPayload<ExtArgs>[]
      shadowRuns: Prisma.$ShadowRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tag: string
      leaderId: string
      maxMembers: number
      dojoCoinBalance: number
      seasonalPoints: number
      bannerUrl: string | null
      color: string
      level: number
      experience: number
      reputation: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clan"]>
    composites: {}
  }

  type ClanGetPayload<S extends boolean | null | undefined | ClanDefaultArgs> = $Result.GetResult<Prisma.$ClanPayload, S>

  type ClanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClanCountAggregateInputType | true
    }

  export interface ClanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clan'], meta: { name: 'Clan' } }
    /**
     * Find zero or one Clan that matches the filter.
     * @param {ClanFindUniqueArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClanFindUniqueArgs>(args: SelectSubset<T, ClanFindUniqueArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClanFindUniqueOrThrowArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClanFindUniqueOrThrowArgs>(args: SelectSubset<T, ClanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanFindFirstArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClanFindFirstArgs>(args?: SelectSubset<T, ClanFindFirstArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanFindFirstOrThrowArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClanFindFirstOrThrowArgs>(args?: SelectSubset<T, ClanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clans
     * const clans = await prisma.clan.findMany()
     * 
     * // Get first 10 Clans
     * const clans = await prisma.clan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clanWithIdOnly = await prisma.clan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClanFindManyArgs>(args?: SelectSubset<T, ClanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clan.
     * @param {ClanCreateArgs} args - Arguments to create a Clan.
     * @example
     * // Create one Clan
     * const Clan = await prisma.clan.create({
     *   data: {
     *     // ... data to create a Clan
     *   }
     * })
     * 
     */
    create<T extends ClanCreateArgs>(args: SelectSubset<T, ClanCreateArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clans.
     * @param {ClanCreateManyArgs} args - Arguments to create many Clans.
     * @example
     * // Create many Clans
     * const clan = await prisma.clan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClanCreateManyArgs>(args?: SelectSubset<T, ClanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clans and returns the data saved in the database.
     * @param {ClanCreateManyAndReturnArgs} args - Arguments to create many Clans.
     * @example
     * // Create many Clans
     * const clan = await prisma.clan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clans and only return the `id`
     * const clanWithIdOnly = await prisma.clan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClanCreateManyAndReturnArgs>(args?: SelectSubset<T, ClanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Clan.
     * @param {ClanDeleteArgs} args - Arguments to delete one Clan.
     * @example
     * // Delete one Clan
     * const Clan = await prisma.clan.delete({
     *   where: {
     *     // ... filter to delete one Clan
     *   }
     * })
     * 
     */
    delete<T extends ClanDeleteArgs>(args: SelectSubset<T, ClanDeleteArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clan.
     * @param {ClanUpdateArgs} args - Arguments to update one Clan.
     * @example
     * // Update one Clan
     * const clan = await prisma.clan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClanUpdateArgs>(args: SelectSubset<T, ClanUpdateArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clans.
     * @param {ClanDeleteManyArgs} args - Arguments to filter Clans to delete.
     * @example
     * // Delete a few Clans
     * const { count } = await prisma.clan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClanDeleteManyArgs>(args?: SelectSubset<T, ClanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clans
     * const clan = await prisma.clan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClanUpdateManyArgs>(args: SelectSubset<T, ClanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clan.
     * @param {ClanUpsertArgs} args - Arguments to update or create a Clan.
     * @example
     * // Update or create a Clan
     * const clan = await prisma.clan.upsert({
     *   create: {
     *     // ... data to create a Clan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clan we want to update
     *   }
     * })
     */
    upsert<T extends ClanUpsertArgs>(args: SelectSubset<T, ClanUpsertArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanCountArgs} args - Arguments to filter Clans to count.
     * @example
     * // Count the number of Clans
     * const count = await prisma.clan.count({
     *   where: {
     *     // ... the filter for the Clans we want to count
     *   }
     * })
    **/
    count<T extends ClanCountArgs>(
      args?: Subset<T, ClanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClanAggregateArgs>(args: Subset<T, ClanAggregateArgs>): Prisma.PrismaPromise<GetClanAggregateType<T>>

    /**
     * Group by Clan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClanGroupByArgs['orderBy'] }
        : { orderBy?: ClanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clan model
   */
  readonly fields: ClanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Clan$membersArgs<ExtArgs> = {}>(args?: Subset<T, Clan$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "findMany"> | Null>
    territories<T extends Clan$territoriesArgs<ExtArgs> = {}>(args?: Subset<T, Clan$territoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findMany"> | Null>
    controlledVenues<T extends Clan$controlledVenuesArgs<ExtArgs> = {}>(args?: Subset<T, Clan$controlledVenuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany"> | Null>
    activityEvents<T extends Clan$activityEventsArgs<ExtArgs> = {}>(args?: Subset<T, Clan$activityEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findMany"> | Null>
    shadowRuns<T extends Clan$shadowRunsArgs<ExtArgs> = {}>(args?: Subset<T, Clan$shadowRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clan model
   */ 
  interface ClanFieldRefs {
    readonly id: FieldRef<"Clan", 'String'>
    readonly name: FieldRef<"Clan", 'String'>
    readonly description: FieldRef<"Clan", 'String'>
    readonly tag: FieldRef<"Clan", 'String'>
    readonly leaderId: FieldRef<"Clan", 'String'>
    readonly maxMembers: FieldRef<"Clan", 'Int'>
    readonly dojoCoinBalance: FieldRef<"Clan", 'Int'>
    readonly seasonalPoints: FieldRef<"Clan", 'Int'>
    readonly bannerUrl: FieldRef<"Clan", 'String'>
    readonly color: FieldRef<"Clan", 'String'>
    readonly level: FieldRef<"Clan", 'Int'>
    readonly experience: FieldRef<"Clan", 'Int'>
    readonly reputation: FieldRef<"Clan", 'Int'>
    readonly isActive: FieldRef<"Clan", 'Boolean'>
    readonly createdAt: FieldRef<"Clan", 'DateTime'>
    readonly updatedAt: FieldRef<"Clan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clan findUnique
   */
  export type ClanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan findUniqueOrThrow
   */
  export type ClanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan findFirst
   */
  export type ClanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clans.
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clans.
     */
    distinct?: ClanScalarFieldEnum | ClanScalarFieldEnum[]
  }

  /**
   * Clan findFirstOrThrow
   */
  export type ClanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clans.
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clans.
     */
    distinct?: ClanScalarFieldEnum | ClanScalarFieldEnum[]
  }

  /**
   * Clan findMany
   */
  export type ClanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clans to fetch.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clans.
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    distinct?: ClanScalarFieldEnum | ClanScalarFieldEnum[]
  }

  /**
   * Clan create
   */
  export type ClanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * The data needed to create a Clan.
     */
    data: XOR<ClanCreateInput, ClanUncheckedCreateInput>
  }

  /**
   * Clan createMany
   */
  export type ClanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clans.
     */
    data: ClanCreateManyInput | ClanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clan createManyAndReturn
   */
  export type ClanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clans.
     */
    data: ClanCreateManyInput | ClanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Clan update
   */
  export type ClanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * The data needed to update a Clan.
     */
    data: XOR<ClanUpdateInput, ClanUncheckedUpdateInput>
    /**
     * Choose, which Clan to update.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan updateMany
   */
  export type ClanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clans.
     */
    data: XOR<ClanUpdateManyMutationInput, ClanUncheckedUpdateManyInput>
    /**
     * Filter which Clans to update
     */
    where?: ClanWhereInput
  }

  /**
   * Clan upsert
   */
  export type ClanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * The filter to search for the Clan to update in case it exists.
     */
    where: ClanWhereUniqueInput
    /**
     * In case the Clan found by the `where` argument doesn't exist, create a new Clan with this data.
     */
    create: XOR<ClanCreateInput, ClanUncheckedCreateInput>
    /**
     * In case the Clan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClanUpdateInput, ClanUncheckedUpdateInput>
  }

  /**
   * Clan delete
   */
  export type ClanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter which Clan to delete.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan deleteMany
   */
  export type ClanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clans to delete
     */
    where?: ClanWhereInput
  }

  /**
   * Clan.members
   */
  export type Clan$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    where?: ClanMemberWhereInput
    orderBy?: ClanMemberOrderByWithRelationInput | ClanMemberOrderByWithRelationInput[]
    cursor?: ClanMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClanMemberScalarFieldEnum | ClanMemberScalarFieldEnum[]
  }

  /**
   * Clan.territories
   */
  export type Clan$territoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    where?: TerritoryWhereInput
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    cursor?: TerritoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Clan.controlledVenues
   */
  export type Clan$controlledVenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Clan.activityEvents
   */
  export type Clan$activityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    where?: ActivityEventWhereInput
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    cursor?: ActivityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * Clan.shadowRuns
   */
  export type Clan$shadowRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    where?: ShadowRunWhereInput
    orderBy?: ShadowRunOrderByWithRelationInput | ShadowRunOrderByWithRelationInput[]
    cursor?: ShadowRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShadowRunScalarFieldEnum | ShadowRunScalarFieldEnum[]
  }

  /**
   * Clan without action
   */
  export type ClanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
  }


  /**
   * Model ClanMember
   */

  export type AggregateClanMember = {
    _count: ClanMemberCountAggregateOutputType | null
    _min: ClanMemberMinAggregateOutputType | null
    _max: ClanMemberMaxAggregateOutputType | null
  }

  export type ClanMemberMinAggregateOutputType = {
    id: string | null
    clanId: string | null
    userId: string | null
    role: $Enums.ClanRole | null
    joinedAt: Date | null
  }

  export type ClanMemberMaxAggregateOutputType = {
    id: string | null
    clanId: string | null
    userId: string | null
    role: $Enums.ClanRole | null
    joinedAt: Date | null
  }

  export type ClanMemberCountAggregateOutputType = {
    id: number
    clanId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type ClanMemberMinAggregateInputType = {
    id?: true
    clanId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ClanMemberMaxAggregateInputType = {
    id?: true
    clanId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ClanMemberCountAggregateInputType = {
    id?: true
    clanId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type ClanMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClanMember to aggregate.
     */
    where?: ClanMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClanMembers to fetch.
     */
    orderBy?: ClanMemberOrderByWithRelationInput | ClanMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClanMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClanMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClanMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClanMembers
    **/
    _count?: true | ClanMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClanMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClanMemberMaxAggregateInputType
  }

  export type GetClanMemberAggregateType<T extends ClanMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateClanMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClanMember[P]>
      : GetScalarType<T[P], AggregateClanMember[P]>
  }




  export type ClanMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClanMemberWhereInput
    orderBy?: ClanMemberOrderByWithAggregationInput | ClanMemberOrderByWithAggregationInput[]
    by: ClanMemberScalarFieldEnum[] | ClanMemberScalarFieldEnum
    having?: ClanMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClanMemberCountAggregateInputType | true
    _min?: ClanMemberMinAggregateInputType
    _max?: ClanMemberMaxAggregateInputType
  }

  export type ClanMemberGroupByOutputType = {
    id: string
    clanId: string
    userId: string
    role: $Enums.ClanRole
    joinedAt: Date
    _count: ClanMemberCountAggregateOutputType | null
    _min: ClanMemberMinAggregateOutputType | null
    _max: ClanMemberMaxAggregateOutputType | null
  }

  type GetClanMemberGroupByPayload<T extends ClanMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClanMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClanMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClanMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ClanMemberGroupByOutputType[P]>
        }
      >
    >


  export type ClanMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clanId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    clan?: boolean | ClanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clanMember"]>

  export type ClanMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clanId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    clan?: boolean | ClanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clanMember"]>

  export type ClanMemberSelectScalar = {
    id?: boolean
    clanId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type ClanMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clan?: boolean | ClanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClanMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clan?: boolean | ClanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClanMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClanMember"
    objects: {
      clan: Prisma.$ClanPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clanId: string
      userId: string
      role: $Enums.ClanRole
      joinedAt: Date
    }, ExtArgs["result"]["clanMember"]>
    composites: {}
  }

  type ClanMemberGetPayload<S extends boolean | null | undefined | ClanMemberDefaultArgs> = $Result.GetResult<Prisma.$ClanMemberPayload, S>

  type ClanMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClanMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClanMemberCountAggregateInputType | true
    }

  export interface ClanMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClanMember'], meta: { name: 'ClanMember' } }
    /**
     * Find zero or one ClanMember that matches the filter.
     * @param {ClanMemberFindUniqueArgs} args - Arguments to find a ClanMember
     * @example
     * // Get one ClanMember
     * const clanMember = await prisma.clanMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClanMemberFindUniqueArgs>(args: SelectSubset<T, ClanMemberFindUniqueArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClanMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClanMemberFindUniqueOrThrowArgs} args - Arguments to find a ClanMember
     * @example
     * // Get one ClanMember
     * const clanMember = await prisma.clanMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClanMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ClanMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClanMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanMemberFindFirstArgs} args - Arguments to find a ClanMember
     * @example
     * // Get one ClanMember
     * const clanMember = await prisma.clanMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClanMemberFindFirstArgs>(args?: SelectSubset<T, ClanMemberFindFirstArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClanMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanMemberFindFirstOrThrowArgs} args - Arguments to find a ClanMember
     * @example
     * // Get one ClanMember
     * const clanMember = await prisma.clanMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClanMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ClanMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClanMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClanMembers
     * const clanMembers = await prisma.clanMember.findMany()
     * 
     * // Get first 10 ClanMembers
     * const clanMembers = await prisma.clanMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clanMemberWithIdOnly = await prisma.clanMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClanMemberFindManyArgs>(args?: SelectSubset<T, ClanMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClanMember.
     * @param {ClanMemberCreateArgs} args - Arguments to create a ClanMember.
     * @example
     * // Create one ClanMember
     * const ClanMember = await prisma.clanMember.create({
     *   data: {
     *     // ... data to create a ClanMember
     *   }
     * })
     * 
     */
    create<T extends ClanMemberCreateArgs>(args: SelectSubset<T, ClanMemberCreateArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClanMembers.
     * @param {ClanMemberCreateManyArgs} args - Arguments to create many ClanMembers.
     * @example
     * // Create many ClanMembers
     * const clanMember = await prisma.clanMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClanMemberCreateManyArgs>(args?: SelectSubset<T, ClanMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClanMembers and returns the data saved in the database.
     * @param {ClanMemberCreateManyAndReturnArgs} args - Arguments to create many ClanMembers.
     * @example
     * // Create many ClanMembers
     * const clanMember = await prisma.clanMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClanMembers and only return the `id`
     * const clanMemberWithIdOnly = await prisma.clanMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClanMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ClanMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClanMember.
     * @param {ClanMemberDeleteArgs} args - Arguments to delete one ClanMember.
     * @example
     * // Delete one ClanMember
     * const ClanMember = await prisma.clanMember.delete({
     *   where: {
     *     // ... filter to delete one ClanMember
     *   }
     * })
     * 
     */
    delete<T extends ClanMemberDeleteArgs>(args: SelectSubset<T, ClanMemberDeleteArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClanMember.
     * @param {ClanMemberUpdateArgs} args - Arguments to update one ClanMember.
     * @example
     * // Update one ClanMember
     * const clanMember = await prisma.clanMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClanMemberUpdateArgs>(args: SelectSubset<T, ClanMemberUpdateArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClanMembers.
     * @param {ClanMemberDeleteManyArgs} args - Arguments to filter ClanMembers to delete.
     * @example
     * // Delete a few ClanMembers
     * const { count } = await prisma.clanMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClanMemberDeleteManyArgs>(args?: SelectSubset<T, ClanMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClanMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClanMembers
     * const clanMember = await prisma.clanMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClanMemberUpdateManyArgs>(args: SelectSubset<T, ClanMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClanMember.
     * @param {ClanMemberUpsertArgs} args - Arguments to update or create a ClanMember.
     * @example
     * // Update or create a ClanMember
     * const clanMember = await prisma.clanMember.upsert({
     *   create: {
     *     // ... data to create a ClanMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClanMember we want to update
     *   }
     * })
     */
    upsert<T extends ClanMemberUpsertArgs>(args: SelectSubset<T, ClanMemberUpsertArgs<ExtArgs>>): Prisma__ClanMemberClient<$Result.GetResult<Prisma.$ClanMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClanMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanMemberCountArgs} args - Arguments to filter ClanMembers to count.
     * @example
     * // Count the number of ClanMembers
     * const count = await prisma.clanMember.count({
     *   where: {
     *     // ... the filter for the ClanMembers we want to count
     *   }
     * })
    **/
    count<T extends ClanMemberCountArgs>(
      args?: Subset<T, ClanMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClanMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClanMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClanMemberAggregateArgs>(args: Subset<T, ClanMemberAggregateArgs>): Prisma.PrismaPromise<GetClanMemberAggregateType<T>>

    /**
     * Group by ClanMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClanMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClanMemberGroupByArgs['orderBy'] }
        : { orderBy?: ClanMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClanMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClanMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClanMember model
   */
  readonly fields: ClanMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClanMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClanMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clan<T extends ClanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClanDefaultArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClanMember model
   */ 
  interface ClanMemberFieldRefs {
    readonly id: FieldRef<"ClanMember", 'String'>
    readonly clanId: FieldRef<"ClanMember", 'String'>
    readonly userId: FieldRef<"ClanMember", 'String'>
    readonly role: FieldRef<"ClanMember", 'ClanRole'>
    readonly joinedAt: FieldRef<"ClanMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClanMember findUnique
   */
  export type ClanMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClanMember to fetch.
     */
    where: ClanMemberWhereUniqueInput
  }

  /**
   * ClanMember findUniqueOrThrow
   */
  export type ClanMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClanMember to fetch.
     */
    where: ClanMemberWhereUniqueInput
  }

  /**
   * ClanMember findFirst
   */
  export type ClanMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClanMember to fetch.
     */
    where?: ClanMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClanMembers to fetch.
     */
    orderBy?: ClanMemberOrderByWithRelationInput | ClanMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClanMembers.
     */
    cursor?: ClanMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClanMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClanMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClanMembers.
     */
    distinct?: ClanMemberScalarFieldEnum | ClanMemberScalarFieldEnum[]
  }

  /**
   * ClanMember findFirstOrThrow
   */
  export type ClanMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClanMember to fetch.
     */
    where?: ClanMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClanMembers to fetch.
     */
    orderBy?: ClanMemberOrderByWithRelationInput | ClanMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClanMembers.
     */
    cursor?: ClanMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClanMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClanMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClanMembers.
     */
    distinct?: ClanMemberScalarFieldEnum | ClanMemberScalarFieldEnum[]
  }

  /**
   * ClanMember findMany
   */
  export type ClanMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClanMembers to fetch.
     */
    where?: ClanMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClanMembers to fetch.
     */
    orderBy?: ClanMemberOrderByWithRelationInput | ClanMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClanMembers.
     */
    cursor?: ClanMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClanMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClanMembers.
     */
    skip?: number
    distinct?: ClanMemberScalarFieldEnum | ClanMemberScalarFieldEnum[]
  }

  /**
   * ClanMember create
   */
  export type ClanMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ClanMember.
     */
    data: XOR<ClanMemberCreateInput, ClanMemberUncheckedCreateInput>
  }

  /**
   * ClanMember createMany
   */
  export type ClanMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClanMembers.
     */
    data: ClanMemberCreateManyInput | ClanMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClanMember createManyAndReturn
   */
  export type ClanMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClanMembers.
     */
    data: ClanMemberCreateManyInput | ClanMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClanMember update
   */
  export type ClanMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ClanMember.
     */
    data: XOR<ClanMemberUpdateInput, ClanMemberUncheckedUpdateInput>
    /**
     * Choose, which ClanMember to update.
     */
    where: ClanMemberWhereUniqueInput
  }

  /**
   * ClanMember updateMany
   */
  export type ClanMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClanMembers.
     */
    data: XOR<ClanMemberUpdateManyMutationInput, ClanMemberUncheckedUpdateManyInput>
    /**
     * Filter which ClanMembers to update
     */
    where?: ClanMemberWhereInput
  }

  /**
   * ClanMember upsert
   */
  export type ClanMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ClanMember to update in case it exists.
     */
    where: ClanMemberWhereUniqueInput
    /**
     * In case the ClanMember found by the `where` argument doesn't exist, create a new ClanMember with this data.
     */
    create: XOR<ClanMemberCreateInput, ClanMemberUncheckedCreateInput>
    /**
     * In case the ClanMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClanMemberUpdateInput, ClanMemberUncheckedUpdateInput>
  }

  /**
   * ClanMember delete
   */
  export type ClanMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
    /**
     * Filter which ClanMember to delete.
     */
    where: ClanMemberWhereUniqueInput
  }

  /**
   * ClanMember deleteMany
   */
  export type ClanMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClanMembers to delete
     */
    where?: ClanMemberWhereInput
  }

  /**
   * ClanMember without action
   */
  export type ClanMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanMember
     */
    select?: ClanMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanMemberInclude<ExtArgs> | null
  }


  /**
   * Model Territory
   */

  export type AggregateTerritory = {
    _count: TerritoryCountAggregateOutputType | null
    _avg: TerritoryAvgAggregateOutputType | null
    _sum: TerritorySumAggregateOutputType | null
    _min: TerritoryMinAggregateOutputType | null
    _max: TerritoryMaxAggregateOutputType | null
  }

  export type TerritoryAvgAggregateOutputType = {
    level: number | null
    defenseScore: number | null
    strategicValue: number | null
  }

  export type TerritorySumAggregateOutputType = {
    level: number | null
    defenseScore: number | null
    strategicValue: number | null
  }

  export type TerritoryMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    name: string | null
    ownerId: string | null
    clanId: string | null
    level: number | null
    defenseScore: number | null
    resources: string | null
    strategicValue: number | null
    resourceRate: string | null
    lastTickAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerritoryMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    name: string | null
    ownerId: string | null
    clanId: string | null
    level: number | null
    defenseScore: number | null
    resources: string | null
    strategicValue: number | null
    resourceRate: string | null
    lastTickAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerritoryCountAggregateOutputType = {
    id: number
    venueId: number
    name: number
    ownerId: number
    clanId: number
    level: number
    defenseScore: number
    resources: number
    strategicValue: number
    resourceRate: number
    lastTickAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TerritoryAvgAggregateInputType = {
    level?: true
    defenseScore?: true
    strategicValue?: true
  }

  export type TerritorySumAggregateInputType = {
    level?: true
    defenseScore?: true
    strategicValue?: true
  }

  export type TerritoryMinAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    ownerId?: true
    clanId?: true
    level?: true
    defenseScore?: true
    resources?: true
    strategicValue?: true
    resourceRate?: true
    lastTickAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerritoryMaxAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    ownerId?: true
    clanId?: true
    level?: true
    defenseScore?: true
    resources?: true
    strategicValue?: true
    resourceRate?: true
    lastTickAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerritoryCountAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    ownerId?: true
    clanId?: true
    level?: true
    defenseScore?: true
    resources?: true
    strategicValue?: true
    resourceRate?: true
    lastTickAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TerritoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Territory to aggregate.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Territories
    **/
    _count?: true | TerritoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TerritoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TerritorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerritoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerritoryMaxAggregateInputType
  }

  export type GetTerritoryAggregateType<T extends TerritoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTerritory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerritory[P]>
      : GetScalarType<T[P], AggregateTerritory[P]>
  }




  export type TerritoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoryWhereInput
    orderBy?: TerritoryOrderByWithAggregationInput | TerritoryOrderByWithAggregationInput[]
    by: TerritoryScalarFieldEnum[] | TerritoryScalarFieldEnum
    having?: TerritoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerritoryCountAggregateInputType | true
    _avg?: TerritoryAvgAggregateInputType
    _sum?: TerritorySumAggregateInputType
    _min?: TerritoryMinAggregateInputType
    _max?: TerritoryMaxAggregateInputType
  }

  export type TerritoryGroupByOutputType = {
    id: string
    venueId: string
    name: string
    ownerId: string | null
    clanId: string | null
    level: number
    defenseScore: number
    resources: string
    strategicValue: number
    resourceRate: string
    lastTickAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TerritoryCountAggregateOutputType | null
    _avg: TerritoryAvgAggregateOutputType | null
    _sum: TerritorySumAggregateOutputType | null
    _min: TerritoryMinAggregateOutputType | null
    _max: TerritoryMaxAggregateOutputType | null
  }

  type GetTerritoryGroupByPayload<T extends TerritoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerritoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerritoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerritoryGroupByOutputType[P]>
            : GetScalarType<T[P], TerritoryGroupByOutputType[P]>
        }
      >
    >


  export type TerritorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    name?: boolean
    ownerId?: boolean
    clanId?: boolean
    level?: boolean
    defenseScore?: boolean
    resources?: boolean
    strategicValue?: boolean
    resourceRate?: boolean
    lastTickAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    owner?: boolean | Territory$ownerArgs<ExtArgs>
    clan?: boolean | Territory$clanArgs<ExtArgs>
    events?: boolean | Territory$eventsArgs<ExtArgs>
    _count?: boolean | TerritoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["territory"]>

  export type TerritorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    name?: boolean
    ownerId?: boolean
    clanId?: boolean
    level?: boolean
    defenseScore?: boolean
    resources?: boolean
    strategicValue?: boolean
    resourceRate?: boolean
    lastTickAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    owner?: boolean | Territory$ownerArgs<ExtArgs>
    clan?: boolean | Territory$clanArgs<ExtArgs>
  }, ExtArgs["result"]["territory"]>

  export type TerritorySelectScalar = {
    id?: boolean
    venueId?: boolean
    name?: boolean
    ownerId?: boolean
    clanId?: boolean
    level?: boolean
    defenseScore?: boolean
    resources?: boolean
    strategicValue?: boolean
    resourceRate?: boolean
    lastTickAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TerritoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    owner?: boolean | Territory$ownerArgs<ExtArgs>
    clan?: boolean | Territory$clanArgs<ExtArgs>
    events?: boolean | Territory$eventsArgs<ExtArgs>
    _count?: boolean | TerritoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TerritoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    owner?: boolean | Territory$ownerArgs<ExtArgs>
    clan?: boolean | Territory$clanArgs<ExtArgs>
  }

  export type $TerritoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Territory"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
      clan: Prisma.$ClanPayload<ExtArgs> | null
      events: Prisma.$TerritoryEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      name: string
      ownerId: string | null
      clanId: string | null
      level: number
      defenseScore: number
      resources: string
      strategicValue: number
      resourceRate: string
      lastTickAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["territory"]>
    composites: {}
  }

  type TerritoryGetPayload<S extends boolean | null | undefined | TerritoryDefaultArgs> = $Result.GetResult<Prisma.$TerritoryPayload, S>

  type TerritoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TerritoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TerritoryCountAggregateInputType | true
    }

  export interface TerritoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Territory'], meta: { name: 'Territory' } }
    /**
     * Find zero or one Territory that matches the filter.
     * @param {TerritoryFindUniqueArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerritoryFindUniqueArgs>(args: SelectSubset<T, TerritoryFindUniqueArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Territory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TerritoryFindUniqueOrThrowArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerritoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TerritoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Territory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryFindFirstArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerritoryFindFirstArgs>(args?: SelectSubset<T, TerritoryFindFirstArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Territory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryFindFirstOrThrowArgs} args - Arguments to find a Territory
     * @example
     * // Get one Territory
     * const territory = await prisma.territory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerritoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TerritoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Territories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Territories
     * const territories = await prisma.territory.findMany()
     * 
     * // Get first 10 Territories
     * const territories = await prisma.territory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const territoryWithIdOnly = await prisma.territory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerritoryFindManyArgs>(args?: SelectSubset<T, TerritoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Territory.
     * @param {TerritoryCreateArgs} args - Arguments to create a Territory.
     * @example
     * // Create one Territory
     * const Territory = await prisma.territory.create({
     *   data: {
     *     // ... data to create a Territory
     *   }
     * })
     * 
     */
    create<T extends TerritoryCreateArgs>(args: SelectSubset<T, TerritoryCreateArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Territories.
     * @param {TerritoryCreateManyArgs} args - Arguments to create many Territories.
     * @example
     * // Create many Territories
     * const territory = await prisma.territory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerritoryCreateManyArgs>(args?: SelectSubset<T, TerritoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Territories and returns the data saved in the database.
     * @param {TerritoryCreateManyAndReturnArgs} args - Arguments to create many Territories.
     * @example
     * // Create many Territories
     * const territory = await prisma.territory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Territories and only return the `id`
     * const territoryWithIdOnly = await prisma.territory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerritoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TerritoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Territory.
     * @param {TerritoryDeleteArgs} args - Arguments to delete one Territory.
     * @example
     * // Delete one Territory
     * const Territory = await prisma.territory.delete({
     *   where: {
     *     // ... filter to delete one Territory
     *   }
     * })
     * 
     */
    delete<T extends TerritoryDeleteArgs>(args: SelectSubset<T, TerritoryDeleteArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Territory.
     * @param {TerritoryUpdateArgs} args - Arguments to update one Territory.
     * @example
     * // Update one Territory
     * const territory = await prisma.territory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerritoryUpdateArgs>(args: SelectSubset<T, TerritoryUpdateArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Territories.
     * @param {TerritoryDeleteManyArgs} args - Arguments to filter Territories to delete.
     * @example
     * // Delete a few Territories
     * const { count } = await prisma.territory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerritoryDeleteManyArgs>(args?: SelectSubset<T, TerritoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Territories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Territories
     * const territory = await prisma.territory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerritoryUpdateManyArgs>(args: SelectSubset<T, TerritoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Territory.
     * @param {TerritoryUpsertArgs} args - Arguments to update or create a Territory.
     * @example
     * // Update or create a Territory
     * const territory = await prisma.territory.upsert({
     *   create: {
     *     // ... data to create a Territory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Territory we want to update
     *   }
     * })
     */
    upsert<T extends TerritoryUpsertArgs>(args: SelectSubset<T, TerritoryUpsertArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Territories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryCountArgs} args - Arguments to filter Territories to count.
     * @example
     * // Count the number of Territories
     * const count = await prisma.territory.count({
     *   where: {
     *     // ... the filter for the Territories we want to count
     *   }
     * })
    **/
    count<T extends TerritoryCountArgs>(
      args?: Subset<T, TerritoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerritoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Territory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerritoryAggregateArgs>(args: Subset<T, TerritoryAggregateArgs>): Prisma.PrismaPromise<GetTerritoryAggregateType<T>>

    /**
     * Group by Territory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerritoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerritoryGroupByArgs['orderBy'] }
        : { orderBy?: TerritoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerritoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerritoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Territory model
   */
  readonly fields: TerritoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Territory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerritoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends Territory$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Territory$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    clan<T extends Territory$clanArgs<ExtArgs> = {}>(args?: Subset<T, Territory$clanArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends Territory$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Territory$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Territory model
   */ 
  interface TerritoryFieldRefs {
    readonly id: FieldRef<"Territory", 'String'>
    readonly venueId: FieldRef<"Territory", 'String'>
    readonly name: FieldRef<"Territory", 'String'>
    readonly ownerId: FieldRef<"Territory", 'String'>
    readonly clanId: FieldRef<"Territory", 'String'>
    readonly level: FieldRef<"Territory", 'Int'>
    readonly defenseScore: FieldRef<"Territory", 'Int'>
    readonly resources: FieldRef<"Territory", 'String'>
    readonly strategicValue: FieldRef<"Territory", 'Int'>
    readonly resourceRate: FieldRef<"Territory", 'String'>
    readonly lastTickAt: FieldRef<"Territory", 'DateTime'>
    readonly createdAt: FieldRef<"Territory", 'DateTime'>
    readonly updatedAt: FieldRef<"Territory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Territory findUnique
   */
  export type TerritoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory findUniqueOrThrow
   */
  export type TerritoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory findFirst
   */
  export type TerritoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Territories.
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Territories.
     */
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Territory findFirstOrThrow
   */
  export type TerritoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territory to fetch.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Territories.
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Territories.
     */
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Territory findMany
   */
  export type TerritoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter, which Territories to fetch.
     */
    where?: TerritoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Territories to fetch.
     */
    orderBy?: TerritoryOrderByWithRelationInput | TerritoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Territories.
     */
    cursor?: TerritoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Territories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Territories.
     */
    skip?: number
    distinct?: TerritoryScalarFieldEnum | TerritoryScalarFieldEnum[]
  }

  /**
   * Territory create
   */
  export type TerritoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Territory.
     */
    data: XOR<TerritoryCreateInput, TerritoryUncheckedCreateInput>
  }

  /**
   * Territory createMany
   */
  export type TerritoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Territories.
     */
    data: TerritoryCreateManyInput | TerritoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Territory createManyAndReturn
   */
  export type TerritoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Territories.
     */
    data: TerritoryCreateManyInput | TerritoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Territory update
   */
  export type TerritoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Territory.
     */
    data: XOR<TerritoryUpdateInput, TerritoryUncheckedUpdateInput>
    /**
     * Choose, which Territory to update.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory updateMany
   */
  export type TerritoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Territories.
     */
    data: XOR<TerritoryUpdateManyMutationInput, TerritoryUncheckedUpdateManyInput>
    /**
     * Filter which Territories to update
     */
    where?: TerritoryWhereInput
  }

  /**
   * Territory upsert
   */
  export type TerritoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Territory to update in case it exists.
     */
    where: TerritoryWhereUniqueInput
    /**
     * In case the Territory found by the `where` argument doesn't exist, create a new Territory with this data.
     */
    create: XOR<TerritoryCreateInput, TerritoryUncheckedCreateInput>
    /**
     * In case the Territory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerritoryUpdateInput, TerritoryUncheckedUpdateInput>
  }

  /**
   * Territory delete
   */
  export type TerritoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
    /**
     * Filter which Territory to delete.
     */
    where: TerritoryWhereUniqueInput
  }

  /**
   * Territory deleteMany
   */
  export type TerritoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Territories to delete
     */
    where?: TerritoryWhereInput
  }

  /**
   * Territory.owner
   */
  export type Territory$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Territory.clan
   */
  export type Territory$clanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    where?: ClanWhereInput
  }

  /**
   * Territory.events
   */
  export type Territory$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    where?: TerritoryEventWhereInput
    orderBy?: TerritoryEventOrderByWithRelationInput | TerritoryEventOrderByWithRelationInput[]
    cursor?: TerritoryEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerritoryEventScalarFieldEnum | TerritoryEventScalarFieldEnum[]
  }

  /**
   * Territory without action
   */
  export type TerritoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Territory
     */
    select?: TerritorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryInclude<ExtArgs> | null
  }


  /**
   * Model TerritoryEvent
   */

  export type AggregateTerritoryEvent = {
    _count: TerritoryEventCountAggregateOutputType | null
    _min: TerritoryEventMinAggregateOutputType | null
    _max: TerritoryEventMaxAggregateOutputType | null
  }

  export type TerritoryEventMinAggregateOutputType = {
    id: string | null
    territoryId: string | null
    type: $Enums.TerritoryEventType | null
    metadata: string | null
    createdAt: Date | null
  }

  export type TerritoryEventMaxAggregateOutputType = {
    id: string | null
    territoryId: string | null
    type: $Enums.TerritoryEventType | null
    metadata: string | null
    createdAt: Date | null
  }

  export type TerritoryEventCountAggregateOutputType = {
    id: number
    territoryId: number
    type: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type TerritoryEventMinAggregateInputType = {
    id?: true
    territoryId?: true
    type?: true
    metadata?: true
    createdAt?: true
  }

  export type TerritoryEventMaxAggregateInputType = {
    id?: true
    territoryId?: true
    type?: true
    metadata?: true
    createdAt?: true
  }

  export type TerritoryEventCountAggregateInputType = {
    id?: true
    territoryId?: true
    type?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type TerritoryEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerritoryEvent to aggregate.
     */
    where?: TerritoryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoryEvents to fetch.
     */
    orderBy?: TerritoryEventOrderByWithRelationInput | TerritoryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerritoryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TerritoryEvents
    **/
    _count?: true | TerritoryEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerritoryEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerritoryEventMaxAggregateInputType
  }

  export type GetTerritoryEventAggregateType<T extends TerritoryEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTerritoryEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerritoryEvent[P]>
      : GetScalarType<T[P], AggregateTerritoryEvent[P]>
  }




  export type TerritoryEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerritoryEventWhereInput
    orderBy?: TerritoryEventOrderByWithAggregationInput | TerritoryEventOrderByWithAggregationInput[]
    by: TerritoryEventScalarFieldEnum[] | TerritoryEventScalarFieldEnum
    having?: TerritoryEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerritoryEventCountAggregateInputType | true
    _min?: TerritoryEventMinAggregateInputType
    _max?: TerritoryEventMaxAggregateInputType
  }

  export type TerritoryEventGroupByOutputType = {
    id: string
    territoryId: string
    type: $Enums.TerritoryEventType
    metadata: string
    createdAt: Date
    _count: TerritoryEventCountAggregateOutputType | null
    _min: TerritoryEventMinAggregateOutputType | null
    _max: TerritoryEventMaxAggregateOutputType | null
  }

  type GetTerritoryEventGroupByPayload<T extends TerritoryEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerritoryEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerritoryEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerritoryEventGroupByOutputType[P]>
            : GetScalarType<T[P], TerritoryEventGroupByOutputType[P]>
        }
      >
    >


  export type TerritoryEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    territoryId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    territory?: boolean | TerritoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["territoryEvent"]>

  export type TerritoryEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    territoryId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    territory?: boolean | TerritoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["territoryEvent"]>

  export type TerritoryEventSelectScalar = {
    id?: boolean
    territoryId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type TerritoryEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    territory?: boolean | TerritoryDefaultArgs<ExtArgs>
  }
  export type TerritoryEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    territory?: boolean | TerritoryDefaultArgs<ExtArgs>
  }

  export type $TerritoryEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TerritoryEvent"
    objects: {
      territory: Prisma.$TerritoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      territoryId: string
      type: $Enums.TerritoryEventType
      metadata: string
      createdAt: Date
    }, ExtArgs["result"]["territoryEvent"]>
    composites: {}
  }

  type TerritoryEventGetPayload<S extends boolean | null | undefined | TerritoryEventDefaultArgs> = $Result.GetResult<Prisma.$TerritoryEventPayload, S>

  type TerritoryEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TerritoryEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TerritoryEventCountAggregateInputType | true
    }

  export interface TerritoryEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TerritoryEvent'], meta: { name: 'TerritoryEvent' } }
    /**
     * Find zero or one TerritoryEvent that matches the filter.
     * @param {TerritoryEventFindUniqueArgs} args - Arguments to find a TerritoryEvent
     * @example
     * // Get one TerritoryEvent
     * const territoryEvent = await prisma.territoryEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerritoryEventFindUniqueArgs>(args: SelectSubset<T, TerritoryEventFindUniqueArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TerritoryEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TerritoryEventFindUniqueOrThrowArgs} args - Arguments to find a TerritoryEvent
     * @example
     * // Get one TerritoryEvent
     * const territoryEvent = await prisma.territoryEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerritoryEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TerritoryEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TerritoryEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryEventFindFirstArgs} args - Arguments to find a TerritoryEvent
     * @example
     * // Get one TerritoryEvent
     * const territoryEvent = await prisma.territoryEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerritoryEventFindFirstArgs>(args?: SelectSubset<T, TerritoryEventFindFirstArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TerritoryEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryEventFindFirstOrThrowArgs} args - Arguments to find a TerritoryEvent
     * @example
     * // Get one TerritoryEvent
     * const territoryEvent = await prisma.territoryEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerritoryEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TerritoryEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TerritoryEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TerritoryEvents
     * const territoryEvents = await prisma.territoryEvent.findMany()
     * 
     * // Get first 10 TerritoryEvents
     * const territoryEvents = await prisma.territoryEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const territoryEventWithIdOnly = await prisma.territoryEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerritoryEventFindManyArgs>(args?: SelectSubset<T, TerritoryEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TerritoryEvent.
     * @param {TerritoryEventCreateArgs} args - Arguments to create a TerritoryEvent.
     * @example
     * // Create one TerritoryEvent
     * const TerritoryEvent = await prisma.territoryEvent.create({
     *   data: {
     *     // ... data to create a TerritoryEvent
     *   }
     * })
     * 
     */
    create<T extends TerritoryEventCreateArgs>(args: SelectSubset<T, TerritoryEventCreateArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TerritoryEvents.
     * @param {TerritoryEventCreateManyArgs} args - Arguments to create many TerritoryEvents.
     * @example
     * // Create many TerritoryEvents
     * const territoryEvent = await prisma.territoryEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerritoryEventCreateManyArgs>(args?: SelectSubset<T, TerritoryEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TerritoryEvents and returns the data saved in the database.
     * @param {TerritoryEventCreateManyAndReturnArgs} args - Arguments to create many TerritoryEvents.
     * @example
     * // Create many TerritoryEvents
     * const territoryEvent = await prisma.territoryEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TerritoryEvents and only return the `id`
     * const territoryEventWithIdOnly = await prisma.territoryEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerritoryEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TerritoryEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TerritoryEvent.
     * @param {TerritoryEventDeleteArgs} args - Arguments to delete one TerritoryEvent.
     * @example
     * // Delete one TerritoryEvent
     * const TerritoryEvent = await prisma.territoryEvent.delete({
     *   where: {
     *     // ... filter to delete one TerritoryEvent
     *   }
     * })
     * 
     */
    delete<T extends TerritoryEventDeleteArgs>(args: SelectSubset<T, TerritoryEventDeleteArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TerritoryEvent.
     * @param {TerritoryEventUpdateArgs} args - Arguments to update one TerritoryEvent.
     * @example
     * // Update one TerritoryEvent
     * const territoryEvent = await prisma.territoryEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerritoryEventUpdateArgs>(args: SelectSubset<T, TerritoryEventUpdateArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TerritoryEvents.
     * @param {TerritoryEventDeleteManyArgs} args - Arguments to filter TerritoryEvents to delete.
     * @example
     * // Delete a few TerritoryEvents
     * const { count } = await prisma.territoryEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerritoryEventDeleteManyArgs>(args?: SelectSubset<T, TerritoryEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TerritoryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TerritoryEvents
     * const territoryEvent = await prisma.territoryEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerritoryEventUpdateManyArgs>(args: SelectSubset<T, TerritoryEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TerritoryEvent.
     * @param {TerritoryEventUpsertArgs} args - Arguments to update or create a TerritoryEvent.
     * @example
     * // Update or create a TerritoryEvent
     * const territoryEvent = await prisma.territoryEvent.upsert({
     *   create: {
     *     // ... data to create a TerritoryEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TerritoryEvent we want to update
     *   }
     * })
     */
    upsert<T extends TerritoryEventUpsertArgs>(args: SelectSubset<T, TerritoryEventUpsertArgs<ExtArgs>>): Prisma__TerritoryEventClient<$Result.GetResult<Prisma.$TerritoryEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TerritoryEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryEventCountArgs} args - Arguments to filter TerritoryEvents to count.
     * @example
     * // Count the number of TerritoryEvents
     * const count = await prisma.territoryEvent.count({
     *   where: {
     *     // ... the filter for the TerritoryEvents we want to count
     *   }
     * })
    **/
    count<T extends TerritoryEventCountArgs>(
      args?: Subset<T, TerritoryEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerritoryEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TerritoryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerritoryEventAggregateArgs>(args: Subset<T, TerritoryEventAggregateArgs>): Prisma.PrismaPromise<GetTerritoryEventAggregateType<T>>

    /**
     * Group by TerritoryEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerritoryEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerritoryEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerritoryEventGroupByArgs['orderBy'] }
        : { orderBy?: TerritoryEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerritoryEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerritoryEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TerritoryEvent model
   */
  readonly fields: TerritoryEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TerritoryEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerritoryEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    territory<T extends TerritoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerritoryDefaultArgs<ExtArgs>>): Prisma__TerritoryClient<$Result.GetResult<Prisma.$TerritoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TerritoryEvent model
   */ 
  interface TerritoryEventFieldRefs {
    readonly id: FieldRef<"TerritoryEvent", 'String'>
    readonly territoryId: FieldRef<"TerritoryEvent", 'String'>
    readonly type: FieldRef<"TerritoryEvent", 'TerritoryEventType'>
    readonly metadata: FieldRef<"TerritoryEvent", 'String'>
    readonly createdAt: FieldRef<"TerritoryEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TerritoryEvent findUnique
   */
  export type TerritoryEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * Filter, which TerritoryEvent to fetch.
     */
    where: TerritoryEventWhereUniqueInput
  }

  /**
   * TerritoryEvent findUniqueOrThrow
   */
  export type TerritoryEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * Filter, which TerritoryEvent to fetch.
     */
    where: TerritoryEventWhereUniqueInput
  }

  /**
   * TerritoryEvent findFirst
   */
  export type TerritoryEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * Filter, which TerritoryEvent to fetch.
     */
    where?: TerritoryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoryEvents to fetch.
     */
    orderBy?: TerritoryEventOrderByWithRelationInput | TerritoryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerritoryEvents.
     */
    cursor?: TerritoryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerritoryEvents.
     */
    distinct?: TerritoryEventScalarFieldEnum | TerritoryEventScalarFieldEnum[]
  }

  /**
   * TerritoryEvent findFirstOrThrow
   */
  export type TerritoryEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * Filter, which TerritoryEvent to fetch.
     */
    where?: TerritoryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoryEvents to fetch.
     */
    orderBy?: TerritoryEventOrderByWithRelationInput | TerritoryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerritoryEvents.
     */
    cursor?: TerritoryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoryEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerritoryEvents.
     */
    distinct?: TerritoryEventScalarFieldEnum | TerritoryEventScalarFieldEnum[]
  }

  /**
   * TerritoryEvent findMany
   */
  export type TerritoryEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * Filter, which TerritoryEvents to fetch.
     */
    where?: TerritoryEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerritoryEvents to fetch.
     */
    orderBy?: TerritoryEventOrderByWithRelationInput | TerritoryEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TerritoryEvents.
     */
    cursor?: TerritoryEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerritoryEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerritoryEvents.
     */
    skip?: number
    distinct?: TerritoryEventScalarFieldEnum | TerritoryEventScalarFieldEnum[]
  }

  /**
   * TerritoryEvent create
   */
  export type TerritoryEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TerritoryEvent.
     */
    data: XOR<TerritoryEventCreateInput, TerritoryEventUncheckedCreateInput>
  }

  /**
   * TerritoryEvent createMany
   */
  export type TerritoryEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TerritoryEvents.
     */
    data: TerritoryEventCreateManyInput | TerritoryEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TerritoryEvent createManyAndReturn
   */
  export type TerritoryEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TerritoryEvents.
     */
    data: TerritoryEventCreateManyInput | TerritoryEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TerritoryEvent update
   */
  export type TerritoryEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TerritoryEvent.
     */
    data: XOR<TerritoryEventUpdateInput, TerritoryEventUncheckedUpdateInput>
    /**
     * Choose, which TerritoryEvent to update.
     */
    where: TerritoryEventWhereUniqueInput
  }

  /**
   * TerritoryEvent updateMany
   */
  export type TerritoryEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TerritoryEvents.
     */
    data: XOR<TerritoryEventUpdateManyMutationInput, TerritoryEventUncheckedUpdateManyInput>
    /**
     * Filter which TerritoryEvents to update
     */
    where?: TerritoryEventWhereInput
  }

  /**
   * TerritoryEvent upsert
   */
  export type TerritoryEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TerritoryEvent to update in case it exists.
     */
    where: TerritoryEventWhereUniqueInput
    /**
     * In case the TerritoryEvent found by the `where` argument doesn't exist, create a new TerritoryEvent with this data.
     */
    create: XOR<TerritoryEventCreateInput, TerritoryEventUncheckedCreateInput>
    /**
     * In case the TerritoryEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerritoryEventUpdateInput, TerritoryEventUncheckedUpdateInput>
  }

  /**
   * TerritoryEvent delete
   */
  export type TerritoryEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
    /**
     * Filter which TerritoryEvent to delete.
     */
    where: TerritoryEventWhereUniqueInput
  }

  /**
   * TerritoryEvent deleteMany
   */
  export type TerritoryEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerritoryEvents to delete
     */
    where?: TerritoryEventWhereInput
  }

  /**
   * TerritoryEvent without action
   */
  export type TerritoryEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerritoryEvent
     */
    select?: TerritoryEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerritoryEventInclude<ExtArgs> | null
  }


  /**
   * Model Tournament
   */

  export type AggregateTournament = {
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    maxPlayers: number | null
    entryFee: number | null
    prizePool: number | null
  }

  export type TournamentSumAggregateOutputType = {
    maxPlayers: number | null
    entryFee: number | null
    prizePool: number | null
  }

  export type TournamentMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    name: string | null
    status: $Enums.TournamentStatus | null
    startTime: Date | null
    endTime: Date | null
    isSponsored: boolean | null
    sponsoredBy: string | null
    startDate: Date | null
    endDate: Date | null
    sponsorBannerUrl: string | null
    maxPlayers: number | null
    entryFee: number | null
    rewards: string | null
    prizePool: number | null
    format: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TournamentMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    name: string | null
    status: $Enums.TournamentStatus | null
    startTime: Date | null
    endTime: Date | null
    isSponsored: boolean | null
    sponsoredBy: string | null
    startDate: Date | null
    endDate: Date | null
    sponsorBannerUrl: string | null
    maxPlayers: number | null
    entryFee: number | null
    rewards: string | null
    prizePool: number | null
    format: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TournamentCountAggregateOutputType = {
    id: number
    venueId: number
    name: number
    status: number
    startTime: number
    endTime: number
    isSponsored: number
    sponsoredBy: number
    startDate: number
    endDate: number
    sponsorBannerUrl: number
    maxPlayers: number
    entryFee: number
    rewards: number
    prizePool: number
    format: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    maxPlayers?: true
    entryFee?: true
    prizePool?: true
  }

  export type TournamentSumAggregateInputType = {
    maxPlayers?: true
    entryFee?: true
    prizePool?: true
  }

  export type TournamentMinAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    status?: true
    startTime?: true
    endTime?: true
    isSponsored?: true
    sponsoredBy?: true
    startDate?: true
    endDate?: true
    sponsorBannerUrl?: true
    maxPlayers?: true
    entryFee?: true
    rewards?: true
    prizePool?: true
    format?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TournamentMaxAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    status?: true
    startTime?: true
    endTime?: true
    isSponsored?: true
    sponsoredBy?: true
    startDate?: true
    endDate?: true
    sponsorBannerUrl?: true
    maxPlayers?: true
    entryFee?: true
    rewards?: true
    prizePool?: true
    format?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TournamentCountAggregateInputType = {
    id?: true
    venueId?: true
    name?: true
    status?: true
    startTime?: true
    endTime?: true
    isSponsored?: true
    sponsoredBy?: true
    startDate?: true
    endDate?: true
    sponsorBannerUrl?: true
    maxPlayers?: true
    entryFee?: true
    rewards?: true
    prizePool?: true
    format?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournament to aggregate.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournaments
    **/
    _count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }




  export type TournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithAggregationInput | TournamentOrderByWithAggregationInput[]
    by: TournamentScalarFieldEnum[] | TournamentScalarFieldEnum
    having?: TournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentCountAggregateInputType | true
    _avg?: TournamentAvgAggregateInputType
    _sum?: TournamentSumAggregateInputType
    _min?: TournamentMinAggregateInputType
    _max?: TournamentMaxAggregateInputType
  }

  export type TournamentGroupByOutputType = {
    id: string
    venueId: string | null
    name: string
    status: $Enums.TournamentStatus
    startTime: Date
    endTime: Date | null
    isSponsored: boolean
    sponsoredBy: string | null
    startDate: Date | null
    endDate: Date | null
    sponsorBannerUrl: string | null
    maxPlayers: number
    entryFee: number
    rewards: string | null
    prizePool: number
    format: string
    createdAt: Date
    updatedAt: Date
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  type GetTournamentGroupByPayload<T extends TournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentGroupByOutputType[P]>
        }
      >
    >


  export type TournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    name?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    isSponsored?: boolean
    sponsoredBy?: boolean
    startDate?: boolean
    endDate?: boolean
    sponsorBannerUrl?: boolean
    maxPlayers?: boolean
    entryFee?: boolean
    rewards?: boolean
    prizePool?: boolean
    format?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | Tournament$venueArgs<ExtArgs>
    participants?: boolean | Tournament$participantsArgs<ExtArgs>
    matches?: boolean | Tournament$matchesArgs<ExtArgs>
    activityEvents?: boolean | Tournament$activityEventsArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    name?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    isSponsored?: boolean
    sponsoredBy?: boolean
    startDate?: boolean
    endDate?: boolean
    sponsorBannerUrl?: boolean
    maxPlayers?: boolean
    entryFee?: boolean
    rewards?: boolean
    prizePool?: boolean
    format?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | Tournament$venueArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectScalar = {
    id?: boolean
    venueId?: boolean
    name?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    isSponsored?: boolean
    sponsoredBy?: boolean
    startDate?: boolean
    endDate?: boolean
    sponsorBannerUrl?: boolean
    maxPlayers?: boolean
    entryFee?: boolean
    rewards?: boolean
    prizePool?: boolean
    format?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | Tournament$venueArgs<ExtArgs>
    participants?: boolean | Tournament$participantsArgs<ExtArgs>
    matches?: boolean | Tournament$matchesArgs<ExtArgs>
    activityEvents?: boolean | Tournament$activityEventsArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | Tournament$venueArgs<ExtArgs>
  }

  export type $TournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tournament"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs> | null
      participants: Prisma.$TournamentParticipantPayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
      activityEvents: Prisma.$ActivityEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string | null
      name: string
      status: $Enums.TournamentStatus
      startTime: Date
      endTime: Date | null
      isSponsored: boolean
      sponsoredBy: string | null
      startDate: Date | null
      endDate: Date | null
      sponsorBannerUrl: string | null
      maxPlayers: number
      entryFee: number
      rewards: string | null
      prizePool: number
      format: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tournament"]>
    composites: {}
  }

  type TournamentGetPayload<S extends boolean | null | undefined | TournamentDefaultArgs> = $Result.GetResult<Prisma.$TournamentPayload, S>

  type TournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TournamentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TournamentCountAggregateInputType | true
    }

  export interface TournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tournament'], meta: { name: 'Tournament' } }
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {TournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentFindUniqueArgs>(args: SelectSubset<T, TournamentFindUniqueArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tournament that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TournamentFindUniqueOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentFindFirstArgs>(args?: SelectSubset<T, TournamentFindFirstArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentWithIdOnly = await prisma.tournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentFindManyArgs>(args?: SelectSubset<T, TournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tournament.
     * @param {TournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
     */
    create<T extends TournamentCreateArgs>(args: SelectSubset<T, TournamentCreateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tournaments.
     * @param {TournamentCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentCreateManyArgs>(args?: SelectSubset<T, TournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {TournamentCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tournament.
     * @param {TournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
     */
    delete<T extends TournamentDeleteArgs>(args: SelectSubset<T, TournamentDeleteArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tournament.
     * @param {TournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentUpdateArgs>(args: SelectSubset<T, TournamentUpdateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tournaments.
     * @param {TournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentDeleteManyArgs>(args?: SelectSubset<T, TournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentUpdateManyArgs>(args: SelectSubset<T, TournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tournament.
     * @param {TournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
     */
    upsert<T extends TournamentUpsertArgs>(args: SelectSubset<T, TournamentUpsertArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends TournamentCountArgs>(
      args?: Subset<T, TournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Prisma.PrismaPromise<GetTournamentAggregateType<T>>

    /**
     * Group by Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentGroupByArgs['orderBy'] }
        : { orderBy?: TournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tournament model
   */
  readonly fields: TournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends Tournament$venueArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    participants<T extends Tournament$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    matches<T extends Tournament$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany"> | Null>
    activityEvents<T extends Tournament$activityEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$activityEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tournament model
   */ 
  interface TournamentFieldRefs {
    readonly id: FieldRef<"Tournament", 'String'>
    readonly venueId: FieldRef<"Tournament", 'String'>
    readonly name: FieldRef<"Tournament", 'String'>
    readonly status: FieldRef<"Tournament", 'TournamentStatus'>
    readonly startTime: FieldRef<"Tournament", 'DateTime'>
    readonly endTime: FieldRef<"Tournament", 'DateTime'>
    readonly isSponsored: FieldRef<"Tournament", 'Boolean'>
    readonly sponsoredBy: FieldRef<"Tournament", 'String'>
    readonly startDate: FieldRef<"Tournament", 'DateTime'>
    readonly endDate: FieldRef<"Tournament", 'DateTime'>
    readonly sponsorBannerUrl: FieldRef<"Tournament", 'String'>
    readonly maxPlayers: FieldRef<"Tournament", 'Int'>
    readonly entryFee: FieldRef<"Tournament", 'Int'>
    readonly rewards: FieldRef<"Tournament", 'String'>
    readonly prizePool: FieldRef<"Tournament", 'Int'>
    readonly format: FieldRef<"Tournament", 'String'>
    readonly createdAt: FieldRef<"Tournament", 'DateTime'>
    readonly updatedAt: FieldRef<"Tournament", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tournament findUnique
   */
  export type TournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findUniqueOrThrow
   */
  export type TournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findFirst
   */
  export type TournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findFirstOrThrow
   */
  export type TournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findMany
   */
  export type TournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournaments to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament create
   */
  export type TournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a Tournament.
     */
    data: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
  }

  /**
   * Tournament createMany
   */
  export type TournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournament createManyAndReturn
   */
  export type TournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tournament update
   */
  export type TournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a Tournament.
     */
    data: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
    /**
     * Choose, which Tournament to update.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament updateMany
   */
  export type TournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
  }

  /**
   * Tournament upsert
   */
  export type TournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the Tournament to update in case it exists.
     */
    where: TournamentWhereUniqueInput
    /**
     * In case the Tournament found by the `where` argument doesn't exist, create a new Tournament with this data.
     */
    create: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
    /**
     * In case the Tournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
  }

  /**
   * Tournament delete
   */
  export type TournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter which Tournament to delete.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament deleteMany
   */
  export type TournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournaments to delete
     */
    where?: TournamentWhereInput
  }

  /**
   * Tournament.venue
   */
  export type Tournament$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * Tournament.participants
   */
  export type Tournament$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    where?: TournamentParticipantWhereInput
    orderBy?: TournamentParticipantOrderByWithRelationInput | TournamentParticipantOrderByWithRelationInput[]
    cursor?: TournamentParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentParticipantScalarFieldEnum | TournamentParticipantScalarFieldEnum[]
  }

  /**
   * Tournament.matches
   */
  export type Tournament$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Tournament.activityEvents
   */
  export type Tournament$activityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    where?: ActivityEventWhereInput
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    cursor?: ActivityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * Tournament without action
   */
  export type TournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
  }


  /**
   * Model TournamentParticipant
   */

  export type AggregateTournamentParticipant = {
    _count: TournamentParticipantCountAggregateOutputType | null
    _avg: TournamentParticipantAvgAggregateOutputType | null
    _sum: TournamentParticipantSumAggregateOutputType | null
    _min: TournamentParticipantMinAggregateOutputType | null
    _max: TournamentParticipantMaxAggregateOutputType | null
  }

  export type TournamentParticipantAvgAggregateOutputType = {
    seed: number | null
    finalRank: number | null
  }

  export type TournamentParticipantSumAggregateOutputType = {
    seed: number | null
    finalRank: number | null
  }

  export type TournamentParticipantMinAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    userId: string | null
    seed: number | null
    finalRank: number | null
    createdAt: Date | null
  }

  export type TournamentParticipantMaxAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    userId: string | null
    seed: number | null
    finalRank: number | null
    createdAt: Date | null
  }

  export type TournamentParticipantCountAggregateOutputType = {
    id: number
    tournamentId: number
    userId: number
    seed: number
    finalRank: number
    createdAt: number
    _all: number
  }


  export type TournamentParticipantAvgAggregateInputType = {
    seed?: true
    finalRank?: true
  }

  export type TournamentParticipantSumAggregateInputType = {
    seed?: true
    finalRank?: true
  }

  export type TournamentParticipantMinAggregateInputType = {
    id?: true
    tournamentId?: true
    userId?: true
    seed?: true
    finalRank?: true
    createdAt?: true
  }

  export type TournamentParticipantMaxAggregateInputType = {
    id?: true
    tournamentId?: true
    userId?: true
    seed?: true
    finalRank?: true
    createdAt?: true
  }

  export type TournamentParticipantCountAggregateInputType = {
    id?: true
    tournamentId?: true
    userId?: true
    seed?: true
    finalRank?: true
    createdAt?: true
    _all?: true
  }

  export type TournamentParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentParticipant to aggregate.
     */
    where?: TournamentParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentParticipants to fetch.
     */
    orderBy?: TournamentParticipantOrderByWithRelationInput | TournamentParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentParticipants
    **/
    _count?: true | TournamentParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentParticipantMaxAggregateInputType
  }

  export type GetTournamentParticipantAggregateType<T extends TournamentParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentParticipant[P]>
      : GetScalarType<T[P], AggregateTournamentParticipant[P]>
  }




  export type TournamentParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentParticipantWhereInput
    orderBy?: TournamentParticipantOrderByWithAggregationInput | TournamentParticipantOrderByWithAggregationInput[]
    by: TournamentParticipantScalarFieldEnum[] | TournamentParticipantScalarFieldEnum
    having?: TournamentParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentParticipantCountAggregateInputType | true
    _avg?: TournamentParticipantAvgAggregateInputType
    _sum?: TournamentParticipantSumAggregateInputType
    _min?: TournamentParticipantMinAggregateInputType
    _max?: TournamentParticipantMaxAggregateInputType
  }

  export type TournamentParticipantGroupByOutputType = {
    id: string
    tournamentId: string
    userId: string
    seed: number | null
    finalRank: number | null
    createdAt: Date
    _count: TournamentParticipantCountAggregateOutputType | null
    _avg: TournamentParticipantAvgAggregateOutputType | null
    _sum: TournamentParticipantSumAggregateOutputType | null
    _min: TournamentParticipantMinAggregateOutputType | null
    _max: TournamentParticipantMaxAggregateOutputType | null
  }

  type GetTournamentParticipantGroupByPayload<T extends TournamentParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TournamentParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    userId?: boolean
    seed?: boolean
    finalRank?: boolean
    createdAt?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentParticipant"]>

  export type TournamentParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    userId?: boolean
    seed?: boolean
    finalRank?: boolean
    createdAt?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentParticipant"]>

  export type TournamentParticipantSelectScalar = {
    id?: boolean
    tournamentId?: boolean
    userId?: boolean
    seed?: boolean
    finalRank?: boolean
    createdAt?: boolean
  }

  export type TournamentParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TournamentParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TournamentParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TournamentParticipant"
    objects: {
      tournament: Prisma.$TournamentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournamentId: string
      userId: string
      seed: number | null
      finalRank: number | null
      createdAt: Date
    }, ExtArgs["result"]["tournamentParticipant"]>
    composites: {}
  }

  type TournamentParticipantGetPayload<S extends boolean | null | undefined | TournamentParticipantDefaultArgs> = $Result.GetResult<Prisma.$TournamentParticipantPayload, S>

  type TournamentParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TournamentParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TournamentParticipantCountAggregateInputType | true
    }

  export interface TournamentParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TournamentParticipant'], meta: { name: 'TournamentParticipant' } }
    /**
     * Find zero or one TournamentParticipant that matches the filter.
     * @param {TournamentParticipantFindUniqueArgs} args - Arguments to find a TournamentParticipant
     * @example
     * // Get one TournamentParticipant
     * const tournamentParticipant = await prisma.tournamentParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentParticipantFindUniqueArgs>(args: SelectSubset<T, TournamentParticipantFindUniqueArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TournamentParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TournamentParticipantFindUniqueOrThrowArgs} args - Arguments to find a TournamentParticipant
     * @example
     * // Get one TournamentParticipant
     * const tournamentParticipant = await prisma.tournamentParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TournamentParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentParticipantFindFirstArgs} args - Arguments to find a TournamentParticipant
     * @example
     * // Get one TournamentParticipant
     * const tournamentParticipant = await prisma.tournamentParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentParticipantFindFirstArgs>(args?: SelectSubset<T, TournamentParticipantFindFirstArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TournamentParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentParticipantFindFirstOrThrowArgs} args - Arguments to find a TournamentParticipant
     * @example
     * // Get one TournamentParticipant
     * const tournamentParticipant = await prisma.tournamentParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TournamentParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentParticipants
     * const tournamentParticipants = await prisma.tournamentParticipant.findMany()
     * 
     * // Get first 10 TournamentParticipants
     * const tournamentParticipants = await prisma.tournamentParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentParticipantWithIdOnly = await prisma.tournamentParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentParticipantFindManyArgs>(args?: SelectSubset<T, TournamentParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TournamentParticipant.
     * @param {TournamentParticipantCreateArgs} args - Arguments to create a TournamentParticipant.
     * @example
     * // Create one TournamentParticipant
     * const TournamentParticipant = await prisma.tournamentParticipant.create({
     *   data: {
     *     // ... data to create a TournamentParticipant
     *   }
     * })
     * 
     */
    create<T extends TournamentParticipantCreateArgs>(args: SelectSubset<T, TournamentParticipantCreateArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TournamentParticipants.
     * @param {TournamentParticipantCreateManyArgs} args - Arguments to create many TournamentParticipants.
     * @example
     * // Create many TournamentParticipants
     * const tournamentParticipant = await prisma.tournamentParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentParticipantCreateManyArgs>(args?: SelectSubset<T, TournamentParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TournamentParticipants and returns the data saved in the database.
     * @param {TournamentParticipantCreateManyAndReturnArgs} args - Arguments to create many TournamentParticipants.
     * @example
     * // Create many TournamentParticipants
     * const tournamentParticipant = await prisma.tournamentParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TournamentParticipants and only return the `id`
     * const tournamentParticipantWithIdOnly = await prisma.tournamentParticipant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TournamentParticipant.
     * @param {TournamentParticipantDeleteArgs} args - Arguments to delete one TournamentParticipant.
     * @example
     * // Delete one TournamentParticipant
     * const TournamentParticipant = await prisma.tournamentParticipant.delete({
     *   where: {
     *     // ... filter to delete one TournamentParticipant
     *   }
     * })
     * 
     */
    delete<T extends TournamentParticipantDeleteArgs>(args: SelectSubset<T, TournamentParticipantDeleteArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TournamentParticipant.
     * @param {TournamentParticipantUpdateArgs} args - Arguments to update one TournamentParticipant.
     * @example
     * // Update one TournamentParticipant
     * const tournamentParticipant = await prisma.tournamentParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentParticipantUpdateArgs>(args: SelectSubset<T, TournamentParticipantUpdateArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TournamentParticipants.
     * @param {TournamentParticipantDeleteManyArgs} args - Arguments to filter TournamentParticipants to delete.
     * @example
     * // Delete a few TournamentParticipants
     * const { count } = await prisma.tournamentParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentParticipantDeleteManyArgs>(args?: SelectSubset<T, TournamentParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentParticipants
     * const tournamentParticipant = await prisma.tournamentParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentParticipantUpdateManyArgs>(args: SelectSubset<T, TournamentParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TournamentParticipant.
     * @param {TournamentParticipantUpsertArgs} args - Arguments to update or create a TournamentParticipant.
     * @example
     * // Update or create a TournamentParticipant
     * const tournamentParticipant = await prisma.tournamentParticipant.upsert({
     *   create: {
     *     // ... data to create a TournamentParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TournamentParticipantUpsertArgs>(args: SelectSubset<T, TournamentParticipantUpsertArgs<ExtArgs>>): Prisma__TournamentParticipantClient<$Result.GetResult<Prisma.$TournamentParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TournamentParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentParticipantCountArgs} args - Arguments to filter TournamentParticipants to count.
     * @example
     * // Count the number of TournamentParticipants
     * const count = await prisma.tournamentParticipant.count({
     *   where: {
     *     // ... the filter for the TournamentParticipants we want to count
     *   }
     * })
    **/
    count<T extends TournamentParticipantCountArgs>(
      args?: Subset<T, TournamentParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentParticipantAggregateArgs>(args: Subset<T, TournamentParticipantAggregateArgs>): Prisma.PrismaPromise<GetTournamentParticipantAggregateType<T>>

    /**
     * Group by TournamentParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TournamentParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TournamentParticipant model
   */
  readonly fields: TournamentParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournament<T extends TournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentDefaultArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TournamentParticipant model
   */ 
  interface TournamentParticipantFieldRefs {
    readonly id: FieldRef<"TournamentParticipant", 'String'>
    readonly tournamentId: FieldRef<"TournamentParticipant", 'String'>
    readonly userId: FieldRef<"TournamentParticipant", 'String'>
    readonly seed: FieldRef<"TournamentParticipant", 'Int'>
    readonly finalRank: FieldRef<"TournamentParticipant", 'Int'>
    readonly createdAt: FieldRef<"TournamentParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TournamentParticipant findUnique
   */
  export type TournamentParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TournamentParticipant to fetch.
     */
    where: TournamentParticipantWhereUniqueInput
  }

  /**
   * TournamentParticipant findUniqueOrThrow
   */
  export type TournamentParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TournamentParticipant to fetch.
     */
    where: TournamentParticipantWhereUniqueInput
  }

  /**
   * TournamentParticipant findFirst
   */
  export type TournamentParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TournamentParticipant to fetch.
     */
    where?: TournamentParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentParticipants to fetch.
     */
    orderBy?: TournamentParticipantOrderByWithRelationInput | TournamentParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentParticipants.
     */
    cursor?: TournamentParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentParticipants.
     */
    distinct?: TournamentParticipantScalarFieldEnum | TournamentParticipantScalarFieldEnum[]
  }

  /**
   * TournamentParticipant findFirstOrThrow
   */
  export type TournamentParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TournamentParticipant to fetch.
     */
    where?: TournamentParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentParticipants to fetch.
     */
    orderBy?: TournamentParticipantOrderByWithRelationInput | TournamentParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentParticipants.
     */
    cursor?: TournamentParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentParticipants.
     */
    distinct?: TournamentParticipantScalarFieldEnum | TournamentParticipantScalarFieldEnum[]
  }

  /**
   * TournamentParticipant findMany
   */
  export type TournamentParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TournamentParticipants to fetch.
     */
    where?: TournamentParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentParticipants to fetch.
     */
    orderBy?: TournamentParticipantOrderByWithRelationInput | TournamentParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentParticipants.
     */
    cursor?: TournamentParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentParticipants.
     */
    skip?: number
    distinct?: TournamentParticipantScalarFieldEnum | TournamentParticipantScalarFieldEnum[]
  }

  /**
   * TournamentParticipant create
   */
  export type TournamentParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TournamentParticipant.
     */
    data: XOR<TournamentParticipantCreateInput, TournamentParticipantUncheckedCreateInput>
  }

  /**
   * TournamentParticipant createMany
   */
  export type TournamentParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TournamentParticipants.
     */
    data: TournamentParticipantCreateManyInput | TournamentParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TournamentParticipant createManyAndReturn
   */
  export type TournamentParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TournamentParticipants.
     */
    data: TournamentParticipantCreateManyInput | TournamentParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentParticipant update
   */
  export type TournamentParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TournamentParticipant.
     */
    data: XOR<TournamentParticipantUpdateInput, TournamentParticipantUncheckedUpdateInput>
    /**
     * Choose, which TournamentParticipant to update.
     */
    where: TournamentParticipantWhereUniqueInput
  }

  /**
   * TournamentParticipant updateMany
   */
  export type TournamentParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TournamentParticipants.
     */
    data: XOR<TournamentParticipantUpdateManyMutationInput, TournamentParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TournamentParticipants to update
     */
    where?: TournamentParticipantWhereInput
  }

  /**
   * TournamentParticipant upsert
   */
  export type TournamentParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TournamentParticipant to update in case it exists.
     */
    where: TournamentParticipantWhereUniqueInput
    /**
     * In case the TournamentParticipant found by the `where` argument doesn't exist, create a new TournamentParticipant with this data.
     */
    create: XOR<TournamentParticipantCreateInput, TournamentParticipantUncheckedCreateInput>
    /**
     * In case the TournamentParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentParticipantUpdateInput, TournamentParticipantUncheckedUpdateInput>
  }

  /**
   * TournamentParticipant delete
   */
  export type TournamentParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
    /**
     * Filter which TournamentParticipant to delete.
     */
    where: TournamentParticipantWhereUniqueInput
  }

  /**
   * TournamentParticipant deleteMany
   */
  export type TournamentParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentParticipants to delete
     */
    where?: TournamentParticipantWhereInput
  }

  /**
   * TournamentParticipant without action
   */
  export type TournamentParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentParticipant
     */
    select?: TournamentParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    scoreA: number | null
    scoreB: number | null
    round: number | null
    wager: number | null
  }

  export type MatchSumAggregateOutputType = {
    scoreA: number | null
    scoreB: number | null
    round: number | null
    wager: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    venueId: string | null
    tableId: string | null
    playerAId: string | null
    playerBId: string | null
    winnerId: string | null
    loserId: string | null
    status: $Enums.MatchStatus | null
    scoreA: number | null
    scoreB: number | null
    round: number | null
    wager: number | null
    aiAnalysisJson: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    venueId: string | null
    tableId: string | null
    playerAId: string | null
    playerBId: string | null
    winnerId: string | null
    loserId: string | null
    status: $Enums.MatchStatus | null
    scoreA: number | null
    scoreB: number | null
    round: number | null
    wager: number | null
    aiAnalysisJson: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    tournamentId: number
    venueId: number
    tableId: number
    playerAId: number
    playerBId: number
    winnerId: number
    loserId: number
    status: number
    scoreA: number
    scoreB: number
    round: number
    wager: number
    aiAnalysisJson: number
    startedAt: number
    endedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    scoreA?: true
    scoreB?: true
    round?: true
    wager?: true
  }

  export type MatchSumAggregateInputType = {
    scoreA?: true
    scoreB?: true
    round?: true
    wager?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    tournamentId?: true
    venueId?: true
    tableId?: true
    playerAId?: true
    playerBId?: true
    winnerId?: true
    loserId?: true
    status?: true
    scoreA?: true
    scoreB?: true
    round?: true
    wager?: true
    aiAnalysisJson?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    tournamentId?: true
    venueId?: true
    tableId?: true
    playerAId?: true
    playerBId?: true
    winnerId?: true
    loserId?: true
    status?: true
    scoreA?: true
    scoreB?: true
    round?: true
    wager?: true
    aiAnalysisJson?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    tournamentId?: true
    venueId?: true
    tableId?: true
    playerAId?: true
    playerBId?: true
    winnerId?: true
    loserId?: true
    status?: true
    scoreA?: true
    scoreB?: true
    round?: true
    wager?: true
    aiAnalysisJson?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: string
    tournamentId: string | null
    venueId: string | null
    tableId: string | null
    playerAId: string
    playerBId: string
    winnerId: string | null
    loserId: string | null
    status: $Enums.MatchStatus
    scoreA: number
    scoreB: number
    round: number | null
    wager: number
    aiAnalysisJson: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    venueId?: boolean
    tableId?: boolean
    playerAId?: boolean
    playerBId?: boolean
    winnerId?: boolean
    loserId?: boolean
    status?: boolean
    scoreA?: boolean
    scoreB?: boolean
    round?: boolean
    wager?: boolean
    aiAnalysisJson?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournament?: boolean | Match$tournamentArgs<ExtArgs>
    venue?: boolean | Match$venueArgs<ExtArgs>
    table?: boolean | Match$tableArgs<ExtArgs>
    playerA?: boolean | UserDefaultArgs<ExtArgs>
    playerB?: boolean | UserDefaultArgs<ExtArgs>
    events?: boolean | Match$eventsArgs<ExtArgs>
    activityEvents?: boolean | Match$activityEventsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    venueId?: boolean
    tableId?: boolean
    playerAId?: boolean
    playerBId?: boolean
    winnerId?: boolean
    loserId?: boolean
    status?: boolean
    scoreA?: boolean
    scoreB?: boolean
    round?: boolean
    wager?: boolean
    aiAnalysisJson?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournament?: boolean | Match$tournamentArgs<ExtArgs>
    venue?: boolean | Match$venueArgs<ExtArgs>
    table?: boolean | Match$tableArgs<ExtArgs>
    playerA?: boolean | UserDefaultArgs<ExtArgs>
    playerB?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    tournamentId?: boolean
    venueId?: boolean
    tableId?: boolean
    playerAId?: boolean
    playerBId?: boolean
    winnerId?: boolean
    loserId?: boolean
    status?: boolean
    scoreA?: boolean
    scoreB?: boolean
    round?: boolean
    wager?: boolean
    aiAnalysisJson?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | Match$tournamentArgs<ExtArgs>
    venue?: boolean | Match$venueArgs<ExtArgs>
    table?: boolean | Match$tableArgs<ExtArgs>
    playerA?: boolean | UserDefaultArgs<ExtArgs>
    playerB?: boolean | UserDefaultArgs<ExtArgs>
    events?: boolean | Match$eventsArgs<ExtArgs>
    activityEvents?: boolean | Match$activityEventsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | Match$tournamentArgs<ExtArgs>
    venue?: boolean | Match$venueArgs<ExtArgs>
    table?: boolean | Match$tableArgs<ExtArgs>
    playerA?: boolean | UserDefaultArgs<ExtArgs>
    playerB?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      tournament: Prisma.$TournamentPayload<ExtArgs> | null
      venue: Prisma.$VenuePayload<ExtArgs> | null
      table: Prisma.$TablePayload<ExtArgs> | null
      playerA: Prisma.$UserPayload<ExtArgs>
      playerB: Prisma.$UserPayload<ExtArgs>
      events: Prisma.$MatchEventPayload<ExtArgs>[]
      activityEvents: Prisma.$ActivityEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournamentId: string | null
      venueId: string | null
      tableId: string | null
      playerAId: string
      playerBId: string
      winnerId: string | null
      loserId: string | null
      status: $Enums.MatchStatus
      scoreA: number
      scoreB: number
      round: number | null
      wager: number
      aiAnalysisJson: string | null
      startedAt: Date | null
      endedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournament<T extends Match$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, Match$tournamentArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    venue<T extends Match$venueArgs<ExtArgs> = {}>(args?: Subset<T, Match$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    table<T extends Match$tableArgs<ExtArgs> = {}>(args?: Subset<T, Match$tableArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    playerA<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    playerB<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    events<T extends Match$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Match$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findMany"> | Null>
    activityEvents<T extends Match$activityEventsArgs<ExtArgs> = {}>(args?: Subset<T, Match$activityEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */ 
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'String'>
    readonly tournamentId: FieldRef<"Match", 'String'>
    readonly venueId: FieldRef<"Match", 'String'>
    readonly tableId: FieldRef<"Match", 'String'>
    readonly playerAId: FieldRef<"Match", 'String'>
    readonly playerBId: FieldRef<"Match", 'String'>
    readonly winnerId: FieldRef<"Match", 'String'>
    readonly loserId: FieldRef<"Match", 'String'>
    readonly status: FieldRef<"Match", 'MatchStatus'>
    readonly scoreA: FieldRef<"Match", 'Int'>
    readonly scoreB: FieldRef<"Match", 'Int'>
    readonly round: FieldRef<"Match", 'Int'>
    readonly wager: FieldRef<"Match", 'Int'>
    readonly aiAnalysisJson: FieldRef<"Match", 'String'>
    readonly startedAt: FieldRef<"Match", 'DateTime'>
    readonly endedAt: FieldRef<"Match", 'DateTime'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
    readonly updatedAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
  }

  /**
   * Match.tournament
   */
  export type Match$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
  }

  /**
   * Match.venue
   */
  export type Match$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * Match.table
   */
  export type Match$tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
  }

  /**
   * Match.events
   */
  export type Match$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    where?: MatchEventWhereInput
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    cursor?: MatchEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchEventScalarFieldEnum | MatchEventScalarFieldEnum[]
  }

  /**
   * Match.activityEvents
   */
  export type Match$activityEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    where?: ActivityEventWhereInput
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    cursor?: ActivityEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model MatchEvent
   */

  export type AggregateMatchEvent = {
    _count: MatchEventCountAggregateOutputType | null
    _min: MatchEventMinAggregateOutputType | null
    _max: MatchEventMaxAggregateOutputType | null
  }

  export type MatchEventMinAggregateOutputType = {
    id: string | null
    matchId: string | null
    type: $Enums.MatchEventType | null
    payload: string | null
    ts: Date | null
  }

  export type MatchEventMaxAggregateOutputType = {
    id: string | null
    matchId: string | null
    type: $Enums.MatchEventType | null
    payload: string | null
    ts: Date | null
  }

  export type MatchEventCountAggregateOutputType = {
    id: number
    matchId: number
    type: number
    payload: number
    ts: number
    _all: number
  }


  export type MatchEventMinAggregateInputType = {
    id?: true
    matchId?: true
    type?: true
    payload?: true
    ts?: true
  }

  export type MatchEventMaxAggregateInputType = {
    id?: true
    matchId?: true
    type?: true
    payload?: true
    ts?: true
  }

  export type MatchEventCountAggregateInputType = {
    id?: true
    matchId?: true
    type?: true
    payload?: true
    ts?: true
    _all?: true
  }

  export type MatchEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchEvent to aggregate.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchEvents
    **/
    _count?: true | MatchEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchEventMaxAggregateInputType
  }

  export type GetMatchEventAggregateType<T extends MatchEventAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchEvent[P]>
      : GetScalarType<T[P], AggregateMatchEvent[P]>
  }




  export type MatchEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchEventWhereInput
    orderBy?: MatchEventOrderByWithAggregationInput | MatchEventOrderByWithAggregationInput[]
    by: MatchEventScalarFieldEnum[] | MatchEventScalarFieldEnum
    having?: MatchEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchEventCountAggregateInputType | true
    _min?: MatchEventMinAggregateInputType
    _max?: MatchEventMaxAggregateInputType
  }

  export type MatchEventGroupByOutputType = {
    id: string
    matchId: string
    type: $Enums.MatchEventType
    payload: string
    ts: Date
    _count: MatchEventCountAggregateOutputType | null
    _min: MatchEventMinAggregateOutputType | null
    _max: MatchEventMaxAggregateOutputType | null
  }

  type GetMatchEventGroupByPayload<T extends MatchEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchEventGroupByOutputType[P]>
            : GetScalarType<T[P], MatchEventGroupByOutputType[P]>
        }
      >
    >


  export type MatchEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    type?: boolean
    payload?: boolean
    ts?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchEvent"]>

  export type MatchEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    type?: boolean
    payload?: boolean
    ts?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchEvent"]>

  export type MatchEventSelectScalar = {
    id?: boolean
    matchId?: boolean
    type?: boolean
    payload?: boolean
    ts?: boolean
  }

  export type MatchEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }
  export type MatchEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }

  export type $MatchEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchEvent"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matchId: string
      type: $Enums.MatchEventType
      payload: string
      ts: Date
    }, ExtArgs["result"]["matchEvent"]>
    composites: {}
  }

  type MatchEventGetPayload<S extends boolean | null | undefined | MatchEventDefaultArgs> = $Result.GetResult<Prisma.$MatchEventPayload, S>

  type MatchEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchEventCountAggregateInputType | true
    }

  export interface MatchEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchEvent'], meta: { name: 'MatchEvent' } }
    /**
     * Find zero or one MatchEvent that matches the filter.
     * @param {MatchEventFindUniqueArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchEventFindUniqueArgs>(args: SelectSubset<T, MatchEventFindUniqueArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MatchEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchEventFindUniqueOrThrowArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchEventFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MatchEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventFindFirstArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchEventFindFirstArgs>(args?: SelectSubset<T, MatchEventFindFirstArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MatchEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventFindFirstOrThrowArgs} args - Arguments to find a MatchEvent
     * @example
     * // Get one MatchEvent
     * const matchEvent = await prisma.matchEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchEventFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MatchEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchEvents
     * const matchEvents = await prisma.matchEvent.findMany()
     * 
     * // Get first 10 MatchEvents
     * const matchEvents = await prisma.matchEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchEventWithIdOnly = await prisma.matchEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchEventFindManyArgs>(args?: SelectSubset<T, MatchEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MatchEvent.
     * @param {MatchEventCreateArgs} args - Arguments to create a MatchEvent.
     * @example
     * // Create one MatchEvent
     * const MatchEvent = await prisma.matchEvent.create({
     *   data: {
     *     // ... data to create a MatchEvent
     *   }
     * })
     * 
     */
    create<T extends MatchEventCreateArgs>(args: SelectSubset<T, MatchEventCreateArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MatchEvents.
     * @param {MatchEventCreateManyArgs} args - Arguments to create many MatchEvents.
     * @example
     * // Create many MatchEvents
     * const matchEvent = await prisma.matchEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchEventCreateManyArgs>(args?: SelectSubset<T, MatchEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchEvents and returns the data saved in the database.
     * @param {MatchEventCreateManyAndReturnArgs} args - Arguments to create many MatchEvents.
     * @example
     * // Create many MatchEvents
     * const matchEvent = await prisma.matchEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchEvents and only return the `id`
     * const matchEventWithIdOnly = await prisma.matchEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchEventCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MatchEvent.
     * @param {MatchEventDeleteArgs} args - Arguments to delete one MatchEvent.
     * @example
     * // Delete one MatchEvent
     * const MatchEvent = await prisma.matchEvent.delete({
     *   where: {
     *     // ... filter to delete one MatchEvent
     *   }
     * })
     * 
     */
    delete<T extends MatchEventDeleteArgs>(args: SelectSubset<T, MatchEventDeleteArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MatchEvent.
     * @param {MatchEventUpdateArgs} args - Arguments to update one MatchEvent.
     * @example
     * // Update one MatchEvent
     * const matchEvent = await prisma.matchEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchEventUpdateArgs>(args: SelectSubset<T, MatchEventUpdateArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MatchEvents.
     * @param {MatchEventDeleteManyArgs} args - Arguments to filter MatchEvents to delete.
     * @example
     * // Delete a few MatchEvents
     * const { count } = await prisma.matchEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchEventDeleteManyArgs>(args?: SelectSubset<T, MatchEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchEvents
     * const matchEvent = await prisma.matchEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchEventUpdateManyArgs>(args: SelectSubset<T, MatchEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatchEvent.
     * @param {MatchEventUpsertArgs} args - Arguments to update or create a MatchEvent.
     * @example
     * // Update or create a MatchEvent
     * const matchEvent = await prisma.matchEvent.upsert({
     *   create: {
     *     // ... data to create a MatchEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchEvent we want to update
     *   }
     * })
     */
    upsert<T extends MatchEventUpsertArgs>(args: SelectSubset<T, MatchEventUpsertArgs<ExtArgs>>): Prisma__MatchEventClient<$Result.GetResult<Prisma.$MatchEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MatchEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventCountArgs} args - Arguments to filter MatchEvents to count.
     * @example
     * // Count the number of MatchEvents
     * const count = await prisma.matchEvent.count({
     *   where: {
     *     // ... the filter for the MatchEvents we want to count
     *   }
     * })
    **/
    count<T extends MatchEventCountArgs>(
      args?: Subset<T, MatchEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchEventAggregateArgs>(args: Subset<T, MatchEventAggregateArgs>): Prisma.PrismaPromise<GetMatchEventAggregateType<T>>

    /**
     * Group by MatchEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchEventGroupByArgs['orderBy'] }
        : { orderBy?: MatchEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchEvent model
   */
  readonly fields: MatchEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchEvent model
   */ 
  interface MatchEventFieldRefs {
    readonly id: FieldRef<"MatchEvent", 'String'>
    readonly matchId: FieldRef<"MatchEvent", 'String'>
    readonly type: FieldRef<"MatchEvent", 'MatchEventType'>
    readonly payload: FieldRef<"MatchEvent", 'String'>
    readonly ts: FieldRef<"MatchEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchEvent findUnique
   */
  export type MatchEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent findUniqueOrThrow
   */
  export type MatchEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent findFirst
   */
  export type MatchEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchEvents.
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchEvents.
     */
    distinct?: MatchEventScalarFieldEnum | MatchEventScalarFieldEnum[]
  }

  /**
   * MatchEvent findFirstOrThrow
   */
  export type MatchEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * Filter, which MatchEvent to fetch.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchEvents.
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchEvents.
     */
    distinct?: MatchEventScalarFieldEnum | MatchEventScalarFieldEnum[]
  }

  /**
   * MatchEvent findMany
   */
  export type MatchEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * Filter, which MatchEvents to fetch.
     */
    where?: MatchEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchEvents to fetch.
     */
    orderBy?: MatchEventOrderByWithRelationInput | MatchEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchEvents.
     */
    cursor?: MatchEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchEvents.
     */
    skip?: number
    distinct?: MatchEventScalarFieldEnum | MatchEventScalarFieldEnum[]
  }

  /**
   * MatchEvent create
   */
  export type MatchEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchEvent.
     */
    data: XOR<MatchEventCreateInput, MatchEventUncheckedCreateInput>
  }

  /**
   * MatchEvent createMany
   */
  export type MatchEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchEvents.
     */
    data: MatchEventCreateManyInput | MatchEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchEvent createManyAndReturn
   */
  export type MatchEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MatchEvents.
     */
    data: MatchEventCreateManyInput | MatchEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchEvent update
   */
  export type MatchEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchEvent.
     */
    data: XOR<MatchEventUpdateInput, MatchEventUncheckedUpdateInput>
    /**
     * Choose, which MatchEvent to update.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent updateMany
   */
  export type MatchEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchEvents.
     */
    data: XOR<MatchEventUpdateManyMutationInput, MatchEventUncheckedUpdateManyInput>
    /**
     * Filter which MatchEvents to update
     */
    where?: MatchEventWhereInput
  }

  /**
   * MatchEvent upsert
   */
  export type MatchEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchEvent to update in case it exists.
     */
    where: MatchEventWhereUniqueInput
    /**
     * In case the MatchEvent found by the `where` argument doesn't exist, create a new MatchEvent with this data.
     */
    create: XOR<MatchEventCreateInput, MatchEventUncheckedCreateInput>
    /**
     * In case the MatchEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchEventUpdateInput, MatchEventUncheckedUpdateInput>
  }

  /**
   * MatchEvent delete
   */
  export type MatchEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
    /**
     * Filter which MatchEvent to delete.
     */
    where: MatchEventWhereUniqueInput
  }

  /**
   * MatchEvent deleteMany
   */
  export type MatchEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchEvents to delete
     */
    where?: MatchEventWhereInput
  }

  /**
   * MatchEvent without action
   */
  export type MatchEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchEvent
     */
    select?: MatchEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchEventInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    stakeCoins: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    stakeCoins: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: string | null
    challengerId: string | null
    defenderId: string | null
    venueId: string | null
    status: $Enums.ChallengeStatus | null
    stakeCoins: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: string | null
    challengerId: string | null
    defenderId: string | null
    venueId: string | null
    status: $Enums.ChallengeStatus | null
    stakeCoins: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    challengerId: number
    defenderId: number
    venueId: number
    status: number
    stakeCoins: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    stakeCoins?: true
  }

  export type ChallengeSumAggregateInputType = {
    stakeCoins?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    challengerId?: true
    defenderId?: true
    venueId?: true
    status?: true
    stakeCoins?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    challengerId?: true
    defenderId?: true
    venueId?: true
    status?: true
    stakeCoins?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    challengerId?: true
    defenderId?: true
    venueId?: true
    status?: true
    stakeCoins?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: string
    challengerId: string
    defenderId: string
    venueId: string | null
    status: $Enums.ChallengeStatus
    stakeCoins: number
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengerId?: boolean
    defenderId?: boolean
    venueId?: boolean
    status?: boolean
    stakeCoins?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    challenger?: boolean | UserDefaultArgs<ExtArgs>
    defender?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | Challenge$venueArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengerId?: boolean
    defenderId?: boolean
    venueId?: boolean
    status?: boolean
    stakeCoins?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    challenger?: boolean | UserDefaultArgs<ExtArgs>
    defender?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | Challenge$venueArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    challengerId?: boolean
    defenderId?: boolean
    venueId?: boolean
    status?: boolean
    stakeCoins?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenger?: boolean | UserDefaultArgs<ExtArgs>
    defender?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | Challenge$venueArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenger?: boolean | UserDefaultArgs<ExtArgs>
    defender?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | Challenge$venueArgs<ExtArgs>
  }

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      challenger: Prisma.$UserPayload<ExtArgs>
      defender: Prisma.$UserPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengerId: string
      defenderId: string
      venueId: string | null
      status: $Enums.ChallengeStatus
      stakeCoins: number
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenger<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    defender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    venue<T extends Challenge$venueArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */ 
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'String'>
    readonly challengerId: FieldRef<"Challenge", 'String'>
    readonly defenderId: FieldRef<"Challenge", 'String'>
    readonly venueId: FieldRef<"Challenge", 'String'>
    readonly status: FieldRef<"Challenge", 'ChallengeStatus'>
    readonly stakeCoins: FieldRef<"Challenge", 'Int'>
    readonly expiresAt: FieldRef<"Challenge", 'DateTime'>
    readonly createdAt: FieldRef<"Challenge", 'DateTime'>
    readonly updatedAt: FieldRef<"Challenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge.venue
   */
  export type Challenge$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    chain: string | null
    address: string | null
    createdAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    chain: string | null
    address: string | null
    createdAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    chain: number
    address: number
    createdAt: number
    _all: number
  }


  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    chain?: true
    address?: true
    createdAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    chain?: true
    address?: true
    createdAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    chain?: true
    address?: true
    createdAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    chain: string
    address: string
    createdAt: Date
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chain?: boolean
    address?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    chain?: boolean
    address?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    chain?: boolean
    address?: boolean
    createdAt?: boolean
  }

  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      chain: string
      address: string
      createdAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */ 
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly chain: FieldRef<"Wallet", 'String'>
    readonly address: FieldRef<"Wallet", 'String'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    type: $Enums.TxType | null
    metadata: string | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    type: $Enums.TxType | null
    metadata: string | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    type: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    type?: true
    metadata?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    type?: true
    metadata?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    type?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    amount: number
    currency: string
    type: $Enums.TxType
    metadata: string
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      currency: string
      type: $Enums.TxType
      metadata: string
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TxType'>
    readonly metadata: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model NFT
   */

  export type AggregateNFT = {
    _count: NFTCountAggregateOutputType | null
    _min: NFTMinAggregateOutputType | null
    _max: NFTMaxAggregateOutputType | null
  }

  export type NFTMinAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    chain: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type NFTMaxAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    chain: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type NFTCountAggregateOutputType = {
    id: number
    contract: number
    tokenId: number
    chain: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NFTMinAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    chain?: true
    metadata?: true
    createdAt?: true
  }

  export type NFTMaxAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    chain?: true
    metadata?: true
    createdAt?: true
  }

  export type NFTCountAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    chain?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NFTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFT to aggregate.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NFTS
    **/
    _count?: true | NFTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NFTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NFTMaxAggregateInputType
  }

  export type GetNFTAggregateType<T extends NFTAggregateArgs> = {
        [P in keyof T & keyof AggregateNFT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNFT[P]>
      : GetScalarType<T[P], AggregateNFT[P]>
  }




  export type NFTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTWhereInput
    orderBy?: NFTOrderByWithAggregationInput | NFTOrderByWithAggregationInput[]
    by: NFTScalarFieldEnum[] | NFTScalarFieldEnum
    having?: NFTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NFTCountAggregateInputType | true
    _min?: NFTMinAggregateInputType
    _max?: NFTMaxAggregateInputType
  }

  export type NFTGroupByOutputType = {
    id: string
    contract: string
    tokenId: string
    chain: string
    metadata: string
    createdAt: Date
    _count: NFTCountAggregateOutputType | null
    _min: NFTMinAggregateOutputType | null
    _max: NFTMaxAggregateOutputType | null
  }

  type GetNFTGroupByPayload<T extends NFTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NFTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NFTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NFTGroupByOutputType[P]>
            : GetScalarType<T[P], NFTGroupByOutputType[P]>
        }
      >
    >


  export type NFTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    chain?: boolean
    metadata?: boolean
    createdAt?: boolean
    users?: boolean | NFT$usersArgs<ExtArgs>
    _count?: boolean | NFTCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nFT"]>

  export type NFTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    chain?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nFT"]>

  export type NFTSelectScalar = {
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    chain?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NFTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | NFT$usersArgs<ExtArgs>
    _count?: boolean | NFTCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NFTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NFTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NFT"
    objects: {
      users: Prisma.$UserNFTPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contract: string
      tokenId: string
      chain: string
      metadata: string
      createdAt: Date
    }, ExtArgs["result"]["nFT"]>
    composites: {}
  }

  type NFTGetPayload<S extends boolean | null | undefined | NFTDefaultArgs> = $Result.GetResult<Prisma.$NFTPayload, S>

  type NFTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NFTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NFTCountAggregateInputType | true
    }

  export interface NFTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NFT'], meta: { name: 'NFT' } }
    /**
     * Find zero or one NFT that matches the filter.
     * @param {NFTFindUniqueArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NFTFindUniqueArgs>(args: SelectSubset<T, NFTFindUniqueArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NFT that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NFTFindUniqueOrThrowArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NFTFindUniqueOrThrowArgs>(args: SelectSubset<T, NFTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NFT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindFirstArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NFTFindFirstArgs>(args?: SelectSubset<T, NFTFindFirstArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NFT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindFirstOrThrowArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NFTFindFirstOrThrowArgs>(args?: SelectSubset<T, NFTFindFirstOrThrowArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NFTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NFTS
     * const nFTS = await prisma.nFT.findMany()
     * 
     * // Get first 10 NFTS
     * const nFTS = await prisma.nFT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nFTWithIdOnly = await prisma.nFT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NFTFindManyArgs>(args?: SelectSubset<T, NFTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NFT.
     * @param {NFTCreateArgs} args - Arguments to create a NFT.
     * @example
     * // Create one NFT
     * const NFT = await prisma.nFT.create({
     *   data: {
     *     // ... data to create a NFT
     *   }
     * })
     * 
     */
    create<T extends NFTCreateArgs>(args: SelectSubset<T, NFTCreateArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NFTS.
     * @param {NFTCreateManyArgs} args - Arguments to create many NFTS.
     * @example
     * // Create many NFTS
     * const nFT = await prisma.nFT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NFTCreateManyArgs>(args?: SelectSubset<T, NFTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NFTS and returns the data saved in the database.
     * @param {NFTCreateManyAndReturnArgs} args - Arguments to create many NFTS.
     * @example
     * // Create many NFTS
     * const nFT = await prisma.nFT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NFTS and only return the `id`
     * const nFTWithIdOnly = await prisma.nFT.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NFTCreateManyAndReturnArgs>(args?: SelectSubset<T, NFTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NFT.
     * @param {NFTDeleteArgs} args - Arguments to delete one NFT.
     * @example
     * // Delete one NFT
     * const NFT = await prisma.nFT.delete({
     *   where: {
     *     // ... filter to delete one NFT
     *   }
     * })
     * 
     */
    delete<T extends NFTDeleteArgs>(args: SelectSubset<T, NFTDeleteArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NFT.
     * @param {NFTUpdateArgs} args - Arguments to update one NFT.
     * @example
     * // Update one NFT
     * const nFT = await prisma.nFT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NFTUpdateArgs>(args: SelectSubset<T, NFTUpdateArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NFTS.
     * @param {NFTDeleteManyArgs} args - Arguments to filter NFTS to delete.
     * @example
     * // Delete a few NFTS
     * const { count } = await prisma.nFT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NFTDeleteManyArgs>(args?: SelectSubset<T, NFTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NFTS
     * const nFT = await prisma.nFT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NFTUpdateManyArgs>(args: SelectSubset<T, NFTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NFT.
     * @param {NFTUpsertArgs} args - Arguments to update or create a NFT.
     * @example
     * // Update or create a NFT
     * const nFT = await prisma.nFT.upsert({
     *   create: {
     *     // ... data to create a NFT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NFT we want to update
     *   }
     * })
     */
    upsert<T extends NFTUpsertArgs>(args: SelectSubset<T, NFTUpsertArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTCountArgs} args - Arguments to filter NFTS to count.
     * @example
     * // Count the number of NFTS
     * const count = await prisma.nFT.count({
     *   where: {
     *     // ... the filter for the NFTS we want to count
     *   }
     * })
    **/
    count<T extends NFTCountArgs>(
      args?: Subset<T, NFTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NFTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NFTAggregateArgs>(args: Subset<T, NFTAggregateArgs>): Prisma.PrismaPromise<GetNFTAggregateType<T>>

    /**
     * Group by NFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NFTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NFTGroupByArgs['orderBy'] }
        : { orderBy?: NFTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NFTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNFTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NFT model
   */
  readonly fields: NFTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NFT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NFTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends NFT$usersArgs<ExtArgs> = {}>(args?: Subset<T, NFT$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NFT model
   */ 
  interface NFTFieldRefs {
    readonly id: FieldRef<"NFT", 'String'>
    readonly contract: FieldRef<"NFT", 'String'>
    readonly tokenId: FieldRef<"NFT", 'String'>
    readonly chain: FieldRef<"NFT", 'String'>
    readonly metadata: FieldRef<"NFT", 'String'>
    readonly createdAt: FieldRef<"NFT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NFT findUnique
   */
  export type NFTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT findUniqueOrThrow
   */
  export type NFTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT findFirst
   */
  export type NFTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTS.
     */
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT findFirstOrThrow
   */
  export type NFTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTS.
     */
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT findMany
   */
  export type NFTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFTS to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT create
   */
  export type NFTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * The data needed to create a NFT.
     */
    data: XOR<NFTCreateInput, NFTUncheckedCreateInput>
  }

  /**
   * NFT createMany
   */
  export type NFTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NFTS.
     */
    data: NFTCreateManyInput | NFTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NFT createManyAndReturn
   */
  export type NFTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NFTS.
     */
    data: NFTCreateManyInput | NFTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NFT update
   */
  export type NFTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * The data needed to update a NFT.
     */
    data: XOR<NFTUpdateInput, NFTUncheckedUpdateInput>
    /**
     * Choose, which NFT to update.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT updateMany
   */
  export type NFTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NFTS.
     */
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyInput>
    /**
     * Filter which NFTS to update
     */
    where?: NFTWhereInput
  }

  /**
   * NFT upsert
   */
  export type NFTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * The filter to search for the NFT to update in case it exists.
     */
    where: NFTWhereUniqueInput
    /**
     * In case the NFT found by the `where` argument doesn't exist, create a new NFT with this data.
     */
    create: XOR<NFTCreateInput, NFTUncheckedCreateInput>
    /**
     * In case the NFT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NFTUpdateInput, NFTUncheckedUpdateInput>
  }

  /**
   * NFT delete
   */
  export type NFTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter which NFT to delete.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT deleteMany
   */
  export type NFTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTS to delete
     */
    where?: NFTWhereInput
  }

  /**
   * NFT.users
   */
  export type NFT$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    where?: UserNFTWhereInput
    orderBy?: UserNFTOrderByWithRelationInput | UserNFTOrderByWithRelationInput[]
    cursor?: UserNFTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNFTScalarFieldEnum | UserNFTScalarFieldEnum[]
  }

  /**
   * NFT without action
   */
  export type NFTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
  }


  /**
   * Model UserNFT
   */

  export type AggregateUserNFT = {
    _count: UserNFTCountAggregateOutputType | null
    _min: UserNFTMinAggregateOutputType | null
    _max: UserNFTMaxAggregateOutputType | null
  }

  export type UserNFTMinAggregateOutputType = {
    id: string | null
    userId: string | null
    nftId: string | null
    createdAt: Date | null
  }

  export type UserNFTMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    nftId: string | null
    createdAt: Date | null
  }

  export type UserNFTCountAggregateOutputType = {
    id: number
    userId: number
    nftId: number
    createdAt: number
    _all: number
  }


  export type UserNFTMinAggregateInputType = {
    id?: true
    userId?: true
    nftId?: true
    createdAt?: true
  }

  export type UserNFTMaxAggregateInputType = {
    id?: true
    userId?: true
    nftId?: true
    createdAt?: true
  }

  export type UserNFTCountAggregateInputType = {
    id?: true
    userId?: true
    nftId?: true
    createdAt?: true
    _all?: true
  }

  export type UserNFTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNFT to aggregate.
     */
    where?: UserNFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNFTS to fetch.
     */
    orderBy?: UserNFTOrderByWithRelationInput | UserNFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNFTS
    **/
    _count?: true | UserNFTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNFTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNFTMaxAggregateInputType
  }

  export type GetUserNFTAggregateType<T extends UserNFTAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNFT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNFT[P]>
      : GetScalarType<T[P], AggregateUserNFT[P]>
  }




  export type UserNFTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNFTWhereInput
    orderBy?: UserNFTOrderByWithAggregationInput | UserNFTOrderByWithAggregationInput[]
    by: UserNFTScalarFieldEnum[] | UserNFTScalarFieldEnum
    having?: UserNFTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNFTCountAggregateInputType | true
    _min?: UserNFTMinAggregateInputType
    _max?: UserNFTMaxAggregateInputType
  }

  export type UserNFTGroupByOutputType = {
    id: string
    userId: string
    nftId: string
    createdAt: Date
    _count: UserNFTCountAggregateOutputType | null
    _min: UserNFTMinAggregateOutputType | null
    _max: UserNFTMaxAggregateOutputType | null
  }

  type GetUserNFTGroupByPayload<T extends UserNFTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNFTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNFTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNFTGroupByOutputType[P]>
            : GetScalarType<T[P], UserNFTGroupByOutputType[P]>
        }
      >
    >


  export type UserNFTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    nftId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNFT"]>

  export type UserNFTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    nftId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNFT"]>

  export type UserNFTSelectScalar = {
    id?: boolean
    userId?: boolean
    nftId?: boolean
    createdAt?: boolean
  }

  export type UserNFTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type UserNFTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }

  export type $UserNFTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNFT"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      nft: Prisma.$NFTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      nftId: string
      createdAt: Date
    }, ExtArgs["result"]["userNFT"]>
    composites: {}
  }

  type UserNFTGetPayload<S extends boolean | null | undefined | UserNFTDefaultArgs> = $Result.GetResult<Prisma.$UserNFTPayload, S>

  type UserNFTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserNFTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserNFTCountAggregateInputType | true
    }

  export interface UserNFTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNFT'], meta: { name: 'UserNFT' } }
    /**
     * Find zero or one UserNFT that matches the filter.
     * @param {UserNFTFindUniqueArgs} args - Arguments to find a UserNFT
     * @example
     * // Get one UserNFT
     * const userNFT = await prisma.userNFT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNFTFindUniqueArgs>(args: SelectSubset<T, UserNFTFindUniqueArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserNFT that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserNFTFindUniqueOrThrowArgs} args - Arguments to find a UserNFT
     * @example
     * // Get one UserNFT
     * const userNFT = await prisma.userNFT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNFTFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNFTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserNFT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNFTFindFirstArgs} args - Arguments to find a UserNFT
     * @example
     * // Get one UserNFT
     * const userNFT = await prisma.userNFT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNFTFindFirstArgs>(args?: SelectSubset<T, UserNFTFindFirstArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserNFT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNFTFindFirstOrThrowArgs} args - Arguments to find a UserNFT
     * @example
     * // Get one UserNFT
     * const userNFT = await prisma.userNFT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNFTFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNFTFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserNFTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNFTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNFTS
     * const userNFTS = await prisma.userNFT.findMany()
     * 
     * // Get first 10 UserNFTS
     * const userNFTS = await prisma.userNFT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNFTWithIdOnly = await prisma.userNFT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNFTFindManyArgs>(args?: SelectSubset<T, UserNFTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserNFT.
     * @param {UserNFTCreateArgs} args - Arguments to create a UserNFT.
     * @example
     * // Create one UserNFT
     * const UserNFT = await prisma.userNFT.create({
     *   data: {
     *     // ... data to create a UserNFT
     *   }
     * })
     * 
     */
    create<T extends UserNFTCreateArgs>(args: SelectSubset<T, UserNFTCreateArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserNFTS.
     * @param {UserNFTCreateManyArgs} args - Arguments to create many UserNFTS.
     * @example
     * // Create many UserNFTS
     * const userNFT = await prisma.userNFT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNFTCreateManyArgs>(args?: SelectSubset<T, UserNFTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNFTS and returns the data saved in the database.
     * @param {UserNFTCreateManyAndReturnArgs} args - Arguments to create many UserNFTS.
     * @example
     * // Create many UserNFTS
     * const userNFT = await prisma.userNFT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNFTS and only return the `id`
     * const userNFTWithIdOnly = await prisma.userNFT.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNFTCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNFTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserNFT.
     * @param {UserNFTDeleteArgs} args - Arguments to delete one UserNFT.
     * @example
     * // Delete one UserNFT
     * const UserNFT = await prisma.userNFT.delete({
     *   where: {
     *     // ... filter to delete one UserNFT
     *   }
     * })
     * 
     */
    delete<T extends UserNFTDeleteArgs>(args: SelectSubset<T, UserNFTDeleteArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserNFT.
     * @param {UserNFTUpdateArgs} args - Arguments to update one UserNFT.
     * @example
     * // Update one UserNFT
     * const userNFT = await prisma.userNFT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNFTUpdateArgs>(args: SelectSubset<T, UserNFTUpdateArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserNFTS.
     * @param {UserNFTDeleteManyArgs} args - Arguments to filter UserNFTS to delete.
     * @example
     * // Delete a few UserNFTS
     * const { count } = await prisma.userNFT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNFTDeleteManyArgs>(args?: SelectSubset<T, UserNFTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNFTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNFTS
     * const userNFT = await prisma.userNFT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNFTUpdateManyArgs>(args: SelectSubset<T, UserNFTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNFT.
     * @param {UserNFTUpsertArgs} args - Arguments to update or create a UserNFT.
     * @example
     * // Update or create a UserNFT
     * const userNFT = await prisma.userNFT.upsert({
     *   create: {
     *     // ... data to create a UserNFT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNFT we want to update
     *   }
     * })
     */
    upsert<T extends UserNFTUpsertArgs>(args: SelectSubset<T, UserNFTUpsertArgs<ExtArgs>>): Prisma__UserNFTClient<$Result.GetResult<Prisma.$UserNFTPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserNFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNFTCountArgs} args - Arguments to filter UserNFTS to count.
     * @example
     * // Count the number of UserNFTS
     * const count = await prisma.userNFT.count({
     *   where: {
     *     // ... the filter for the UserNFTS we want to count
     *   }
     * })
    **/
    count<T extends UserNFTCountArgs>(
      args?: Subset<T, UserNFTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNFTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNFTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNFTAggregateArgs>(args: Subset<T, UserNFTAggregateArgs>): Prisma.PrismaPromise<GetUserNFTAggregateType<T>>

    /**
     * Group by UserNFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNFTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNFTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNFTGroupByArgs['orderBy'] }
        : { orderBy?: UserNFTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNFTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNFTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNFT model
   */
  readonly fields: UserNFTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNFT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNFTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nft<T extends NFTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NFTDefaultArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNFT model
   */ 
  interface UserNFTFieldRefs {
    readonly id: FieldRef<"UserNFT", 'String'>
    readonly userId: FieldRef<"UserNFT", 'String'>
    readonly nftId: FieldRef<"UserNFT", 'String'>
    readonly createdAt: FieldRef<"UserNFT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNFT findUnique
   */
  export type UserNFTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * Filter, which UserNFT to fetch.
     */
    where: UserNFTWhereUniqueInput
  }

  /**
   * UserNFT findUniqueOrThrow
   */
  export type UserNFTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * Filter, which UserNFT to fetch.
     */
    where: UserNFTWhereUniqueInput
  }

  /**
   * UserNFT findFirst
   */
  export type UserNFTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * Filter, which UserNFT to fetch.
     */
    where?: UserNFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNFTS to fetch.
     */
    orderBy?: UserNFTOrderByWithRelationInput | UserNFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNFTS.
     */
    cursor?: UserNFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNFTS.
     */
    distinct?: UserNFTScalarFieldEnum | UserNFTScalarFieldEnum[]
  }

  /**
   * UserNFT findFirstOrThrow
   */
  export type UserNFTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * Filter, which UserNFT to fetch.
     */
    where?: UserNFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNFTS to fetch.
     */
    orderBy?: UserNFTOrderByWithRelationInput | UserNFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNFTS.
     */
    cursor?: UserNFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNFTS.
     */
    distinct?: UserNFTScalarFieldEnum | UserNFTScalarFieldEnum[]
  }

  /**
   * UserNFT findMany
   */
  export type UserNFTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * Filter, which UserNFTS to fetch.
     */
    where?: UserNFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNFTS to fetch.
     */
    orderBy?: UserNFTOrderByWithRelationInput | UserNFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNFTS.
     */
    cursor?: UserNFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNFTS.
     */
    skip?: number
    distinct?: UserNFTScalarFieldEnum | UserNFTScalarFieldEnum[]
  }

  /**
   * UserNFT create
   */
  export type UserNFTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNFT.
     */
    data: XOR<UserNFTCreateInput, UserNFTUncheckedCreateInput>
  }

  /**
   * UserNFT createMany
   */
  export type UserNFTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNFTS.
     */
    data: UserNFTCreateManyInput | UserNFTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNFT createManyAndReturn
   */
  export type UserNFTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserNFTS.
     */
    data: UserNFTCreateManyInput | UserNFTCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNFT update
   */
  export type UserNFTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNFT.
     */
    data: XOR<UserNFTUpdateInput, UserNFTUncheckedUpdateInput>
    /**
     * Choose, which UserNFT to update.
     */
    where: UserNFTWhereUniqueInput
  }

  /**
   * UserNFT updateMany
   */
  export type UserNFTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNFTS.
     */
    data: XOR<UserNFTUpdateManyMutationInput, UserNFTUncheckedUpdateManyInput>
    /**
     * Filter which UserNFTS to update
     */
    where?: UserNFTWhereInput
  }

  /**
   * UserNFT upsert
   */
  export type UserNFTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNFT to update in case it exists.
     */
    where: UserNFTWhereUniqueInput
    /**
     * In case the UserNFT found by the `where` argument doesn't exist, create a new UserNFT with this data.
     */
    create: XOR<UserNFTCreateInput, UserNFTUncheckedCreateInput>
    /**
     * In case the UserNFT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNFTUpdateInput, UserNFTUncheckedUpdateInput>
  }

  /**
   * UserNFT delete
   */
  export type UserNFTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
    /**
     * Filter which UserNFT to delete.
     */
    where: UserNFTWhereUniqueInput
  }

  /**
   * UserNFT deleteMany
   */
  export type UserNFTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNFTS to delete
     */
    where?: UserNFTWhereInput
  }

  /**
   * UserNFT without action
   */
  export type UserNFTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNFT
     */
    select?: UserNFTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNFTInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    desc: string | null
    description: string | null
    category: string | null
    points: number | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    desc: string | null
    description: string | null
    category: string | null
    points: number | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    key: number
    name: number
    desc: number
    description: number
    category: number
    points: number
    createdAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    desc?: true
    description?: true
    category?: true
    points?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    desc?: true
    description?: true
    category?: true
    points?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    desc?: true
    description?: true
    category?: true
    points?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    key: string
    name: string
    desc: string | null
    description: string | null
    category: string
    points: number
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    desc?: boolean
    description?: boolean
    category?: boolean
    points?: boolean
    createdAt?: boolean
    users?: boolean | Achievement$usersArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    desc?: boolean
    description?: boolean
    category?: boolean
    points?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    desc?: boolean
    description?: boolean
    category?: boolean
    points?: boolean
    createdAt?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Achievement$usersArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      users: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      desc: string | null
      description: string | null
      category: string
      points: number
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Achievement$usersArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly key: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly desc: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'String'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement.users
   */
  export type Achievement$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    earnedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    earnedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    earnedAt: number
    _all: number
  }


  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    earnedAt?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    earnedAt: Date
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    earnedAt?: boolean
  }

  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      earnedAt: Date
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly earnedAt: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    payload: string | null
    read: boolean | null
    isRead: boolean | null
    recipientId: string | null
    title: string | null
    priority: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    payload: string | null
    read: boolean | null
    isRead: boolean | null
    recipientId: string | null
    title: string | null
    priority: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    payload: number
    read: number
    isRead: number
    recipientId: number
    title: number
    priority: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    payload?: true
    read?: true
    isRead?: true
    recipientId?: true
    title?: true
    priority?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    payload?: true
    read?: true
    isRead?: true
    recipientId?: true
    title?: true
    priority?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    payload?: true
    read?: true
    isRead?: true
    recipientId?: true
    title?: true
    priority?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    message: string | null
    payload: string
    read: boolean
    isRead: boolean
    recipientId: string | null
    title: string | null
    priority: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    payload?: boolean
    read?: boolean
    isRead?: boolean
    recipientId?: boolean
    title?: boolean
    priority?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    payload?: boolean
    read?: boolean
    isRead?: boolean
    recipientId?: boolean
    title?: boolean
    priority?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    payload?: boolean
    read?: boolean
    isRead?: boolean
    recipientId?: boolean
    title?: boolean
    priority?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      message: string | null
      payload: string
      read: boolean
      isRead: boolean
      recipientId: string | null
      title: string | null
      priority: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly payload: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly priority: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    target: string | null
    metadata: string | null
    ts: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    target: string | null
    metadata: string | null
    ts: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    target: number
    metadata: number
    ts: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    target?: true
    metadata?: true
    ts?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    target?: true
    metadata?: true
    ts?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    target?: true
    metadata?: true
    ts?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string | null
    action: string
    target: string | null
    metadata: string
    ts: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    ts?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    ts?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    target?: boolean
    metadata?: boolean
    ts?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string | null
      action: string
      target: string | null
      metadata: string
      ts: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly target: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'String'>
    readonly ts: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    requesterId: string | null
    addresseeId: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    requesterId: string | null
    addresseeId: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    requesterId: number
    addresseeId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    requesterId: string
    addresseeId: string
    status: $Enums.FriendshipStatus
    createdAt: Date
    updatedAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    addressee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    requester?: boolean | UserDefaultArgs<ExtArgs>
    addressee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    addressee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | UserDefaultArgs<ExtArgs>
    addressee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      requester: Prisma.$UserPayload<ExtArgs>
      addressee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requesterId: string
      addresseeId: string
      status: $Enums.FriendshipStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    addressee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */ 
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly requesterId: FieldRef<"Friendship", 'String'>
    readonly addresseeId: FieldRef<"Friendship", 'String'>
    readonly status: FieldRef<"Friendship", 'FriendshipStatus'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
    readonly updatedAt: FieldRef<"Friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model DirectMessage
   */

  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    read: boolean | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    read: boolean | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    read: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type DirectMessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    read?: true
    timestamp?: true
    createdAt?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    read?: true
    timestamp?: true
    createdAt?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    read?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithAggregationInput | DirectMessageOrderByWithAggregationInput[]
    by: DirectMessageScalarFieldEnum[] | DirectMessageScalarFieldEnum
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }

  export type DirectMessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    content: string
    read: boolean
    timestamp: Date
    createdAt: Date
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    read?: boolean
    timestamp?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    read?: boolean
    timestamp?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    read?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type DirectMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DirectMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DirectMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DirectMessage"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      content: string
      read: boolean
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["directMessage"]>
    composites: {}
  }

  type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageDefaultArgs> = $Result.GetResult<Prisma.$DirectMessagePayload, S>

  type DirectMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DirectMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DirectMessage'], meta: { name: 'DirectMessage' } }
    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirectMessageFindUniqueArgs>(args: SelectSubset<T, DirectMessageFindUniqueArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DirectMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirectMessageFindFirstArgs>(args?: SelectSubset<T, DirectMessageFindFirstArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirectMessageFindManyArgs>(args?: SelectSubset<T, DirectMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
     */
    create<T extends DirectMessageCreateArgs>(args: SelectSubset<T, DirectMessageCreateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DirectMessages.
     * @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirectMessageCreateManyArgs>(args?: SelectSubset<T, DirectMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DirectMessages and returns the data saved in the database.
     * @param {DirectMessageCreateManyAndReturnArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DirectMessages and only return the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DirectMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DirectMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
     */
    delete<T extends DirectMessageDeleteArgs>(args: SelectSubset<T, DirectMessageDeleteArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirectMessageUpdateArgs>(args: SelectSubset<T, DirectMessageUpdateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirectMessageDeleteManyArgs>(args?: SelectSubset<T, DirectMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirectMessageUpdateManyArgs>(args: SelectSubset<T, DirectMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
     */
    upsert<T extends DirectMessageUpsertArgs>(args: SelectSubset<T, DirectMessageUpsertArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DirectMessage model
   */
  readonly fields: DirectMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirectMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DirectMessage model
   */ 
  interface DirectMessageFieldRefs {
    readonly id: FieldRef<"DirectMessage", 'String'>
    readonly senderId: FieldRef<"DirectMessage", 'String'>
    readonly receiverId: FieldRef<"DirectMessage", 'String'>
    readonly content: FieldRef<"DirectMessage", 'String'>
    readonly read: FieldRef<"DirectMessage", 'Boolean'>
    readonly timestamp: FieldRef<"DirectMessage", 'DateTime'>
    readonly createdAt: FieldRef<"DirectMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DirectMessage findUnique
   */
  export type DirectMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findFirst
   */
  export type DirectMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }

  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DirectMessage createManyAndReturn
   */
  export type DirectMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
  }

  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }

  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
  }

  /**
   * DirectMessage without action
   */
  export type DirectMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
  }


  /**
   * Model ActivityEvent
   */

  export type AggregateActivityEvent = {
    _count: ActivityEventCountAggregateOutputType | null
    _min: ActivityEventMinAggregateOutputType | null
    _max: ActivityEventMaxAggregateOutputType | null
  }

  export type ActivityEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    data: string | null
    venueId: string | null
    matchId: string | null
    tournamentId: string | null
    clanId: string | null
    metadata: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    data: string | null
    venueId: string | null
    matchId: string | null
    tournamentId: string | null
    clanId: string | null
    metadata: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityEventCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    data: number
    venueId: number
    matchId: number
    tournamentId: number
    clanId: number
    metadata: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityEventMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    data?: true
    venueId?: true
    matchId?: true
    tournamentId?: true
    clanId?: true
    metadata?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityEventMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    data?: true
    venueId?: true
    matchId?: true
    tournamentId?: true
    clanId?: true
    metadata?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityEventCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    data?: true
    venueId?: true
    matchId?: true
    tournamentId?: true
    clanId?: true
    metadata?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityEvent to aggregate.
     */
    where?: ActivityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityEvents to fetch.
     */
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityEvents
    **/
    _count?: true | ActivityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityEventMaxAggregateInputType
  }

  export type GetActivityEventAggregateType<T extends ActivityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityEvent[P]>
      : GetScalarType<T[P], AggregateActivityEvent[P]>
  }




  export type ActivityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityEventWhereInput
    orderBy?: ActivityEventOrderByWithAggregationInput | ActivityEventOrderByWithAggregationInput[]
    by: ActivityEventScalarFieldEnum[] | ActivityEventScalarFieldEnum
    having?: ActivityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityEventCountAggregateInputType | true
    _min?: ActivityEventMinAggregateInputType
    _max?: ActivityEventMaxAggregateInputType
  }

  export type ActivityEventGroupByOutputType = {
    id: string
    userId: string
    type: string
    message: string | null
    data: string
    venueId: string | null
    matchId: string | null
    tournamentId: string | null
    clanId: string | null
    metadata: string | null
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: ActivityEventCountAggregateOutputType | null
    _min: ActivityEventMinAggregateOutputType | null
    _max: ActivityEventMaxAggregateOutputType | null
  }

  type GetActivityEventGroupByPayload<T extends ActivityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityEventGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityEventGroupByOutputType[P]>
        }
      >
    >


  export type ActivityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    venueId?: boolean
    matchId?: boolean
    tournamentId?: boolean
    clanId?: boolean
    metadata?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ActivityEvent$userArgs<ExtArgs>
    venue?: boolean | ActivityEvent$venueArgs<ExtArgs>
    match?: boolean | ActivityEvent$matchArgs<ExtArgs>
    tournament?: boolean | ActivityEvent$tournamentArgs<ExtArgs>
    clan?: boolean | ActivityEvent$clanArgs<ExtArgs>
  }, ExtArgs["result"]["activityEvent"]>

  export type ActivityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    venueId?: boolean
    matchId?: boolean
    tournamentId?: boolean
    clanId?: boolean
    metadata?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ActivityEvent$userArgs<ExtArgs>
    venue?: boolean | ActivityEvent$venueArgs<ExtArgs>
    match?: boolean | ActivityEvent$matchArgs<ExtArgs>
    tournament?: boolean | ActivityEvent$tournamentArgs<ExtArgs>
    clan?: boolean | ActivityEvent$clanArgs<ExtArgs>
  }, ExtArgs["result"]["activityEvent"]>

  export type ActivityEventSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    venueId?: boolean
    matchId?: boolean
    tournamentId?: boolean
    clanId?: boolean
    metadata?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityEvent$userArgs<ExtArgs>
    venue?: boolean | ActivityEvent$venueArgs<ExtArgs>
    match?: boolean | ActivityEvent$matchArgs<ExtArgs>
    tournament?: boolean | ActivityEvent$tournamentArgs<ExtArgs>
    clan?: boolean | ActivityEvent$clanArgs<ExtArgs>
  }
  export type ActivityEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityEvent$userArgs<ExtArgs>
    venue?: boolean | ActivityEvent$venueArgs<ExtArgs>
    match?: boolean | ActivityEvent$matchArgs<ExtArgs>
    tournament?: boolean | ActivityEvent$tournamentArgs<ExtArgs>
    clan?: boolean | ActivityEvent$clanArgs<ExtArgs>
  }

  export type $ActivityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      venue: Prisma.$VenuePayload<ExtArgs> | null
      match: Prisma.$MatchPayload<ExtArgs> | null
      tournament: Prisma.$TournamentPayload<ExtArgs> | null
      clan: Prisma.$ClanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      message: string | null
      data: string
      venueId: string | null
      matchId: string | null
      tournamentId: string | null
      clanId: string | null
      metadata: string | null
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activityEvent"]>
    composites: {}
  }

  type ActivityEventGetPayload<S extends boolean | null | undefined | ActivityEventDefaultArgs> = $Result.GetResult<Prisma.$ActivityEventPayload, S>

  type ActivityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityEventCountAggregateInputType | true
    }

  export interface ActivityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityEvent'], meta: { name: 'ActivityEvent' } }
    /**
     * Find zero or one ActivityEvent that matches the filter.
     * @param {ActivityEventFindUniqueArgs} args - Arguments to find a ActivityEvent
     * @example
     * // Get one ActivityEvent
     * const activityEvent = await prisma.activityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityEventFindUniqueArgs>(args: SelectSubset<T, ActivityEventFindUniqueArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityEventFindUniqueOrThrowArgs} args - Arguments to find a ActivityEvent
     * @example
     * // Get one ActivityEvent
     * const activityEvent = await prisma.activityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityEventFindFirstArgs} args - Arguments to find a ActivityEvent
     * @example
     * // Get one ActivityEvent
     * const activityEvent = await prisma.activityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityEventFindFirstArgs>(args?: SelectSubset<T, ActivityEventFindFirstArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityEventFindFirstOrThrowArgs} args - Arguments to find a ActivityEvent
     * @example
     * // Get one ActivityEvent
     * const activityEvent = await prisma.activityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityEvents
     * const activityEvents = await prisma.activityEvent.findMany()
     * 
     * // Get first 10 ActivityEvents
     * const activityEvents = await prisma.activityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityEventWithIdOnly = await prisma.activityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityEventFindManyArgs>(args?: SelectSubset<T, ActivityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityEvent.
     * @param {ActivityEventCreateArgs} args - Arguments to create a ActivityEvent.
     * @example
     * // Create one ActivityEvent
     * const ActivityEvent = await prisma.activityEvent.create({
     *   data: {
     *     // ... data to create a ActivityEvent
     *   }
     * })
     * 
     */
    create<T extends ActivityEventCreateArgs>(args: SelectSubset<T, ActivityEventCreateArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityEvents.
     * @param {ActivityEventCreateManyArgs} args - Arguments to create many ActivityEvents.
     * @example
     * // Create many ActivityEvents
     * const activityEvent = await prisma.activityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityEventCreateManyArgs>(args?: SelectSubset<T, ActivityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityEvents and returns the data saved in the database.
     * @param {ActivityEventCreateManyAndReturnArgs} args - Arguments to create many ActivityEvents.
     * @example
     * // Create many ActivityEvents
     * const activityEvent = await prisma.activityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityEvents and only return the `id`
     * const activityEventWithIdOnly = await prisma.activityEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityEvent.
     * @param {ActivityEventDeleteArgs} args - Arguments to delete one ActivityEvent.
     * @example
     * // Delete one ActivityEvent
     * const ActivityEvent = await prisma.activityEvent.delete({
     *   where: {
     *     // ... filter to delete one ActivityEvent
     *   }
     * })
     * 
     */
    delete<T extends ActivityEventDeleteArgs>(args: SelectSubset<T, ActivityEventDeleteArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityEvent.
     * @param {ActivityEventUpdateArgs} args - Arguments to update one ActivityEvent.
     * @example
     * // Update one ActivityEvent
     * const activityEvent = await prisma.activityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityEventUpdateArgs>(args: SelectSubset<T, ActivityEventUpdateArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityEvents.
     * @param {ActivityEventDeleteManyArgs} args - Arguments to filter ActivityEvents to delete.
     * @example
     * // Delete a few ActivityEvents
     * const { count } = await prisma.activityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityEventDeleteManyArgs>(args?: SelectSubset<T, ActivityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityEvents
     * const activityEvent = await prisma.activityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityEventUpdateManyArgs>(args: SelectSubset<T, ActivityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityEvent.
     * @param {ActivityEventUpsertArgs} args - Arguments to update or create a ActivityEvent.
     * @example
     * // Update or create a ActivityEvent
     * const activityEvent = await prisma.activityEvent.upsert({
     *   create: {
     *     // ... data to create a ActivityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityEvent we want to update
     *   }
     * })
     */
    upsert<T extends ActivityEventUpsertArgs>(args: SelectSubset<T, ActivityEventUpsertArgs<ExtArgs>>): Prisma__ActivityEventClient<$Result.GetResult<Prisma.$ActivityEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityEventCountArgs} args - Arguments to filter ActivityEvents to count.
     * @example
     * // Count the number of ActivityEvents
     * const count = await prisma.activityEvent.count({
     *   where: {
     *     // ... the filter for the ActivityEvents we want to count
     *   }
     * })
    **/
    count<T extends ActivityEventCountArgs>(
      args?: Subset<T, ActivityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityEventAggregateArgs>(args: Subset<T, ActivityEventAggregateArgs>): Prisma.PrismaPromise<GetActivityEventAggregateType<T>>

    /**
     * Group by ActivityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityEventGroupByArgs['orderBy'] }
        : { orderBy?: ActivityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityEvent model
   */
  readonly fields: ActivityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ActivityEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    venue<T extends ActivityEvent$venueArgs<ExtArgs> = {}>(args?: Subset<T, ActivityEvent$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    match<T extends ActivityEvent$matchArgs<ExtArgs> = {}>(args?: Subset<T, ActivityEvent$matchArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tournament<T extends ActivityEvent$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, ActivityEvent$tournamentArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    clan<T extends ActivityEvent$clanArgs<ExtArgs> = {}>(args?: Subset<T, ActivityEvent$clanArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityEvent model
   */ 
  interface ActivityEventFieldRefs {
    readonly id: FieldRef<"ActivityEvent", 'String'>
    readonly userId: FieldRef<"ActivityEvent", 'String'>
    readonly type: FieldRef<"ActivityEvent", 'String'>
    readonly message: FieldRef<"ActivityEvent", 'String'>
    readonly data: FieldRef<"ActivityEvent", 'String'>
    readonly venueId: FieldRef<"ActivityEvent", 'String'>
    readonly matchId: FieldRef<"ActivityEvent", 'String'>
    readonly tournamentId: FieldRef<"ActivityEvent", 'String'>
    readonly clanId: FieldRef<"ActivityEvent", 'String'>
    readonly metadata: FieldRef<"ActivityEvent", 'String'>
    readonly isPublic: FieldRef<"ActivityEvent", 'Boolean'>
    readonly createdAt: FieldRef<"ActivityEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"ActivityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityEvent findUnique
   */
  export type ActivityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * Filter, which ActivityEvent to fetch.
     */
    where: ActivityEventWhereUniqueInput
  }

  /**
   * ActivityEvent findUniqueOrThrow
   */
  export type ActivityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * Filter, which ActivityEvent to fetch.
     */
    where: ActivityEventWhereUniqueInput
  }

  /**
   * ActivityEvent findFirst
   */
  export type ActivityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * Filter, which ActivityEvent to fetch.
     */
    where?: ActivityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityEvents to fetch.
     */
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityEvents.
     */
    cursor?: ActivityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityEvents.
     */
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * ActivityEvent findFirstOrThrow
   */
  export type ActivityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * Filter, which ActivityEvent to fetch.
     */
    where?: ActivityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityEvents to fetch.
     */
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityEvents.
     */
    cursor?: ActivityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityEvents.
     */
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * ActivityEvent findMany
   */
  export type ActivityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * Filter, which ActivityEvents to fetch.
     */
    where?: ActivityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityEvents to fetch.
     */
    orderBy?: ActivityEventOrderByWithRelationInput | ActivityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityEvents.
     */
    cursor?: ActivityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityEvents.
     */
    skip?: number
    distinct?: ActivityEventScalarFieldEnum | ActivityEventScalarFieldEnum[]
  }

  /**
   * ActivityEvent create
   */
  export type ActivityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityEvent.
     */
    data: XOR<ActivityEventCreateInput, ActivityEventUncheckedCreateInput>
  }

  /**
   * ActivityEvent createMany
   */
  export type ActivityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityEvents.
     */
    data: ActivityEventCreateManyInput | ActivityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityEvent createManyAndReturn
   */
  export type ActivityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityEvents.
     */
    data: ActivityEventCreateManyInput | ActivityEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityEvent update
   */
  export type ActivityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityEvent.
     */
    data: XOR<ActivityEventUpdateInput, ActivityEventUncheckedUpdateInput>
    /**
     * Choose, which ActivityEvent to update.
     */
    where: ActivityEventWhereUniqueInput
  }

  /**
   * ActivityEvent updateMany
   */
  export type ActivityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityEvents.
     */
    data: XOR<ActivityEventUpdateManyMutationInput, ActivityEventUncheckedUpdateManyInput>
    /**
     * Filter which ActivityEvents to update
     */
    where?: ActivityEventWhereInput
  }

  /**
   * ActivityEvent upsert
   */
  export type ActivityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityEvent to update in case it exists.
     */
    where: ActivityEventWhereUniqueInput
    /**
     * In case the ActivityEvent found by the `where` argument doesn't exist, create a new ActivityEvent with this data.
     */
    create: XOR<ActivityEventCreateInput, ActivityEventUncheckedCreateInput>
    /**
     * In case the ActivityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityEventUpdateInput, ActivityEventUncheckedUpdateInput>
  }

  /**
   * ActivityEvent delete
   */
  export type ActivityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
    /**
     * Filter which ActivityEvent to delete.
     */
    where: ActivityEventWhereUniqueInput
  }

  /**
   * ActivityEvent deleteMany
   */
  export type ActivityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityEvents to delete
     */
    where?: ActivityEventWhereInput
  }

  /**
   * ActivityEvent.user
   */
  export type ActivityEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityEvent.venue
   */
  export type ActivityEvent$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * ActivityEvent.match
   */
  export type ActivityEvent$matchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
  }

  /**
   * ActivityEvent.tournament
   */
  export type ActivityEvent$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
  }

  /**
   * ActivityEvent.clan
   */
  export type ActivityEvent$clanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    where?: ClanWhereInput
  }

  /**
   * ActivityEvent without action
   */
  export type ActivityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityEvent
     */
    select?: ActivityEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityEventInclude<ExtArgs> | null
  }


  /**
   * Model VenueQuest
   */

  export type AggregateVenueQuest = {
    _count: VenueQuestCountAggregateOutputType | null
    _avg: VenueQuestAvgAggregateOutputType | null
    _sum: VenueQuestSumAggregateOutputType | null
    _min: VenueQuestMinAggregateOutputType | null
    _max: VenueQuestMaxAggregateOutputType | null
  }

  export type VenueQuestAvgAggregateOutputType = {
    rewardDojoCoins: number | null
  }

  export type VenueQuestSumAggregateOutputType = {
    rewardDojoCoins: number | null
  }

  export type VenueQuestMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    title: string | null
    description: string | null
    reward: string | null
    rewardDojoCoins: number | null
    active: boolean | null
    isActive: boolean | null
    requirements: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueQuestMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    title: string | null
    description: string | null
    reward: string | null
    rewardDojoCoins: number | null
    active: boolean | null
    isActive: boolean | null
    requirements: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueQuestCountAggregateOutputType = {
    id: number
    venueId: number
    title: number
    description: number
    reward: number
    rewardDojoCoins: number
    active: number
    isActive: number
    requirements: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenueQuestAvgAggregateInputType = {
    rewardDojoCoins?: true
  }

  export type VenueQuestSumAggregateInputType = {
    rewardDojoCoins?: true
  }

  export type VenueQuestMinAggregateInputType = {
    id?: true
    venueId?: true
    title?: true
    description?: true
    reward?: true
    rewardDojoCoins?: true
    active?: true
    isActive?: true
    requirements?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueQuestMaxAggregateInputType = {
    id?: true
    venueId?: true
    title?: true
    description?: true
    reward?: true
    rewardDojoCoins?: true
    active?: true
    isActive?: true
    requirements?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueQuestCountAggregateInputType = {
    id?: true
    venueId?: true
    title?: true
    description?: true
    reward?: true
    rewardDojoCoins?: true
    active?: true
    isActive?: true
    requirements?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenueQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueQuest to aggregate.
     */
    where?: VenueQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueQuests to fetch.
     */
    orderBy?: VenueQuestOrderByWithRelationInput | VenueQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VenueQuests
    **/
    _count?: true | VenueQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueQuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueQuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueQuestMaxAggregateInputType
  }

  export type GetVenueQuestAggregateType<T extends VenueQuestAggregateArgs> = {
        [P in keyof T & keyof AggregateVenueQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenueQuest[P]>
      : GetScalarType<T[P], AggregateVenueQuest[P]>
  }




  export type VenueQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueQuestWhereInput
    orderBy?: VenueQuestOrderByWithAggregationInput | VenueQuestOrderByWithAggregationInput[]
    by: VenueQuestScalarFieldEnum[] | VenueQuestScalarFieldEnum
    having?: VenueQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueQuestCountAggregateInputType | true
    _avg?: VenueQuestAvgAggregateInputType
    _sum?: VenueQuestSumAggregateInputType
    _min?: VenueQuestMinAggregateInputType
    _max?: VenueQuestMaxAggregateInputType
  }

  export type VenueQuestGroupByOutputType = {
    id: string
    venueId: string
    title: string
    description: string
    reward: string
    rewardDojoCoins: number
    active: boolean
    isActive: boolean
    requirements: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: VenueQuestCountAggregateOutputType | null
    _avg: VenueQuestAvgAggregateOutputType | null
    _sum: VenueQuestSumAggregateOutputType | null
    _min: VenueQuestMinAggregateOutputType | null
    _max: VenueQuestMaxAggregateOutputType | null
  }

  type GetVenueQuestGroupByPayload<T extends VenueQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueQuestGroupByOutputType[P]>
            : GetScalarType<T[P], VenueQuestGroupByOutputType[P]>
        }
      >
    >


  export type VenueQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    rewardDojoCoins?: boolean
    active?: boolean
    isActive?: boolean
    requirements?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueQuest"]>

  export type VenueQuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    rewardDojoCoins?: boolean
    active?: boolean
    isActive?: boolean
    requirements?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueQuest"]>

  export type VenueQuestSelectScalar = {
    id?: boolean
    venueId?: boolean
    title?: boolean
    description?: boolean
    reward?: boolean
    rewardDojoCoins?: boolean
    active?: boolean
    isActive?: boolean
    requirements?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenueQuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type VenueQuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $VenueQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VenueQuest"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      title: string
      description: string
      reward: string
      rewardDojoCoins: number
      active: boolean
      isActive: boolean
      requirements: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venueQuest"]>
    composites: {}
  }

  type VenueQuestGetPayload<S extends boolean | null | undefined | VenueQuestDefaultArgs> = $Result.GetResult<Prisma.$VenueQuestPayload, S>

  type VenueQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VenueQuestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VenueQuestCountAggregateInputType | true
    }

  export interface VenueQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VenueQuest'], meta: { name: 'VenueQuest' } }
    /**
     * Find zero or one VenueQuest that matches the filter.
     * @param {VenueQuestFindUniqueArgs} args - Arguments to find a VenueQuest
     * @example
     * // Get one VenueQuest
     * const venueQuest = await prisma.venueQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueQuestFindUniqueArgs>(args: SelectSubset<T, VenueQuestFindUniqueArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VenueQuest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VenueQuestFindUniqueOrThrowArgs} args - Arguments to find a VenueQuest
     * @example
     * // Get one VenueQuest
     * const venueQuest = await prisma.venueQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueQuestFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueQuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VenueQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueQuestFindFirstArgs} args - Arguments to find a VenueQuest
     * @example
     * // Get one VenueQuest
     * const venueQuest = await prisma.venueQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueQuestFindFirstArgs>(args?: SelectSubset<T, VenueQuestFindFirstArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VenueQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueQuestFindFirstOrThrowArgs} args - Arguments to find a VenueQuest
     * @example
     * // Get one VenueQuest
     * const venueQuest = await prisma.venueQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueQuestFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueQuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VenueQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueQuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VenueQuests
     * const venueQuests = await prisma.venueQuest.findMany()
     * 
     * // Get first 10 VenueQuests
     * const venueQuests = await prisma.venueQuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueQuestWithIdOnly = await prisma.venueQuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueQuestFindManyArgs>(args?: SelectSubset<T, VenueQuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VenueQuest.
     * @param {VenueQuestCreateArgs} args - Arguments to create a VenueQuest.
     * @example
     * // Create one VenueQuest
     * const VenueQuest = await prisma.venueQuest.create({
     *   data: {
     *     // ... data to create a VenueQuest
     *   }
     * })
     * 
     */
    create<T extends VenueQuestCreateArgs>(args: SelectSubset<T, VenueQuestCreateArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VenueQuests.
     * @param {VenueQuestCreateManyArgs} args - Arguments to create many VenueQuests.
     * @example
     * // Create many VenueQuests
     * const venueQuest = await prisma.venueQuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueQuestCreateManyArgs>(args?: SelectSubset<T, VenueQuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VenueQuests and returns the data saved in the database.
     * @param {VenueQuestCreateManyAndReturnArgs} args - Arguments to create many VenueQuests.
     * @example
     * // Create many VenueQuests
     * const venueQuest = await prisma.venueQuest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VenueQuests and only return the `id`
     * const venueQuestWithIdOnly = await prisma.venueQuest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueQuestCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueQuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VenueQuest.
     * @param {VenueQuestDeleteArgs} args - Arguments to delete one VenueQuest.
     * @example
     * // Delete one VenueQuest
     * const VenueQuest = await prisma.venueQuest.delete({
     *   where: {
     *     // ... filter to delete one VenueQuest
     *   }
     * })
     * 
     */
    delete<T extends VenueQuestDeleteArgs>(args: SelectSubset<T, VenueQuestDeleteArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VenueQuest.
     * @param {VenueQuestUpdateArgs} args - Arguments to update one VenueQuest.
     * @example
     * // Update one VenueQuest
     * const venueQuest = await prisma.venueQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueQuestUpdateArgs>(args: SelectSubset<T, VenueQuestUpdateArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VenueQuests.
     * @param {VenueQuestDeleteManyArgs} args - Arguments to filter VenueQuests to delete.
     * @example
     * // Delete a few VenueQuests
     * const { count } = await prisma.venueQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueQuestDeleteManyArgs>(args?: SelectSubset<T, VenueQuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VenueQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VenueQuests
     * const venueQuest = await prisma.venueQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueQuestUpdateManyArgs>(args: SelectSubset<T, VenueQuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VenueQuest.
     * @param {VenueQuestUpsertArgs} args - Arguments to update or create a VenueQuest.
     * @example
     * // Update or create a VenueQuest
     * const venueQuest = await prisma.venueQuest.upsert({
     *   create: {
     *     // ... data to create a VenueQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VenueQuest we want to update
     *   }
     * })
     */
    upsert<T extends VenueQuestUpsertArgs>(args: SelectSubset<T, VenueQuestUpsertArgs<ExtArgs>>): Prisma__VenueQuestClient<$Result.GetResult<Prisma.$VenueQuestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VenueQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueQuestCountArgs} args - Arguments to filter VenueQuests to count.
     * @example
     * // Count the number of VenueQuests
     * const count = await prisma.venueQuest.count({
     *   where: {
     *     // ... the filter for the VenueQuests we want to count
     *   }
     * })
    **/
    count<T extends VenueQuestCountArgs>(
      args?: Subset<T, VenueQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VenueQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueQuestAggregateArgs>(args: Subset<T, VenueQuestAggregateArgs>): Prisma.PrismaPromise<GetVenueQuestAggregateType<T>>

    /**
     * Group by VenueQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueQuestGroupByArgs['orderBy'] }
        : { orderBy?: VenueQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VenueQuest model
   */
  readonly fields: VenueQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VenueQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VenueQuest model
   */ 
  interface VenueQuestFieldRefs {
    readonly id: FieldRef<"VenueQuest", 'String'>
    readonly venueId: FieldRef<"VenueQuest", 'String'>
    readonly title: FieldRef<"VenueQuest", 'String'>
    readonly description: FieldRef<"VenueQuest", 'String'>
    readonly reward: FieldRef<"VenueQuest", 'String'>
    readonly rewardDojoCoins: FieldRef<"VenueQuest", 'Int'>
    readonly active: FieldRef<"VenueQuest", 'Boolean'>
    readonly isActive: FieldRef<"VenueQuest", 'Boolean'>
    readonly requirements: FieldRef<"VenueQuest", 'String'>
    readonly type: FieldRef<"VenueQuest", 'String'>
    readonly createdAt: FieldRef<"VenueQuest", 'DateTime'>
    readonly updatedAt: FieldRef<"VenueQuest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VenueQuest findUnique
   */
  export type VenueQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * Filter, which VenueQuest to fetch.
     */
    where: VenueQuestWhereUniqueInput
  }

  /**
   * VenueQuest findUniqueOrThrow
   */
  export type VenueQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * Filter, which VenueQuest to fetch.
     */
    where: VenueQuestWhereUniqueInput
  }

  /**
   * VenueQuest findFirst
   */
  export type VenueQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * Filter, which VenueQuest to fetch.
     */
    where?: VenueQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueQuests to fetch.
     */
    orderBy?: VenueQuestOrderByWithRelationInput | VenueQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueQuests.
     */
    cursor?: VenueQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueQuests.
     */
    distinct?: VenueQuestScalarFieldEnum | VenueQuestScalarFieldEnum[]
  }

  /**
   * VenueQuest findFirstOrThrow
   */
  export type VenueQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * Filter, which VenueQuest to fetch.
     */
    where?: VenueQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueQuests to fetch.
     */
    orderBy?: VenueQuestOrderByWithRelationInput | VenueQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueQuests.
     */
    cursor?: VenueQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueQuests.
     */
    distinct?: VenueQuestScalarFieldEnum | VenueQuestScalarFieldEnum[]
  }

  /**
   * VenueQuest findMany
   */
  export type VenueQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * Filter, which VenueQuests to fetch.
     */
    where?: VenueQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueQuests to fetch.
     */
    orderBy?: VenueQuestOrderByWithRelationInput | VenueQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VenueQuests.
     */
    cursor?: VenueQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueQuests.
     */
    skip?: number
    distinct?: VenueQuestScalarFieldEnum | VenueQuestScalarFieldEnum[]
  }

  /**
   * VenueQuest create
   */
  export type VenueQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * The data needed to create a VenueQuest.
     */
    data: XOR<VenueQuestCreateInput, VenueQuestUncheckedCreateInput>
  }

  /**
   * VenueQuest createMany
   */
  export type VenueQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VenueQuests.
     */
    data: VenueQuestCreateManyInput | VenueQuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VenueQuest createManyAndReturn
   */
  export type VenueQuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VenueQuests.
     */
    data: VenueQuestCreateManyInput | VenueQuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VenueQuest update
   */
  export type VenueQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * The data needed to update a VenueQuest.
     */
    data: XOR<VenueQuestUpdateInput, VenueQuestUncheckedUpdateInput>
    /**
     * Choose, which VenueQuest to update.
     */
    where: VenueQuestWhereUniqueInput
  }

  /**
   * VenueQuest updateMany
   */
  export type VenueQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VenueQuests.
     */
    data: XOR<VenueQuestUpdateManyMutationInput, VenueQuestUncheckedUpdateManyInput>
    /**
     * Filter which VenueQuests to update
     */
    where?: VenueQuestWhereInput
  }

  /**
   * VenueQuest upsert
   */
  export type VenueQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * The filter to search for the VenueQuest to update in case it exists.
     */
    where: VenueQuestWhereUniqueInput
    /**
     * In case the VenueQuest found by the `where` argument doesn't exist, create a new VenueQuest with this data.
     */
    create: XOR<VenueQuestCreateInput, VenueQuestUncheckedCreateInput>
    /**
     * In case the VenueQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueQuestUpdateInput, VenueQuestUncheckedUpdateInput>
  }

  /**
   * VenueQuest delete
   */
  export type VenueQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
    /**
     * Filter which VenueQuest to delete.
     */
    where: VenueQuestWhereUniqueInput
  }

  /**
   * VenueQuest deleteMany
   */
  export type VenueQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueQuests to delete
     */
    where?: VenueQuestWhereInput
  }

  /**
   * VenueQuest without action
   */
  export type VenueQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueQuest
     */
    select?: VenueQuestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueQuestInclude<ExtArgs> | null
  }


  /**
   * Model GameSession
   */

  export type AggregateGameSession = {
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  export type GameSessionAvgAggregateOutputType = {
    duration: number | null
    totalShots: number | null
    totalFouls: number | null
    totalFrames: number | null
    frameCount: number | null
    shotCount: number | null
    foulCount: number | null
  }

  export type GameSessionSumAggregateOutputType = {
    duration: number | null
    totalShots: number | null
    totalFouls: number | null
    totalFrames: number | null
    frameCount: number | null
    shotCount: number | null
    foulCount: number | null
  }

  export type GameSessionMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    gameId: string | null
    venueId: string | null
    status: string | null
    gameType: string | null
    rules: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    playerIds: string | null
    currentPlayerId: string | null
    ballStates: string | null
    fouls: string | null
    score: string | null
    events: string | null
    totalShots: number | null
    totalFouls: number | null
    totalFrames: number | null
    lastUpdated: Date | null
    winnerId: string | null
    frameCount: number | null
    shotCount: number | null
    foulCount: number | null
    shots: string | null
    statistics: string | null
    aiCommentary: string | null
    matchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameSessionMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    gameId: string | null
    venueId: string | null
    status: string | null
    gameType: string | null
    rules: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    playerIds: string | null
    currentPlayerId: string | null
    ballStates: string | null
    fouls: string | null
    score: string | null
    events: string | null
    totalShots: number | null
    totalFouls: number | null
    totalFrames: number | null
    lastUpdated: Date | null
    winnerId: string | null
    frameCount: number | null
    shotCount: number | null
    foulCount: number | null
    shots: string | null
    statistics: string | null
    aiCommentary: string | null
    matchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameSessionCountAggregateOutputType = {
    id: number
    playerId: number
    gameId: number
    venueId: number
    status: number
    gameType: number
    rules: number
    startTime: number
    endTime: number
    duration: number
    playerIds: number
    currentPlayerId: number
    ballStates: number
    fouls: number
    score: number
    events: number
    totalShots: number
    totalFouls: number
    totalFrames: number
    lastUpdated: number
    winnerId: number
    data: number
    frameCount: number
    shotCount: number
    foulCount: number
    shots: number
    statistics: number
    aiCommentary: number
    matchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameSessionAvgAggregateInputType = {
    duration?: true
    totalShots?: true
    totalFouls?: true
    totalFrames?: true
    frameCount?: true
    shotCount?: true
    foulCount?: true
  }

  export type GameSessionSumAggregateInputType = {
    duration?: true
    totalShots?: true
    totalFouls?: true
    totalFrames?: true
    frameCount?: true
    shotCount?: true
    foulCount?: true
  }

  export type GameSessionMinAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    venueId?: true
    status?: true
    gameType?: true
    rules?: true
    startTime?: true
    endTime?: true
    duration?: true
    playerIds?: true
    currentPlayerId?: true
    ballStates?: true
    fouls?: true
    score?: true
    events?: true
    totalShots?: true
    totalFouls?: true
    totalFrames?: true
    lastUpdated?: true
    winnerId?: true
    frameCount?: true
    shotCount?: true
    foulCount?: true
    shots?: true
    statistics?: true
    aiCommentary?: true
    matchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameSessionMaxAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    venueId?: true
    status?: true
    gameType?: true
    rules?: true
    startTime?: true
    endTime?: true
    duration?: true
    playerIds?: true
    currentPlayerId?: true
    ballStates?: true
    fouls?: true
    score?: true
    events?: true
    totalShots?: true
    totalFouls?: true
    totalFrames?: true
    lastUpdated?: true
    winnerId?: true
    frameCount?: true
    shotCount?: true
    foulCount?: true
    shots?: true
    statistics?: true
    aiCommentary?: true
    matchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameSessionCountAggregateInputType = {
    id?: true
    playerId?: true
    gameId?: true
    venueId?: true
    status?: true
    gameType?: true
    rules?: true
    startTime?: true
    endTime?: true
    duration?: true
    playerIds?: true
    currentPlayerId?: true
    ballStates?: true
    fouls?: true
    score?: true
    events?: true
    totalShots?: true
    totalFouls?: true
    totalFrames?: true
    lastUpdated?: true
    winnerId?: true
    data?: true
    frameCount?: true
    shotCount?: true
    foulCount?: true
    shots?: true
    statistics?: true
    aiCommentary?: true
    matchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSession to aggregate.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameSessions
    **/
    _count?: true | GameSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameSessionMaxAggregateInputType
  }

  export type GetGameSessionAggregateType<T extends GameSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGameSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameSession[P]>
      : GetScalarType<T[P], AggregateGameSession[P]>
  }




  export type GameSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithAggregationInput | GameSessionOrderByWithAggregationInput[]
    by: GameSessionScalarFieldEnum[] | GameSessionScalarFieldEnum
    having?: GameSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameSessionCountAggregateInputType | true
    _avg?: GameSessionAvgAggregateInputType
    _sum?: GameSessionSumAggregateInputType
    _min?: GameSessionMinAggregateInputType
    _max?: GameSessionMaxAggregateInputType
  }

  export type GameSessionGroupByOutputType = {
    id: string
    playerId: string
    gameId: string | null
    venueId: string | null
    status: string
    gameType: string | null
    rules: string
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    playerIds: string
    currentPlayerId: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots: number
    totalFouls: number
    totalFrames: number
    lastUpdated: Date | null
    winnerId: string | null
    data: JsonValue
    frameCount: number
    shotCount: number
    foulCount: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  type GetGameSessionGroupByPayload<T extends GameSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
            : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
        }
      >
    >


  export type GameSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    gameId?: boolean
    venueId?: boolean
    status?: boolean
    gameType?: boolean
    rules?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    playerIds?: boolean
    currentPlayerId?: boolean
    ballStates?: boolean
    fouls?: boolean
    score?: boolean
    events?: boolean
    totalShots?: boolean
    totalFouls?: boolean
    totalFrames?: boolean
    lastUpdated?: boolean
    winnerId?: boolean
    data?: boolean
    frameCount?: boolean
    shotCount?: boolean
    foulCount?: boolean
    shots?: boolean
    statistics?: boolean
    aiCommentary?: boolean
    matchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | GameSession$venueArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    gameId?: boolean
    venueId?: boolean
    status?: boolean
    gameType?: boolean
    rules?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    playerIds?: boolean
    currentPlayerId?: boolean
    ballStates?: boolean
    fouls?: boolean
    score?: boolean
    events?: boolean
    totalShots?: boolean
    totalFouls?: boolean
    totalFrames?: boolean
    lastUpdated?: boolean
    winnerId?: boolean
    data?: boolean
    frameCount?: boolean
    shotCount?: boolean
    foulCount?: boolean
    shots?: boolean
    statistics?: boolean
    aiCommentary?: boolean
    matchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | GameSession$venueArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectScalar = {
    id?: boolean
    playerId?: boolean
    gameId?: boolean
    venueId?: boolean
    status?: boolean
    gameType?: boolean
    rules?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    playerIds?: boolean
    currentPlayerId?: boolean
    ballStates?: boolean
    fouls?: boolean
    score?: boolean
    events?: boolean
    totalShots?: boolean
    totalFouls?: boolean
    totalFrames?: boolean
    lastUpdated?: boolean
    winnerId?: boolean
    data?: boolean
    frameCount?: boolean
    shotCount?: boolean
    foulCount?: boolean
    shots?: boolean
    statistics?: boolean
    aiCommentary?: boolean
    matchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | GameSession$venueArgs<ExtArgs>
  }
  export type GameSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | GameSession$venueArgs<ExtArgs>
  }

  export type $GameSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameSession"
    objects: {
      player: Prisma.$UserPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      gameId: string | null
      venueId: string | null
      status: string
      gameType: string | null
      rules: string
      startTime: Date | null
      endTime: Date | null
      duration: number | null
      playerIds: string
      currentPlayerId: string | null
      ballStates: string
      fouls: string
      score: string
      events: string
      totalShots: number
      totalFouls: number
      totalFrames: number
      lastUpdated: Date | null
      winnerId: string | null
      data: Prisma.JsonValue
      frameCount: number
      shotCount: number
      foulCount: number
      shots: string
      statistics: string
      aiCommentary: string
      matchId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameSession"]>
    composites: {}
  }

  type GameSessionGetPayload<S extends boolean | null | undefined | GameSessionDefaultArgs> = $Result.GetResult<Prisma.$GameSessionPayload, S>

  type GameSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameSessionCountAggregateInputType | true
    }

  export interface GameSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameSession'], meta: { name: 'GameSession' } }
    /**
     * Find zero or one GameSession that matches the filter.
     * @param {GameSessionFindUniqueArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameSessionFindUniqueArgs>(args: SelectSubset<T, GameSessionFindUniqueArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameSessionFindUniqueOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GameSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameSessionFindFirstArgs>(args?: SelectSubset<T, GameSessionFindFirstArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GameSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameSessions
     * const gameSessions = await prisma.gameSession.findMany()
     * 
     * // Get first 10 GameSessions
     * const gameSessions = await prisma.gameSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameSessionFindManyArgs>(args?: SelectSubset<T, GameSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameSession.
     * @param {GameSessionCreateArgs} args - Arguments to create a GameSession.
     * @example
     * // Create one GameSession
     * const GameSession = await prisma.gameSession.create({
     *   data: {
     *     // ... data to create a GameSession
     *   }
     * })
     * 
     */
    create<T extends GameSessionCreateArgs>(args: SelectSubset<T, GameSessionCreateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameSessions.
     * @param {GameSessionCreateManyArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameSessionCreateManyArgs>(args?: SelectSubset<T, GameSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameSessions and returns the data saved in the database.
     * @param {GameSessionCreateManyAndReturnArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameSessions and only return the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GameSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GameSession.
     * @param {GameSessionDeleteArgs} args - Arguments to delete one GameSession.
     * @example
     * // Delete one GameSession
     * const GameSession = await prisma.gameSession.delete({
     *   where: {
     *     // ... filter to delete one GameSession
     *   }
     * })
     * 
     */
    delete<T extends GameSessionDeleteArgs>(args: SelectSubset<T, GameSessionDeleteArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameSession.
     * @param {GameSessionUpdateArgs} args - Arguments to update one GameSession.
     * @example
     * // Update one GameSession
     * const gameSession = await prisma.gameSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameSessionUpdateArgs>(args: SelectSubset<T, GameSessionUpdateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameSessions.
     * @param {GameSessionDeleteManyArgs} args - Arguments to filter GameSessions to delete.
     * @example
     * // Delete a few GameSessions
     * const { count } = await prisma.gameSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameSessionDeleteManyArgs>(args?: SelectSubset<T, GameSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameSessions
     * const gameSession = await prisma.gameSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameSessionUpdateManyArgs>(args: SelectSubset<T, GameSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameSession.
     * @param {GameSessionUpsertArgs} args - Arguments to update or create a GameSession.
     * @example
     * // Update or create a GameSession
     * const gameSession = await prisma.gameSession.upsert({
     *   create: {
     *     // ... data to create a GameSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameSession we want to update
     *   }
     * })
     */
    upsert<T extends GameSessionUpsertArgs>(args: SelectSubset<T, GameSessionUpsertArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionCountArgs} args - Arguments to filter GameSessions to count.
     * @example
     * // Count the number of GameSessions
     * const count = await prisma.gameSession.count({
     *   where: {
     *     // ... the filter for the GameSessions we want to count
     *   }
     * })
    **/
    count<T extends GameSessionCountArgs>(
      args?: Subset<T, GameSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameSessionAggregateArgs>(args: Subset<T, GameSessionAggregateArgs>): Prisma.PrismaPromise<GetGameSessionAggregateType<T>>

    /**
     * Group by GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameSessionGroupByArgs['orderBy'] }
        : { orderBy?: GameSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameSession model
   */
  readonly fields: GameSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    venue<T extends GameSession$venueArgs<ExtArgs> = {}>(args?: Subset<T, GameSession$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameSession model
   */ 
  interface GameSessionFieldRefs {
    readonly id: FieldRef<"GameSession", 'String'>
    readonly playerId: FieldRef<"GameSession", 'String'>
    readonly gameId: FieldRef<"GameSession", 'String'>
    readonly venueId: FieldRef<"GameSession", 'String'>
    readonly status: FieldRef<"GameSession", 'String'>
    readonly gameType: FieldRef<"GameSession", 'String'>
    readonly rules: FieldRef<"GameSession", 'String'>
    readonly startTime: FieldRef<"GameSession", 'DateTime'>
    readonly endTime: FieldRef<"GameSession", 'DateTime'>
    readonly duration: FieldRef<"GameSession", 'Int'>
    readonly playerIds: FieldRef<"GameSession", 'String'>
    readonly currentPlayerId: FieldRef<"GameSession", 'String'>
    readonly ballStates: FieldRef<"GameSession", 'String'>
    readonly fouls: FieldRef<"GameSession", 'String'>
    readonly score: FieldRef<"GameSession", 'String'>
    readonly events: FieldRef<"GameSession", 'String'>
    readonly totalShots: FieldRef<"GameSession", 'Int'>
    readonly totalFouls: FieldRef<"GameSession", 'Int'>
    readonly totalFrames: FieldRef<"GameSession", 'Int'>
    readonly lastUpdated: FieldRef<"GameSession", 'DateTime'>
    readonly winnerId: FieldRef<"GameSession", 'String'>
    readonly data: FieldRef<"GameSession", 'Json'>
    readonly frameCount: FieldRef<"GameSession", 'Int'>
    readonly shotCount: FieldRef<"GameSession", 'Int'>
    readonly foulCount: FieldRef<"GameSession", 'Int'>
    readonly shots: FieldRef<"GameSession", 'String'>
    readonly statistics: FieldRef<"GameSession", 'String'>
    readonly aiCommentary: FieldRef<"GameSession", 'String'>
    readonly matchId: FieldRef<"GameSession", 'String'>
    readonly createdAt: FieldRef<"GameSession", 'DateTime'>
    readonly updatedAt: FieldRef<"GameSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameSession findUnique
   */
  export type GameSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findUniqueOrThrow
   */
  export type GameSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findFirst
   */
  export type GameSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findFirstOrThrow
   */
  export type GameSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findMany
   */
  export type GameSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSessions to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession create
   */
  export type GameSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GameSession.
     */
    data: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
  }

  /**
   * GameSession createMany
   */
  export type GameSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameSession createManyAndReturn
   */
  export type GameSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameSession update
   */
  export type GameSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GameSession.
     */
    data: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
    /**
     * Choose, which GameSession to update.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession updateMany
   */
  export type GameSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameSessions.
     */
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyInput>
    /**
     * Filter which GameSessions to update
     */
    where?: GameSessionWhereInput
  }

  /**
   * GameSession upsert
   */
  export type GameSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GameSession to update in case it exists.
     */
    where: GameSessionWhereUniqueInput
    /**
     * In case the GameSession found by the `where` argument doesn't exist, create a new GameSession with this data.
     */
    create: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
    /**
     * In case the GameSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
  }

  /**
   * GameSession delete
   */
  export type GameSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter which GameSession to delete.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession deleteMany
   */
  export type GameSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSessions to delete
     */
    where?: GameSessionWhereInput
  }

  /**
   * GameSession.venue
   */
  export type GameSession$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * GameSession without action
   */
  export type GameSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceItem
   */

  export type AggregateMarketplaceItem = {
    _count: MarketplaceItemCountAggregateOutputType | null
    _avg: MarketplaceItemAvgAggregateOutputType | null
    _sum: MarketplaceItemSumAggregateOutputType | null
    _min: MarketplaceItemMinAggregateOutputType | null
    _max: MarketplaceItemMaxAggregateOutputType | null
  }

  export type MarketplaceItemAvgAggregateOutputType = {
    price: number | null
  }

  export type MarketplaceItemSumAggregateOutputType = {
    price: number | null
  }

  export type MarketplaceItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    category: string | null
    imageUrl: string | null
    available: boolean | null
    communityItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    category: string | null
    imageUrl: string | null
    available: boolean | null
    communityItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    category: number
    imageUrl: number
    available: number
    communityItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketplaceItemAvgAggregateInputType = {
    price?: true
  }

  export type MarketplaceItemSumAggregateInputType = {
    price?: true
  }

  export type MarketplaceItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    category?: true
    imageUrl?: true
    available?: true
    communityItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    category?: true
    imageUrl?: true
    available?: true
    communityItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    category?: true
    imageUrl?: true
    available?: true
    communityItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketplaceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceItem to aggregate.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceItems
    **/
    _count?: true | MarketplaceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceItemMaxAggregateInputType
  }

  export type GetMarketplaceItemAggregateType<T extends MarketplaceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceItem[P]>
      : GetScalarType<T[P], AggregateMarketplaceItem[P]>
  }




  export type MarketplaceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceItemWhereInput
    orderBy?: MarketplaceItemOrderByWithAggregationInput | MarketplaceItemOrderByWithAggregationInput[]
    by: MarketplaceItemScalarFieldEnum[] | MarketplaceItemScalarFieldEnum
    having?: MarketplaceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceItemCountAggregateInputType | true
    _avg?: MarketplaceItemAvgAggregateInputType
    _sum?: MarketplaceItemSumAggregateInputType
    _min?: MarketplaceItemMinAggregateInputType
    _max?: MarketplaceItemMaxAggregateInputType
  }

  export type MarketplaceItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    category: string
    imageUrl: string | null
    available: boolean
    communityItemId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarketplaceItemCountAggregateOutputType | null
    _avg: MarketplaceItemAvgAggregateOutputType | null
    _sum: MarketplaceItemSumAggregateOutputType | null
    _min: MarketplaceItemMinAggregateOutputType | null
    _max: MarketplaceItemMaxAggregateOutputType | null
  }

  type GetMarketplaceItemGroupByPayload<T extends MarketplaceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceItemGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceItemGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    available?: boolean
    communityItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItems?: boolean | MarketplaceItem$inventoryItemsArgs<ExtArgs>
    communityItem?: boolean | MarketplaceItem$communityItemArgs<ExtArgs>
    _count?: boolean | MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceItem"]>

  export type MarketplaceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    available?: boolean
    communityItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketplaceItem"]>

  export type MarketplaceItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    category?: boolean
    imageUrl?: boolean
    available?: boolean
    communityItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketplaceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | MarketplaceItem$inventoryItemsArgs<ExtArgs>
    communityItem?: boolean | MarketplaceItem$communityItemArgs<ExtArgs>
    _count?: boolean | MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketplaceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarketplaceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceItem"
    objects: {
      inventoryItems: Prisma.$UserInventoryItemPayload<ExtArgs>[]
      communityItem: Prisma.$CommunityCosmeticItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      category: string
      imageUrl: string | null
      available: boolean
      communityItemId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketplaceItem"]>
    composites: {}
  }

  type MarketplaceItemGetPayload<S extends boolean | null | undefined | MarketplaceItemDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceItemPayload, S>

  type MarketplaceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketplaceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketplaceItemCountAggregateInputType | true
    }

  export interface MarketplaceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceItem'], meta: { name: 'MarketplaceItem' } }
    /**
     * Find zero or one MarketplaceItem that matches the filter.
     * @param {MarketplaceItemFindUniqueArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceItemFindUniqueArgs>(args: SelectSubset<T, MarketplaceItemFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketplaceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketplaceItemFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketplaceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindFirstArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceItemFindFirstArgs>(args?: SelectSubset<T, MarketplaceItemFindFirstArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketplaceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindFirstOrThrowArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketplaceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceItems
     * const marketplaceItems = await prisma.marketplaceItem.findMany()
     * 
     * // Get first 10 MarketplaceItems
     * const marketplaceItems = await prisma.marketplaceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceItemWithIdOnly = await prisma.marketplaceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceItemFindManyArgs>(args?: SelectSubset<T, MarketplaceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketplaceItem.
     * @param {MarketplaceItemCreateArgs} args - Arguments to create a MarketplaceItem.
     * @example
     * // Create one MarketplaceItem
     * const MarketplaceItem = await prisma.marketplaceItem.create({
     *   data: {
     *     // ... data to create a MarketplaceItem
     *   }
     * })
     * 
     */
    create<T extends MarketplaceItemCreateArgs>(args: SelectSubset<T, MarketplaceItemCreateArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketplaceItems.
     * @param {MarketplaceItemCreateManyArgs} args - Arguments to create many MarketplaceItems.
     * @example
     * // Create many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceItemCreateManyArgs>(args?: SelectSubset<T, MarketplaceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceItems and returns the data saved in the database.
     * @param {MarketplaceItemCreateManyAndReturnArgs} args - Arguments to create many MarketplaceItems.
     * @example
     * // Create many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceItems and only return the `id`
     * const marketplaceItemWithIdOnly = await prisma.marketplaceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketplaceItem.
     * @param {MarketplaceItemDeleteArgs} args - Arguments to delete one MarketplaceItem.
     * @example
     * // Delete one MarketplaceItem
     * const MarketplaceItem = await prisma.marketplaceItem.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceItem
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceItemDeleteArgs>(args: SelectSubset<T, MarketplaceItemDeleteArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketplaceItem.
     * @param {MarketplaceItemUpdateArgs} args - Arguments to update one MarketplaceItem.
     * @example
     * // Update one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceItemUpdateArgs>(args: SelectSubset<T, MarketplaceItemUpdateArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketplaceItems.
     * @param {MarketplaceItemDeleteManyArgs} args - Arguments to filter MarketplaceItems to delete.
     * @example
     * // Delete a few MarketplaceItems
     * const { count } = await prisma.marketplaceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceItemDeleteManyArgs>(args?: SelectSubset<T, MarketplaceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceItemUpdateManyArgs>(args: SelectSubset<T, MarketplaceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketplaceItem.
     * @param {MarketplaceItemUpsertArgs} args - Arguments to update or create a MarketplaceItem.
     * @example
     * // Update or create a MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.upsert({
     *   create: {
     *     // ... data to create a MarketplaceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceItem we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceItemUpsertArgs>(args: SelectSubset<T, MarketplaceItemUpsertArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketplaceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemCountArgs} args - Arguments to filter MarketplaceItems to count.
     * @example
     * // Count the number of MarketplaceItems
     * const count = await prisma.marketplaceItem.count({
     *   where: {
     *     // ... the filter for the MarketplaceItems we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceItemCountArgs>(
      args?: Subset<T, MarketplaceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceItemAggregateArgs>(args: Subset<T, MarketplaceItemAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceItemAggregateType<T>>

    /**
     * Group by MarketplaceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceItemGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceItem model
   */
  readonly fields: MarketplaceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends MarketplaceItem$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceItem$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    communityItem<T extends MarketplaceItem$communityItemArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceItem$communityItemArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceItem model
   */ 
  interface MarketplaceItemFieldRefs {
    readonly id: FieldRef<"MarketplaceItem", 'String'>
    readonly name: FieldRef<"MarketplaceItem", 'String'>
    readonly description: FieldRef<"MarketplaceItem", 'String'>
    readonly price: FieldRef<"MarketplaceItem", 'Int'>
    readonly category: FieldRef<"MarketplaceItem", 'String'>
    readonly imageUrl: FieldRef<"MarketplaceItem", 'String'>
    readonly available: FieldRef<"MarketplaceItem", 'Boolean'>
    readonly communityItemId: FieldRef<"MarketplaceItem", 'String'>
    readonly createdAt: FieldRef<"MarketplaceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketplaceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceItem findUnique
   */
  export type MarketplaceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem findUniqueOrThrow
   */
  export type MarketplaceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem findFirst
   */
  export type MarketplaceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceItems.
     */
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem findFirstOrThrow
   */
  export type MarketplaceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceItems.
     */
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem findMany
   */
  export type MarketplaceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItems to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem create
   */
  export type MarketplaceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceItem.
     */
    data: XOR<MarketplaceItemCreateInput, MarketplaceItemUncheckedCreateInput>
  }

  /**
   * MarketplaceItem createMany
   */
  export type MarketplaceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceItems.
     */
    data: MarketplaceItemCreateManyInput | MarketplaceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceItem createManyAndReturn
   */
  export type MarketplaceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketplaceItems.
     */
    data: MarketplaceItemCreateManyInput | MarketplaceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceItem update
   */
  export type MarketplaceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceItem.
     */
    data: XOR<MarketplaceItemUpdateInput, MarketplaceItemUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceItem to update.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem updateMany
   */
  export type MarketplaceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceItems.
     */
    data: XOR<MarketplaceItemUpdateManyMutationInput, MarketplaceItemUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceItems to update
     */
    where?: MarketplaceItemWhereInput
  }

  /**
   * MarketplaceItem upsert
   */
  export type MarketplaceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceItem to update in case it exists.
     */
    where: MarketplaceItemWhereUniqueInput
    /**
     * In case the MarketplaceItem found by the `where` argument doesn't exist, create a new MarketplaceItem with this data.
     */
    create: XOR<MarketplaceItemCreateInput, MarketplaceItemUncheckedCreateInput>
    /**
     * In case the MarketplaceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceItemUpdateInput, MarketplaceItemUncheckedUpdateInput>
  }

  /**
   * MarketplaceItem delete
   */
  export type MarketplaceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceItem to delete.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem deleteMany
   */
  export type MarketplaceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceItems to delete
     */
    where?: MarketplaceItemWhereInput
  }

  /**
   * MarketplaceItem.inventoryItems
   */
  export type MarketplaceItem$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    where?: UserInventoryItemWhereInput
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    cursor?: UserInventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem.communityItem
   */
  export type MarketplaceItem$communityItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    where?: CommunityCosmeticItemWhereInput
  }

  /**
   * MarketplaceItem without action
   */
  export type MarketplaceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
  }


  /**
   * Model CommunityCosmeticItem
   */

  export type AggregateCommunityCosmeticItem = {
    _count: CommunityCosmeticItemCountAggregateOutputType | null
    _avg: CommunityCosmeticItemAvgAggregateOutputType | null
    _sum: CommunityCosmeticItemSumAggregateOutputType | null
    _min: CommunityCosmeticItemMinAggregateOutputType | null
    _max: CommunityCosmeticItemMaxAggregateOutputType | null
  }

  export type CommunityCosmeticItemAvgAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type CommunityCosmeticItemSumAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type CommunityCosmeticItemMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    category: $Enums.CosmeticCategory | null
    designFileUrl: string | null
    previewImageUrl: string | null
    status: $Enums.SubmissionStatus | null
    rejectionReason: string | null
    approvedItemId: string | null
    reviewerId: string | null
    reviewedAt: Date | null
    metadata: string | null
    tags: string | null
    likes: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityCosmeticItemMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    category: $Enums.CosmeticCategory | null
    designFileUrl: string | null
    previewImageUrl: string | null
    status: $Enums.SubmissionStatus | null
    rejectionReason: string | null
    approvedItemId: string | null
    reviewerId: string | null
    reviewedAt: Date | null
    metadata: string | null
    tags: string | null
    likes: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityCosmeticItemCountAggregateOutputType = {
    id: number
    creatorId: number
    title: number
    description: number
    category: number
    designFileUrl: number
    previewImageUrl: number
    status: number
    rejectionReason: number
    approvedItemId: number
    reviewerId: number
    reviewedAt: number
    metadata: number
    tags: number
    likes: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityCosmeticItemAvgAggregateInputType = {
    likes?: true
    views?: true
  }

  export type CommunityCosmeticItemSumAggregateInputType = {
    likes?: true
    views?: true
  }

  export type CommunityCosmeticItemMinAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    category?: true
    designFileUrl?: true
    previewImageUrl?: true
    status?: true
    rejectionReason?: true
    approvedItemId?: true
    reviewerId?: true
    reviewedAt?: true
    metadata?: true
    tags?: true
    likes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityCosmeticItemMaxAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    category?: true
    designFileUrl?: true
    previewImageUrl?: true
    status?: true
    rejectionReason?: true
    approvedItemId?: true
    reviewerId?: true
    reviewedAt?: true
    metadata?: true
    tags?: true
    likes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityCosmeticItemCountAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    category?: true
    designFileUrl?: true
    previewImageUrl?: true
    status?: true
    rejectionReason?: true
    approvedItemId?: true
    reviewerId?: true
    reviewedAt?: true
    metadata?: true
    tags?: true
    likes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityCosmeticItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityCosmeticItem to aggregate.
     */
    where?: CommunityCosmeticItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityCosmeticItems to fetch.
     */
    orderBy?: CommunityCosmeticItemOrderByWithRelationInput | CommunityCosmeticItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityCosmeticItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityCosmeticItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityCosmeticItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityCosmeticItems
    **/
    _count?: true | CommunityCosmeticItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityCosmeticItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityCosmeticItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityCosmeticItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityCosmeticItemMaxAggregateInputType
  }

  export type GetCommunityCosmeticItemAggregateType<T extends CommunityCosmeticItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityCosmeticItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityCosmeticItem[P]>
      : GetScalarType<T[P], AggregateCommunityCosmeticItem[P]>
  }




  export type CommunityCosmeticItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityCosmeticItemWhereInput
    orderBy?: CommunityCosmeticItemOrderByWithAggregationInput | CommunityCosmeticItemOrderByWithAggregationInput[]
    by: CommunityCosmeticItemScalarFieldEnum[] | CommunityCosmeticItemScalarFieldEnum
    having?: CommunityCosmeticItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCosmeticItemCountAggregateInputType | true
    _avg?: CommunityCosmeticItemAvgAggregateInputType
    _sum?: CommunityCosmeticItemSumAggregateInputType
    _min?: CommunityCosmeticItemMinAggregateInputType
    _max?: CommunityCosmeticItemMaxAggregateInputType
  }

  export type CommunityCosmeticItemGroupByOutputType = {
    id: string
    creatorId: string
    title: string
    description: string | null
    category: $Enums.CosmeticCategory
    designFileUrl: string | null
    previewImageUrl: string | null
    status: $Enums.SubmissionStatus
    rejectionReason: string | null
    approvedItemId: string | null
    reviewerId: string | null
    reviewedAt: Date | null
    metadata: string
    tags: string
    likes: number
    views: number
    createdAt: Date
    updatedAt: Date
    _count: CommunityCosmeticItemCountAggregateOutputType | null
    _avg: CommunityCosmeticItemAvgAggregateOutputType | null
    _sum: CommunityCosmeticItemSumAggregateOutputType | null
    _min: CommunityCosmeticItemMinAggregateOutputType | null
    _max: CommunityCosmeticItemMaxAggregateOutputType | null
  }

  type GetCommunityCosmeticItemGroupByPayload<T extends CommunityCosmeticItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityCosmeticItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityCosmeticItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityCosmeticItemGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityCosmeticItemGroupByOutputType[P]>
        }
      >
    >


  export type CommunityCosmeticItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    designFileUrl?: boolean
    previewImageUrl?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedItemId?: boolean
    reviewerId?: boolean
    reviewedAt?: boolean
    metadata?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approvedItem?: boolean | CommunityCosmeticItem$approvedItemArgs<ExtArgs>
    reviewer?: boolean | CommunityCosmeticItem$reviewerArgs<ExtArgs>
    likedBy?: boolean | CommunityCosmeticItem$likedByArgs<ExtArgs>
    _count?: boolean | CommunityCosmeticItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityCosmeticItem"]>

  export type CommunityCosmeticItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    designFileUrl?: boolean
    previewImageUrl?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedItemId?: boolean
    reviewerId?: boolean
    reviewedAt?: boolean
    metadata?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approvedItem?: boolean | CommunityCosmeticItem$approvedItemArgs<ExtArgs>
    reviewer?: boolean | CommunityCosmeticItem$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["communityCosmeticItem"]>

  export type CommunityCosmeticItemSelectScalar = {
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    designFileUrl?: boolean
    previewImageUrl?: boolean
    status?: boolean
    rejectionReason?: boolean
    approvedItemId?: boolean
    reviewerId?: boolean
    reviewedAt?: boolean
    metadata?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityCosmeticItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approvedItem?: boolean | CommunityCosmeticItem$approvedItemArgs<ExtArgs>
    reviewer?: boolean | CommunityCosmeticItem$reviewerArgs<ExtArgs>
    likedBy?: boolean | CommunityCosmeticItem$likedByArgs<ExtArgs>
    _count?: boolean | CommunityCosmeticItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityCosmeticItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approvedItem?: boolean | CommunityCosmeticItem$approvedItemArgs<ExtArgs>
    reviewer?: boolean | CommunityCosmeticItem$reviewerArgs<ExtArgs>
  }

  export type $CommunityCosmeticItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityCosmeticItem"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      approvedItem: Prisma.$MarketplaceItemPayload<ExtArgs> | null
      reviewer: Prisma.$UserPayload<ExtArgs> | null
      likedBy: Prisma.$CosmeticItemLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      title: string
      description: string | null
      category: $Enums.CosmeticCategory
      designFileUrl: string | null
      previewImageUrl: string | null
      status: $Enums.SubmissionStatus
      rejectionReason: string | null
      approvedItemId: string | null
      reviewerId: string | null
      reviewedAt: Date | null
      metadata: string
      tags: string
      likes: number
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityCosmeticItem"]>
    composites: {}
  }

  type CommunityCosmeticItemGetPayload<S extends boolean | null | undefined | CommunityCosmeticItemDefaultArgs> = $Result.GetResult<Prisma.$CommunityCosmeticItemPayload, S>

  type CommunityCosmeticItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityCosmeticItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityCosmeticItemCountAggregateInputType | true
    }

  export interface CommunityCosmeticItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityCosmeticItem'], meta: { name: 'CommunityCosmeticItem' } }
    /**
     * Find zero or one CommunityCosmeticItem that matches the filter.
     * @param {CommunityCosmeticItemFindUniqueArgs} args - Arguments to find a CommunityCosmeticItem
     * @example
     * // Get one CommunityCosmeticItem
     * const communityCosmeticItem = await prisma.communityCosmeticItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityCosmeticItemFindUniqueArgs>(args: SelectSubset<T, CommunityCosmeticItemFindUniqueArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommunityCosmeticItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunityCosmeticItemFindUniqueOrThrowArgs} args - Arguments to find a CommunityCosmeticItem
     * @example
     * // Get one CommunityCosmeticItem
     * const communityCosmeticItem = await prisma.communityCosmeticItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityCosmeticItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityCosmeticItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommunityCosmeticItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCosmeticItemFindFirstArgs} args - Arguments to find a CommunityCosmeticItem
     * @example
     * // Get one CommunityCosmeticItem
     * const communityCosmeticItem = await prisma.communityCosmeticItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityCosmeticItemFindFirstArgs>(args?: SelectSubset<T, CommunityCosmeticItemFindFirstArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommunityCosmeticItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCosmeticItemFindFirstOrThrowArgs} args - Arguments to find a CommunityCosmeticItem
     * @example
     * // Get one CommunityCosmeticItem
     * const communityCosmeticItem = await prisma.communityCosmeticItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityCosmeticItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityCosmeticItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommunityCosmeticItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCosmeticItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityCosmeticItems
     * const communityCosmeticItems = await prisma.communityCosmeticItem.findMany()
     * 
     * // Get first 10 CommunityCosmeticItems
     * const communityCosmeticItems = await prisma.communityCosmeticItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityCosmeticItemWithIdOnly = await prisma.communityCosmeticItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityCosmeticItemFindManyArgs>(args?: SelectSubset<T, CommunityCosmeticItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommunityCosmeticItem.
     * @param {CommunityCosmeticItemCreateArgs} args - Arguments to create a CommunityCosmeticItem.
     * @example
     * // Create one CommunityCosmeticItem
     * const CommunityCosmeticItem = await prisma.communityCosmeticItem.create({
     *   data: {
     *     // ... data to create a CommunityCosmeticItem
     *   }
     * })
     * 
     */
    create<T extends CommunityCosmeticItemCreateArgs>(args: SelectSubset<T, CommunityCosmeticItemCreateArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommunityCosmeticItems.
     * @param {CommunityCosmeticItemCreateManyArgs} args - Arguments to create many CommunityCosmeticItems.
     * @example
     * // Create many CommunityCosmeticItems
     * const communityCosmeticItem = await prisma.communityCosmeticItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityCosmeticItemCreateManyArgs>(args?: SelectSubset<T, CommunityCosmeticItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityCosmeticItems and returns the data saved in the database.
     * @param {CommunityCosmeticItemCreateManyAndReturnArgs} args - Arguments to create many CommunityCosmeticItems.
     * @example
     * // Create many CommunityCosmeticItems
     * const communityCosmeticItem = await prisma.communityCosmeticItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityCosmeticItems and only return the `id`
     * const communityCosmeticItemWithIdOnly = await prisma.communityCosmeticItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityCosmeticItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityCosmeticItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommunityCosmeticItem.
     * @param {CommunityCosmeticItemDeleteArgs} args - Arguments to delete one CommunityCosmeticItem.
     * @example
     * // Delete one CommunityCosmeticItem
     * const CommunityCosmeticItem = await prisma.communityCosmeticItem.delete({
     *   where: {
     *     // ... filter to delete one CommunityCosmeticItem
     *   }
     * })
     * 
     */
    delete<T extends CommunityCosmeticItemDeleteArgs>(args: SelectSubset<T, CommunityCosmeticItemDeleteArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommunityCosmeticItem.
     * @param {CommunityCosmeticItemUpdateArgs} args - Arguments to update one CommunityCosmeticItem.
     * @example
     * // Update one CommunityCosmeticItem
     * const communityCosmeticItem = await prisma.communityCosmeticItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityCosmeticItemUpdateArgs>(args: SelectSubset<T, CommunityCosmeticItemUpdateArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommunityCosmeticItems.
     * @param {CommunityCosmeticItemDeleteManyArgs} args - Arguments to filter CommunityCosmeticItems to delete.
     * @example
     * // Delete a few CommunityCosmeticItems
     * const { count } = await prisma.communityCosmeticItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityCosmeticItemDeleteManyArgs>(args?: SelectSubset<T, CommunityCosmeticItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityCosmeticItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCosmeticItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityCosmeticItems
     * const communityCosmeticItem = await prisma.communityCosmeticItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityCosmeticItemUpdateManyArgs>(args: SelectSubset<T, CommunityCosmeticItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityCosmeticItem.
     * @param {CommunityCosmeticItemUpsertArgs} args - Arguments to update or create a CommunityCosmeticItem.
     * @example
     * // Update or create a CommunityCosmeticItem
     * const communityCosmeticItem = await prisma.communityCosmeticItem.upsert({
     *   create: {
     *     // ... data to create a CommunityCosmeticItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityCosmeticItem we want to update
     *   }
     * })
     */
    upsert<T extends CommunityCosmeticItemUpsertArgs>(args: SelectSubset<T, CommunityCosmeticItemUpsertArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommunityCosmeticItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCosmeticItemCountArgs} args - Arguments to filter CommunityCosmeticItems to count.
     * @example
     * // Count the number of CommunityCosmeticItems
     * const count = await prisma.communityCosmeticItem.count({
     *   where: {
     *     // ... the filter for the CommunityCosmeticItems we want to count
     *   }
     * })
    **/
    count<T extends CommunityCosmeticItemCountArgs>(
      args?: Subset<T, CommunityCosmeticItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCosmeticItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityCosmeticItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCosmeticItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityCosmeticItemAggregateArgs>(args: Subset<T, CommunityCosmeticItemAggregateArgs>): Prisma.PrismaPromise<GetCommunityCosmeticItemAggregateType<T>>

    /**
     * Group by CommunityCosmeticItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCosmeticItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityCosmeticItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityCosmeticItemGroupByArgs['orderBy'] }
        : { orderBy?: CommunityCosmeticItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityCosmeticItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityCosmeticItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityCosmeticItem model
   */
  readonly fields: CommunityCosmeticItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityCosmeticItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityCosmeticItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedItem<T extends CommunityCosmeticItem$approvedItemArgs<ExtArgs> = {}>(args?: Subset<T, CommunityCosmeticItem$approvedItemArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviewer<T extends CommunityCosmeticItem$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, CommunityCosmeticItem$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    likedBy<T extends CommunityCosmeticItem$likedByArgs<ExtArgs> = {}>(args?: Subset<T, CommunityCosmeticItem$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityCosmeticItem model
   */ 
  interface CommunityCosmeticItemFieldRefs {
    readonly id: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly creatorId: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly title: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly description: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly category: FieldRef<"CommunityCosmeticItem", 'CosmeticCategory'>
    readonly designFileUrl: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly previewImageUrl: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly status: FieldRef<"CommunityCosmeticItem", 'SubmissionStatus'>
    readonly rejectionReason: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly approvedItemId: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly reviewerId: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly reviewedAt: FieldRef<"CommunityCosmeticItem", 'DateTime'>
    readonly metadata: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly tags: FieldRef<"CommunityCosmeticItem", 'String'>
    readonly likes: FieldRef<"CommunityCosmeticItem", 'Int'>
    readonly views: FieldRef<"CommunityCosmeticItem", 'Int'>
    readonly createdAt: FieldRef<"CommunityCosmeticItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityCosmeticItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityCosmeticItem findUnique
   */
  export type CommunityCosmeticItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * Filter, which CommunityCosmeticItem to fetch.
     */
    where: CommunityCosmeticItemWhereUniqueInput
  }

  /**
   * CommunityCosmeticItem findUniqueOrThrow
   */
  export type CommunityCosmeticItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * Filter, which CommunityCosmeticItem to fetch.
     */
    where: CommunityCosmeticItemWhereUniqueInput
  }

  /**
   * CommunityCosmeticItem findFirst
   */
  export type CommunityCosmeticItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * Filter, which CommunityCosmeticItem to fetch.
     */
    where?: CommunityCosmeticItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityCosmeticItems to fetch.
     */
    orderBy?: CommunityCosmeticItemOrderByWithRelationInput | CommunityCosmeticItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityCosmeticItems.
     */
    cursor?: CommunityCosmeticItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityCosmeticItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityCosmeticItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityCosmeticItems.
     */
    distinct?: CommunityCosmeticItemScalarFieldEnum | CommunityCosmeticItemScalarFieldEnum[]
  }

  /**
   * CommunityCosmeticItem findFirstOrThrow
   */
  export type CommunityCosmeticItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * Filter, which CommunityCosmeticItem to fetch.
     */
    where?: CommunityCosmeticItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityCosmeticItems to fetch.
     */
    orderBy?: CommunityCosmeticItemOrderByWithRelationInput | CommunityCosmeticItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityCosmeticItems.
     */
    cursor?: CommunityCosmeticItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityCosmeticItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityCosmeticItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityCosmeticItems.
     */
    distinct?: CommunityCosmeticItemScalarFieldEnum | CommunityCosmeticItemScalarFieldEnum[]
  }

  /**
   * CommunityCosmeticItem findMany
   */
  export type CommunityCosmeticItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * Filter, which CommunityCosmeticItems to fetch.
     */
    where?: CommunityCosmeticItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityCosmeticItems to fetch.
     */
    orderBy?: CommunityCosmeticItemOrderByWithRelationInput | CommunityCosmeticItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityCosmeticItems.
     */
    cursor?: CommunityCosmeticItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityCosmeticItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityCosmeticItems.
     */
    skip?: number
    distinct?: CommunityCosmeticItemScalarFieldEnum | CommunityCosmeticItemScalarFieldEnum[]
  }

  /**
   * CommunityCosmeticItem create
   */
  export type CommunityCosmeticItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityCosmeticItem.
     */
    data: XOR<CommunityCosmeticItemCreateInput, CommunityCosmeticItemUncheckedCreateInput>
  }

  /**
   * CommunityCosmeticItem createMany
   */
  export type CommunityCosmeticItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityCosmeticItems.
     */
    data: CommunityCosmeticItemCreateManyInput | CommunityCosmeticItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityCosmeticItem createManyAndReturn
   */
  export type CommunityCosmeticItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommunityCosmeticItems.
     */
    data: CommunityCosmeticItemCreateManyInput | CommunityCosmeticItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityCosmeticItem update
   */
  export type CommunityCosmeticItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityCosmeticItem.
     */
    data: XOR<CommunityCosmeticItemUpdateInput, CommunityCosmeticItemUncheckedUpdateInput>
    /**
     * Choose, which CommunityCosmeticItem to update.
     */
    where: CommunityCosmeticItemWhereUniqueInput
  }

  /**
   * CommunityCosmeticItem updateMany
   */
  export type CommunityCosmeticItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityCosmeticItems.
     */
    data: XOR<CommunityCosmeticItemUpdateManyMutationInput, CommunityCosmeticItemUncheckedUpdateManyInput>
    /**
     * Filter which CommunityCosmeticItems to update
     */
    where?: CommunityCosmeticItemWhereInput
  }

  /**
   * CommunityCosmeticItem upsert
   */
  export type CommunityCosmeticItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityCosmeticItem to update in case it exists.
     */
    where: CommunityCosmeticItemWhereUniqueInput
    /**
     * In case the CommunityCosmeticItem found by the `where` argument doesn't exist, create a new CommunityCosmeticItem with this data.
     */
    create: XOR<CommunityCosmeticItemCreateInput, CommunityCosmeticItemUncheckedCreateInput>
    /**
     * In case the CommunityCosmeticItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityCosmeticItemUpdateInput, CommunityCosmeticItemUncheckedUpdateInput>
  }

  /**
   * CommunityCosmeticItem delete
   */
  export type CommunityCosmeticItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
    /**
     * Filter which CommunityCosmeticItem to delete.
     */
    where: CommunityCosmeticItemWhereUniqueInput
  }

  /**
   * CommunityCosmeticItem deleteMany
   */
  export type CommunityCosmeticItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityCosmeticItems to delete
     */
    where?: CommunityCosmeticItemWhereInput
  }

  /**
   * CommunityCosmeticItem.approvedItem
   */
  export type CommunityCosmeticItem$approvedItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    where?: MarketplaceItemWhereInput
  }

  /**
   * CommunityCosmeticItem.reviewer
   */
  export type CommunityCosmeticItem$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CommunityCosmeticItem.likedBy
   */
  export type CommunityCosmeticItem$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    where?: CosmeticItemLikeWhereInput
    orderBy?: CosmeticItemLikeOrderByWithRelationInput | CosmeticItemLikeOrderByWithRelationInput[]
    cursor?: CosmeticItemLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CosmeticItemLikeScalarFieldEnum | CosmeticItemLikeScalarFieldEnum[]
  }

  /**
   * CommunityCosmeticItem without action
   */
  export type CommunityCosmeticItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCosmeticItem
     */
    select?: CommunityCosmeticItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityCosmeticItemInclude<ExtArgs> | null
  }


  /**
   * Model CosmeticItemLike
   */

  export type AggregateCosmeticItemLike = {
    _count: CosmeticItemLikeCountAggregateOutputType | null
    _min: CosmeticItemLikeMinAggregateOutputType | null
    _max: CosmeticItemLikeMaxAggregateOutputType | null
  }

  export type CosmeticItemLikeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cosmeticItemId: string | null
    createdAt: Date | null
  }

  export type CosmeticItemLikeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cosmeticItemId: string | null
    createdAt: Date | null
  }

  export type CosmeticItemLikeCountAggregateOutputType = {
    id: number
    userId: number
    cosmeticItemId: number
    createdAt: number
    _all: number
  }


  export type CosmeticItemLikeMinAggregateInputType = {
    id?: true
    userId?: true
    cosmeticItemId?: true
    createdAt?: true
  }

  export type CosmeticItemLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    cosmeticItemId?: true
    createdAt?: true
  }

  export type CosmeticItemLikeCountAggregateInputType = {
    id?: true
    userId?: true
    cosmeticItemId?: true
    createdAt?: true
    _all?: true
  }

  export type CosmeticItemLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CosmeticItemLike to aggregate.
     */
    where?: CosmeticItemLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CosmeticItemLikes to fetch.
     */
    orderBy?: CosmeticItemLikeOrderByWithRelationInput | CosmeticItemLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CosmeticItemLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CosmeticItemLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CosmeticItemLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CosmeticItemLikes
    **/
    _count?: true | CosmeticItemLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CosmeticItemLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CosmeticItemLikeMaxAggregateInputType
  }

  export type GetCosmeticItemLikeAggregateType<T extends CosmeticItemLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateCosmeticItemLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCosmeticItemLike[P]>
      : GetScalarType<T[P], AggregateCosmeticItemLike[P]>
  }




  export type CosmeticItemLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CosmeticItemLikeWhereInput
    orderBy?: CosmeticItemLikeOrderByWithAggregationInput | CosmeticItemLikeOrderByWithAggregationInput[]
    by: CosmeticItemLikeScalarFieldEnum[] | CosmeticItemLikeScalarFieldEnum
    having?: CosmeticItemLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CosmeticItemLikeCountAggregateInputType | true
    _min?: CosmeticItemLikeMinAggregateInputType
    _max?: CosmeticItemLikeMaxAggregateInputType
  }

  export type CosmeticItemLikeGroupByOutputType = {
    id: string
    userId: string
    cosmeticItemId: string
    createdAt: Date
    _count: CosmeticItemLikeCountAggregateOutputType | null
    _min: CosmeticItemLikeMinAggregateOutputType | null
    _max: CosmeticItemLikeMaxAggregateOutputType | null
  }

  type GetCosmeticItemLikeGroupByPayload<T extends CosmeticItemLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CosmeticItemLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CosmeticItemLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CosmeticItemLikeGroupByOutputType[P]>
            : GetScalarType<T[P], CosmeticItemLikeGroupByOutputType[P]>
        }
      >
    >


  export type CosmeticItemLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cosmeticItemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cosmeticItem?: boolean | CommunityCosmeticItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cosmeticItemLike"]>

  export type CosmeticItemLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cosmeticItemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cosmeticItem?: boolean | CommunityCosmeticItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cosmeticItemLike"]>

  export type CosmeticItemLikeSelectScalar = {
    id?: boolean
    userId?: boolean
    cosmeticItemId?: boolean
    createdAt?: boolean
  }

  export type CosmeticItemLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cosmeticItem?: boolean | CommunityCosmeticItemDefaultArgs<ExtArgs>
  }
  export type CosmeticItemLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cosmeticItem?: boolean | CommunityCosmeticItemDefaultArgs<ExtArgs>
  }

  export type $CosmeticItemLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CosmeticItemLike"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cosmeticItem: Prisma.$CommunityCosmeticItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cosmeticItemId: string
      createdAt: Date
    }, ExtArgs["result"]["cosmeticItemLike"]>
    composites: {}
  }

  type CosmeticItemLikeGetPayload<S extends boolean | null | undefined | CosmeticItemLikeDefaultArgs> = $Result.GetResult<Prisma.$CosmeticItemLikePayload, S>

  type CosmeticItemLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CosmeticItemLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CosmeticItemLikeCountAggregateInputType | true
    }

  export interface CosmeticItemLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CosmeticItemLike'], meta: { name: 'CosmeticItemLike' } }
    /**
     * Find zero or one CosmeticItemLike that matches the filter.
     * @param {CosmeticItemLikeFindUniqueArgs} args - Arguments to find a CosmeticItemLike
     * @example
     * // Get one CosmeticItemLike
     * const cosmeticItemLike = await prisma.cosmeticItemLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CosmeticItemLikeFindUniqueArgs>(args: SelectSubset<T, CosmeticItemLikeFindUniqueArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CosmeticItemLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CosmeticItemLikeFindUniqueOrThrowArgs} args - Arguments to find a CosmeticItemLike
     * @example
     * // Get one CosmeticItemLike
     * const cosmeticItemLike = await prisma.cosmeticItemLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CosmeticItemLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, CosmeticItemLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CosmeticItemLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CosmeticItemLikeFindFirstArgs} args - Arguments to find a CosmeticItemLike
     * @example
     * // Get one CosmeticItemLike
     * const cosmeticItemLike = await prisma.cosmeticItemLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CosmeticItemLikeFindFirstArgs>(args?: SelectSubset<T, CosmeticItemLikeFindFirstArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CosmeticItemLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CosmeticItemLikeFindFirstOrThrowArgs} args - Arguments to find a CosmeticItemLike
     * @example
     * // Get one CosmeticItemLike
     * const cosmeticItemLike = await prisma.cosmeticItemLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CosmeticItemLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, CosmeticItemLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CosmeticItemLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CosmeticItemLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CosmeticItemLikes
     * const cosmeticItemLikes = await prisma.cosmeticItemLike.findMany()
     * 
     * // Get first 10 CosmeticItemLikes
     * const cosmeticItemLikes = await prisma.cosmeticItemLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cosmeticItemLikeWithIdOnly = await prisma.cosmeticItemLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CosmeticItemLikeFindManyArgs>(args?: SelectSubset<T, CosmeticItemLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CosmeticItemLike.
     * @param {CosmeticItemLikeCreateArgs} args - Arguments to create a CosmeticItemLike.
     * @example
     * // Create one CosmeticItemLike
     * const CosmeticItemLike = await prisma.cosmeticItemLike.create({
     *   data: {
     *     // ... data to create a CosmeticItemLike
     *   }
     * })
     * 
     */
    create<T extends CosmeticItemLikeCreateArgs>(args: SelectSubset<T, CosmeticItemLikeCreateArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CosmeticItemLikes.
     * @param {CosmeticItemLikeCreateManyArgs} args - Arguments to create many CosmeticItemLikes.
     * @example
     * // Create many CosmeticItemLikes
     * const cosmeticItemLike = await prisma.cosmeticItemLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CosmeticItemLikeCreateManyArgs>(args?: SelectSubset<T, CosmeticItemLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CosmeticItemLikes and returns the data saved in the database.
     * @param {CosmeticItemLikeCreateManyAndReturnArgs} args - Arguments to create many CosmeticItemLikes.
     * @example
     * // Create many CosmeticItemLikes
     * const cosmeticItemLike = await prisma.cosmeticItemLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CosmeticItemLikes and only return the `id`
     * const cosmeticItemLikeWithIdOnly = await prisma.cosmeticItemLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CosmeticItemLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, CosmeticItemLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CosmeticItemLike.
     * @param {CosmeticItemLikeDeleteArgs} args - Arguments to delete one CosmeticItemLike.
     * @example
     * // Delete one CosmeticItemLike
     * const CosmeticItemLike = await prisma.cosmeticItemLike.delete({
     *   where: {
     *     // ... filter to delete one CosmeticItemLike
     *   }
     * })
     * 
     */
    delete<T extends CosmeticItemLikeDeleteArgs>(args: SelectSubset<T, CosmeticItemLikeDeleteArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CosmeticItemLike.
     * @param {CosmeticItemLikeUpdateArgs} args - Arguments to update one CosmeticItemLike.
     * @example
     * // Update one CosmeticItemLike
     * const cosmeticItemLike = await prisma.cosmeticItemLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CosmeticItemLikeUpdateArgs>(args: SelectSubset<T, CosmeticItemLikeUpdateArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CosmeticItemLikes.
     * @param {CosmeticItemLikeDeleteManyArgs} args - Arguments to filter CosmeticItemLikes to delete.
     * @example
     * // Delete a few CosmeticItemLikes
     * const { count } = await prisma.cosmeticItemLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CosmeticItemLikeDeleteManyArgs>(args?: SelectSubset<T, CosmeticItemLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CosmeticItemLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CosmeticItemLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CosmeticItemLikes
     * const cosmeticItemLike = await prisma.cosmeticItemLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CosmeticItemLikeUpdateManyArgs>(args: SelectSubset<T, CosmeticItemLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CosmeticItemLike.
     * @param {CosmeticItemLikeUpsertArgs} args - Arguments to update or create a CosmeticItemLike.
     * @example
     * // Update or create a CosmeticItemLike
     * const cosmeticItemLike = await prisma.cosmeticItemLike.upsert({
     *   create: {
     *     // ... data to create a CosmeticItemLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CosmeticItemLike we want to update
     *   }
     * })
     */
    upsert<T extends CosmeticItemLikeUpsertArgs>(args: SelectSubset<T, CosmeticItemLikeUpsertArgs<ExtArgs>>): Prisma__CosmeticItemLikeClient<$Result.GetResult<Prisma.$CosmeticItemLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CosmeticItemLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CosmeticItemLikeCountArgs} args - Arguments to filter CosmeticItemLikes to count.
     * @example
     * // Count the number of CosmeticItemLikes
     * const count = await prisma.cosmeticItemLike.count({
     *   where: {
     *     // ... the filter for the CosmeticItemLikes we want to count
     *   }
     * })
    **/
    count<T extends CosmeticItemLikeCountArgs>(
      args?: Subset<T, CosmeticItemLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CosmeticItemLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CosmeticItemLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CosmeticItemLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CosmeticItemLikeAggregateArgs>(args: Subset<T, CosmeticItemLikeAggregateArgs>): Prisma.PrismaPromise<GetCosmeticItemLikeAggregateType<T>>

    /**
     * Group by CosmeticItemLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CosmeticItemLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CosmeticItemLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CosmeticItemLikeGroupByArgs['orderBy'] }
        : { orderBy?: CosmeticItemLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CosmeticItemLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCosmeticItemLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CosmeticItemLike model
   */
  readonly fields: CosmeticItemLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CosmeticItemLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CosmeticItemLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cosmeticItem<T extends CommunityCosmeticItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityCosmeticItemDefaultArgs<ExtArgs>>): Prisma__CommunityCosmeticItemClient<$Result.GetResult<Prisma.$CommunityCosmeticItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CosmeticItemLike model
   */ 
  interface CosmeticItemLikeFieldRefs {
    readonly id: FieldRef<"CosmeticItemLike", 'String'>
    readonly userId: FieldRef<"CosmeticItemLike", 'String'>
    readonly cosmeticItemId: FieldRef<"CosmeticItemLike", 'String'>
    readonly createdAt: FieldRef<"CosmeticItemLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CosmeticItemLike findUnique
   */
  export type CosmeticItemLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * Filter, which CosmeticItemLike to fetch.
     */
    where: CosmeticItemLikeWhereUniqueInput
  }

  /**
   * CosmeticItemLike findUniqueOrThrow
   */
  export type CosmeticItemLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * Filter, which CosmeticItemLike to fetch.
     */
    where: CosmeticItemLikeWhereUniqueInput
  }

  /**
   * CosmeticItemLike findFirst
   */
  export type CosmeticItemLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * Filter, which CosmeticItemLike to fetch.
     */
    where?: CosmeticItemLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CosmeticItemLikes to fetch.
     */
    orderBy?: CosmeticItemLikeOrderByWithRelationInput | CosmeticItemLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CosmeticItemLikes.
     */
    cursor?: CosmeticItemLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CosmeticItemLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CosmeticItemLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CosmeticItemLikes.
     */
    distinct?: CosmeticItemLikeScalarFieldEnum | CosmeticItemLikeScalarFieldEnum[]
  }

  /**
   * CosmeticItemLike findFirstOrThrow
   */
  export type CosmeticItemLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * Filter, which CosmeticItemLike to fetch.
     */
    where?: CosmeticItemLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CosmeticItemLikes to fetch.
     */
    orderBy?: CosmeticItemLikeOrderByWithRelationInput | CosmeticItemLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CosmeticItemLikes.
     */
    cursor?: CosmeticItemLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CosmeticItemLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CosmeticItemLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CosmeticItemLikes.
     */
    distinct?: CosmeticItemLikeScalarFieldEnum | CosmeticItemLikeScalarFieldEnum[]
  }

  /**
   * CosmeticItemLike findMany
   */
  export type CosmeticItemLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * Filter, which CosmeticItemLikes to fetch.
     */
    where?: CosmeticItemLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CosmeticItemLikes to fetch.
     */
    orderBy?: CosmeticItemLikeOrderByWithRelationInput | CosmeticItemLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CosmeticItemLikes.
     */
    cursor?: CosmeticItemLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CosmeticItemLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CosmeticItemLikes.
     */
    skip?: number
    distinct?: CosmeticItemLikeScalarFieldEnum | CosmeticItemLikeScalarFieldEnum[]
  }

  /**
   * CosmeticItemLike create
   */
  export type CosmeticItemLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a CosmeticItemLike.
     */
    data: XOR<CosmeticItemLikeCreateInput, CosmeticItemLikeUncheckedCreateInput>
  }

  /**
   * CosmeticItemLike createMany
   */
  export type CosmeticItemLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CosmeticItemLikes.
     */
    data: CosmeticItemLikeCreateManyInput | CosmeticItemLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CosmeticItemLike createManyAndReturn
   */
  export type CosmeticItemLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CosmeticItemLikes.
     */
    data: CosmeticItemLikeCreateManyInput | CosmeticItemLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CosmeticItemLike update
   */
  export type CosmeticItemLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a CosmeticItemLike.
     */
    data: XOR<CosmeticItemLikeUpdateInput, CosmeticItemLikeUncheckedUpdateInput>
    /**
     * Choose, which CosmeticItemLike to update.
     */
    where: CosmeticItemLikeWhereUniqueInput
  }

  /**
   * CosmeticItemLike updateMany
   */
  export type CosmeticItemLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CosmeticItemLikes.
     */
    data: XOR<CosmeticItemLikeUpdateManyMutationInput, CosmeticItemLikeUncheckedUpdateManyInput>
    /**
     * Filter which CosmeticItemLikes to update
     */
    where?: CosmeticItemLikeWhereInput
  }

  /**
   * CosmeticItemLike upsert
   */
  export type CosmeticItemLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the CosmeticItemLike to update in case it exists.
     */
    where: CosmeticItemLikeWhereUniqueInput
    /**
     * In case the CosmeticItemLike found by the `where` argument doesn't exist, create a new CosmeticItemLike with this data.
     */
    create: XOR<CosmeticItemLikeCreateInput, CosmeticItemLikeUncheckedCreateInput>
    /**
     * In case the CosmeticItemLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CosmeticItemLikeUpdateInput, CosmeticItemLikeUncheckedUpdateInput>
  }

  /**
   * CosmeticItemLike delete
   */
  export type CosmeticItemLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
    /**
     * Filter which CosmeticItemLike to delete.
     */
    where: CosmeticItemLikeWhereUniqueInput
  }

  /**
   * CosmeticItemLike deleteMany
   */
  export type CosmeticItemLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CosmeticItemLikes to delete
     */
    where?: CosmeticItemLikeWhereInput
  }

  /**
   * CosmeticItemLike without action
   */
  export type CosmeticItemLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CosmeticItemLike
     */
    select?: CosmeticItemLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CosmeticItemLikeInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeasonMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SeasonCountAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {SeasonCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */ 
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'String'>
    readonly name: FieldRef<"Season", 'String'>
    readonly description: FieldRef<"Season", 'String'>
    readonly startDate: FieldRef<"Season", 'DateTime'>
    readonly endDate: FieldRef<"Season", 'DateTime'>
    readonly isActive: FieldRef<"Season", 'Boolean'>
    readonly createdAt: FieldRef<"Season", 'DateTime'>
    readonly updatedAt: FieldRef<"Season", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season createManyAndReturn
   */
  export type SeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
  }


  /**
   * Model ShadowRun
   */

  export type AggregateShadowRun = {
    _count: ShadowRunCountAggregateOutputType | null
    _avg: ShadowRunAvgAggregateOutputType | null
    _sum: ShadowRunSumAggregateOutputType | null
    _min: ShadowRunMinAggregateOutputType | null
    _max: ShadowRunMaxAggregateOutputType | null
  }

  export type ShadowRunAvgAggregateOutputType = {
    cost: number | null
    reward: number | null
  }

  export type ShadowRunSumAggregateOutputType = {
    cost: number | null
    reward: number | null
  }

  export type ShadowRunMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    type: string | null
    status: string | null
    cost: number | null
    reward: number | null
    completedAt: Date | null
    initiatingClanId: string | null
    targetVenueId: string | null
    outcome: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShadowRunMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    type: string | null
    status: string | null
    cost: number | null
    reward: number | null
    completedAt: Date | null
    initiatingClanId: string | null
    targetVenueId: string | null
    outcome: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShadowRunCountAggregateOutputType = {
    id: number
    playerId: number
    type: number
    status: number
    cost: number
    reward: number
    completedAt: number
    initiatingClanId: number
    targetVenueId: number
    outcome: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShadowRunAvgAggregateInputType = {
    cost?: true
    reward?: true
  }

  export type ShadowRunSumAggregateInputType = {
    cost?: true
    reward?: true
  }

  export type ShadowRunMinAggregateInputType = {
    id?: true
    playerId?: true
    type?: true
    status?: true
    cost?: true
    reward?: true
    completedAt?: true
    initiatingClanId?: true
    targetVenueId?: true
    outcome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShadowRunMaxAggregateInputType = {
    id?: true
    playerId?: true
    type?: true
    status?: true
    cost?: true
    reward?: true
    completedAt?: true
    initiatingClanId?: true
    targetVenueId?: true
    outcome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShadowRunCountAggregateInputType = {
    id?: true
    playerId?: true
    type?: true
    status?: true
    cost?: true
    reward?: true
    completedAt?: true
    initiatingClanId?: true
    targetVenueId?: true
    outcome?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShadowRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShadowRun to aggregate.
     */
    where?: ShadowRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShadowRuns to fetch.
     */
    orderBy?: ShadowRunOrderByWithRelationInput | ShadowRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShadowRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShadowRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShadowRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShadowRuns
    **/
    _count?: true | ShadowRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShadowRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShadowRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShadowRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShadowRunMaxAggregateInputType
  }

  export type GetShadowRunAggregateType<T extends ShadowRunAggregateArgs> = {
        [P in keyof T & keyof AggregateShadowRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShadowRun[P]>
      : GetScalarType<T[P], AggregateShadowRun[P]>
  }




  export type ShadowRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShadowRunWhereInput
    orderBy?: ShadowRunOrderByWithAggregationInput | ShadowRunOrderByWithAggregationInput[]
    by: ShadowRunScalarFieldEnum[] | ShadowRunScalarFieldEnum
    having?: ShadowRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShadowRunCountAggregateInputType | true
    _avg?: ShadowRunAvgAggregateInputType
    _sum?: ShadowRunSumAggregateInputType
    _min?: ShadowRunMinAggregateInputType
    _max?: ShadowRunMaxAggregateInputType
  }

  export type ShadowRunGroupByOutputType = {
    id: string
    playerId: string
    type: string
    status: string
    cost: number
    reward: number | null
    completedAt: Date | null
    initiatingClanId: string | null
    targetVenueId: string | null
    outcome: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShadowRunCountAggregateOutputType | null
    _avg: ShadowRunAvgAggregateOutputType | null
    _sum: ShadowRunSumAggregateOutputType | null
    _min: ShadowRunMinAggregateOutputType | null
    _max: ShadowRunMaxAggregateOutputType | null
  }

  type GetShadowRunGroupByPayload<T extends ShadowRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShadowRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShadowRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShadowRunGroupByOutputType[P]>
            : GetScalarType<T[P], ShadowRunGroupByOutputType[P]>
        }
      >
    >


  export type ShadowRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    type?: boolean
    status?: boolean
    cost?: boolean
    reward?: boolean
    completedAt?: boolean
    initiatingClanId?: boolean
    targetVenueId?: boolean
    outcome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | UserDefaultArgs<ExtArgs>
    initiatingClan?: boolean | ShadowRun$initiatingClanArgs<ExtArgs>
    targetVenue?: boolean | ShadowRun$targetVenueArgs<ExtArgs>
  }, ExtArgs["result"]["shadowRun"]>

  export type ShadowRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    type?: boolean
    status?: boolean
    cost?: boolean
    reward?: boolean
    completedAt?: boolean
    initiatingClanId?: boolean
    targetVenueId?: boolean
    outcome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | UserDefaultArgs<ExtArgs>
    initiatingClan?: boolean | ShadowRun$initiatingClanArgs<ExtArgs>
    targetVenue?: boolean | ShadowRun$targetVenueArgs<ExtArgs>
  }, ExtArgs["result"]["shadowRun"]>

  export type ShadowRunSelectScalar = {
    id?: boolean
    playerId?: boolean
    type?: boolean
    status?: boolean
    cost?: boolean
    reward?: boolean
    completedAt?: boolean
    initiatingClanId?: boolean
    targetVenueId?: boolean
    outcome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShadowRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | UserDefaultArgs<ExtArgs>
    initiatingClan?: boolean | ShadowRun$initiatingClanArgs<ExtArgs>
    targetVenue?: boolean | ShadowRun$targetVenueArgs<ExtArgs>
  }
  export type ShadowRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | UserDefaultArgs<ExtArgs>
    initiatingClan?: boolean | ShadowRun$initiatingClanArgs<ExtArgs>
    targetVenue?: boolean | ShadowRun$targetVenueArgs<ExtArgs>
  }

  export type $ShadowRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShadowRun"
    objects: {
      player: Prisma.$UserPayload<ExtArgs>
      initiatingClan: Prisma.$ClanPayload<ExtArgs> | null
      targetVenue: Prisma.$VenuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      type: string
      status: string
      cost: number
      reward: number | null
      completedAt: Date | null
      initiatingClanId: string | null
      targetVenueId: string | null
      outcome: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shadowRun"]>
    composites: {}
  }

  type ShadowRunGetPayload<S extends boolean | null | undefined | ShadowRunDefaultArgs> = $Result.GetResult<Prisma.$ShadowRunPayload, S>

  type ShadowRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShadowRunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShadowRunCountAggregateInputType | true
    }

  export interface ShadowRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShadowRun'], meta: { name: 'ShadowRun' } }
    /**
     * Find zero or one ShadowRun that matches the filter.
     * @param {ShadowRunFindUniqueArgs} args - Arguments to find a ShadowRun
     * @example
     * // Get one ShadowRun
     * const shadowRun = await prisma.shadowRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShadowRunFindUniqueArgs>(args: SelectSubset<T, ShadowRunFindUniqueArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShadowRun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShadowRunFindUniqueOrThrowArgs} args - Arguments to find a ShadowRun
     * @example
     * // Get one ShadowRun
     * const shadowRun = await prisma.shadowRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShadowRunFindUniqueOrThrowArgs>(args: SelectSubset<T, ShadowRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShadowRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShadowRunFindFirstArgs} args - Arguments to find a ShadowRun
     * @example
     * // Get one ShadowRun
     * const shadowRun = await prisma.shadowRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShadowRunFindFirstArgs>(args?: SelectSubset<T, ShadowRunFindFirstArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShadowRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShadowRunFindFirstOrThrowArgs} args - Arguments to find a ShadowRun
     * @example
     * // Get one ShadowRun
     * const shadowRun = await prisma.shadowRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShadowRunFindFirstOrThrowArgs>(args?: SelectSubset<T, ShadowRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShadowRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShadowRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShadowRuns
     * const shadowRuns = await prisma.shadowRun.findMany()
     * 
     * // Get first 10 ShadowRuns
     * const shadowRuns = await prisma.shadowRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shadowRunWithIdOnly = await prisma.shadowRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShadowRunFindManyArgs>(args?: SelectSubset<T, ShadowRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShadowRun.
     * @param {ShadowRunCreateArgs} args - Arguments to create a ShadowRun.
     * @example
     * // Create one ShadowRun
     * const ShadowRun = await prisma.shadowRun.create({
     *   data: {
     *     // ... data to create a ShadowRun
     *   }
     * })
     * 
     */
    create<T extends ShadowRunCreateArgs>(args: SelectSubset<T, ShadowRunCreateArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShadowRuns.
     * @param {ShadowRunCreateManyArgs} args - Arguments to create many ShadowRuns.
     * @example
     * // Create many ShadowRuns
     * const shadowRun = await prisma.shadowRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShadowRunCreateManyArgs>(args?: SelectSubset<T, ShadowRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShadowRuns and returns the data saved in the database.
     * @param {ShadowRunCreateManyAndReturnArgs} args - Arguments to create many ShadowRuns.
     * @example
     * // Create many ShadowRuns
     * const shadowRun = await prisma.shadowRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShadowRuns and only return the `id`
     * const shadowRunWithIdOnly = await prisma.shadowRun.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShadowRunCreateManyAndReturnArgs>(args?: SelectSubset<T, ShadowRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShadowRun.
     * @param {ShadowRunDeleteArgs} args - Arguments to delete one ShadowRun.
     * @example
     * // Delete one ShadowRun
     * const ShadowRun = await prisma.shadowRun.delete({
     *   where: {
     *     // ... filter to delete one ShadowRun
     *   }
     * })
     * 
     */
    delete<T extends ShadowRunDeleteArgs>(args: SelectSubset<T, ShadowRunDeleteArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShadowRun.
     * @param {ShadowRunUpdateArgs} args - Arguments to update one ShadowRun.
     * @example
     * // Update one ShadowRun
     * const shadowRun = await prisma.shadowRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShadowRunUpdateArgs>(args: SelectSubset<T, ShadowRunUpdateArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShadowRuns.
     * @param {ShadowRunDeleteManyArgs} args - Arguments to filter ShadowRuns to delete.
     * @example
     * // Delete a few ShadowRuns
     * const { count } = await prisma.shadowRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShadowRunDeleteManyArgs>(args?: SelectSubset<T, ShadowRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShadowRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShadowRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShadowRuns
     * const shadowRun = await prisma.shadowRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShadowRunUpdateManyArgs>(args: SelectSubset<T, ShadowRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShadowRun.
     * @param {ShadowRunUpsertArgs} args - Arguments to update or create a ShadowRun.
     * @example
     * // Update or create a ShadowRun
     * const shadowRun = await prisma.shadowRun.upsert({
     *   create: {
     *     // ... data to create a ShadowRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShadowRun we want to update
     *   }
     * })
     */
    upsert<T extends ShadowRunUpsertArgs>(args: SelectSubset<T, ShadowRunUpsertArgs<ExtArgs>>): Prisma__ShadowRunClient<$Result.GetResult<Prisma.$ShadowRunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShadowRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShadowRunCountArgs} args - Arguments to filter ShadowRuns to count.
     * @example
     * // Count the number of ShadowRuns
     * const count = await prisma.shadowRun.count({
     *   where: {
     *     // ... the filter for the ShadowRuns we want to count
     *   }
     * })
    **/
    count<T extends ShadowRunCountArgs>(
      args?: Subset<T, ShadowRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShadowRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShadowRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShadowRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShadowRunAggregateArgs>(args: Subset<T, ShadowRunAggregateArgs>): Prisma.PrismaPromise<GetShadowRunAggregateType<T>>

    /**
     * Group by ShadowRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShadowRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShadowRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShadowRunGroupByArgs['orderBy'] }
        : { orderBy?: ShadowRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShadowRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShadowRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShadowRun model
   */
  readonly fields: ShadowRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShadowRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShadowRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    initiatingClan<T extends ShadowRun$initiatingClanArgs<ExtArgs> = {}>(args?: Subset<T, ShadowRun$initiatingClanArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    targetVenue<T extends ShadowRun$targetVenueArgs<ExtArgs> = {}>(args?: Subset<T, ShadowRun$targetVenueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShadowRun model
   */ 
  interface ShadowRunFieldRefs {
    readonly id: FieldRef<"ShadowRun", 'String'>
    readonly playerId: FieldRef<"ShadowRun", 'String'>
    readonly type: FieldRef<"ShadowRun", 'String'>
    readonly status: FieldRef<"ShadowRun", 'String'>
    readonly cost: FieldRef<"ShadowRun", 'Int'>
    readonly reward: FieldRef<"ShadowRun", 'Int'>
    readonly completedAt: FieldRef<"ShadowRun", 'DateTime'>
    readonly initiatingClanId: FieldRef<"ShadowRun", 'String'>
    readonly targetVenueId: FieldRef<"ShadowRun", 'String'>
    readonly outcome: FieldRef<"ShadowRun", 'String'>
    readonly createdAt: FieldRef<"ShadowRun", 'DateTime'>
    readonly updatedAt: FieldRef<"ShadowRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShadowRun findUnique
   */
  export type ShadowRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * Filter, which ShadowRun to fetch.
     */
    where: ShadowRunWhereUniqueInput
  }

  /**
   * ShadowRun findUniqueOrThrow
   */
  export type ShadowRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * Filter, which ShadowRun to fetch.
     */
    where: ShadowRunWhereUniqueInput
  }

  /**
   * ShadowRun findFirst
   */
  export type ShadowRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * Filter, which ShadowRun to fetch.
     */
    where?: ShadowRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShadowRuns to fetch.
     */
    orderBy?: ShadowRunOrderByWithRelationInput | ShadowRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShadowRuns.
     */
    cursor?: ShadowRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShadowRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShadowRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShadowRuns.
     */
    distinct?: ShadowRunScalarFieldEnum | ShadowRunScalarFieldEnum[]
  }

  /**
   * ShadowRun findFirstOrThrow
   */
  export type ShadowRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * Filter, which ShadowRun to fetch.
     */
    where?: ShadowRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShadowRuns to fetch.
     */
    orderBy?: ShadowRunOrderByWithRelationInput | ShadowRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShadowRuns.
     */
    cursor?: ShadowRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShadowRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShadowRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShadowRuns.
     */
    distinct?: ShadowRunScalarFieldEnum | ShadowRunScalarFieldEnum[]
  }

  /**
   * ShadowRun findMany
   */
  export type ShadowRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * Filter, which ShadowRuns to fetch.
     */
    where?: ShadowRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShadowRuns to fetch.
     */
    orderBy?: ShadowRunOrderByWithRelationInput | ShadowRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShadowRuns.
     */
    cursor?: ShadowRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShadowRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShadowRuns.
     */
    skip?: number
    distinct?: ShadowRunScalarFieldEnum | ShadowRunScalarFieldEnum[]
  }

  /**
   * ShadowRun create
   */
  export type ShadowRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * The data needed to create a ShadowRun.
     */
    data: XOR<ShadowRunCreateInput, ShadowRunUncheckedCreateInput>
  }

  /**
   * ShadowRun createMany
   */
  export type ShadowRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShadowRuns.
     */
    data: ShadowRunCreateManyInput | ShadowRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShadowRun createManyAndReturn
   */
  export type ShadowRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShadowRuns.
     */
    data: ShadowRunCreateManyInput | ShadowRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShadowRun update
   */
  export type ShadowRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * The data needed to update a ShadowRun.
     */
    data: XOR<ShadowRunUpdateInput, ShadowRunUncheckedUpdateInput>
    /**
     * Choose, which ShadowRun to update.
     */
    where: ShadowRunWhereUniqueInput
  }

  /**
   * ShadowRun updateMany
   */
  export type ShadowRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShadowRuns.
     */
    data: XOR<ShadowRunUpdateManyMutationInput, ShadowRunUncheckedUpdateManyInput>
    /**
     * Filter which ShadowRuns to update
     */
    where?: ShadowRunWhereInput
  }

  /**
   * ShadowRun upsert
   */
  export type ShadowRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * The filter to search for the ShadowRun to update in case it exists.
     */
    where: ShadowRunWhereUniqueInput
    /**
     * In case the ShadowRun found by the `where` argument doesn't exist, create a new ShadowRun with this data.
     */
    create: XOR<ShadowRunCreateInput, ShadowRunUncheckedCreateInput>
    /**
     * In case the ShadowRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShadowRunUpdateInput, ShadowRunUncheckedUpdateInput>
  }

  /**
   * ShadowRun delete
   */
  export type ShadowRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
    /**
     * Filter which ShadowRun to delete.
     */
    where: ShadowRunWhereUniqueInput
  }

  /**
   * ShadowRun deleteMany
   */
  export type ShadowRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShadowRuns to delete
     */
    where?: ShadowRunWhereInput
  }

  /**
   * ShadowRun.initiatingClan
   */
  export type ShadowRun$initiatingClanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    where?: ClanWhereInput
  }

  /**
   * ShadowRun.targetVenue
   */
  export type ShadowRun$targetVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * ShadowRun without action
   */
  export type ShadowRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShadowRun
     */
    select?: ShadowRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShadowRunInclude<ExtArgs> | null
  }


  /**
   * Model DojoCheckIn
   */

  export type AggregateDojoCheckIn = {
    _count: DojoCheckInCountAggregateOutputType | null
    _min: DojoCheckInMinAggregateOutputType | null
    _max: DojoCheckInMaxAggregateOutputType | null
  }

  export type DojoCheckInMinAggregateOutputType = {
    id: string | null
    userId: string | null
    venueId: string | null
    createdAt: Date | null
  }

  export type DojoCheckInMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    venueId: string | null
    createdAt: Date | null
  }

  export type DojoCheckInCountAggregateOutputType = {
    id: number
    userId: number
    venueId: number
    createdAt: number
    _all: number
  }


  export type DojoCheckInMinAggregateInputType = {
    id?: true
    userId?: true
    venueId?: true
    createdAt?: true
  }

  export type DojoCheckInMaxAggregateInputType = {
    id?: true
    userId?: true
    venueId?: true
    createdAt?: true
  }

  export type DojoCheckInCountAggregateInputType = {
    id?: true
    userId?: true
    venueId?: true
    createdAt?: true
    _all?: true
  }

  export type DojoCheckInAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DojoCheckIn to aggregate.
     */
    where?: DojoCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DojoCheckIns to fetch.
     */
    orderBy?: DojoCheckInOrderByWithRelationInput | DojoCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DojoCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DojoCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DojoCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DojoCheckIns
    **/
    _count?: true | DojoCheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DojoCheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DojoCheckInMaxAggregateInputType
  }

  export type GetDojoCheckInAggregateType<T extends DojoCheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateDojoCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDojoCheckIn[P]>
      : GetScalarType<T[P], AggregateDojoCheckIn[P]>
  }




  export type DojoCheckInGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DojoCheckInWhereInput
    orderBy?: DojoCheckInOrderByWithAggregationInput | DojoCheckInOrderByWithAggregationInput[]
    by: DojoCheckInScalarFieldEnum[] | DojoCheckInScalarFieldEnum
    having?: DojoCheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DojoCheckInCountAggregateInputType | true
    _min?: DojoCheckInMinAggregateInputType
    _max?: DojoCheckInMaxAggregateInputType
  }

  export type DojoCheckInGroupByOutputType = {
    id: string
    userId: string
    venueId: string
    createdAt: Date
    _count: DojoCheckInCountAggregateOutputType | null
    _min: DojoCheckInMinAggregateOutputType | null
    _max: DojoCheckInMaxAggregateOutputType | null
  }

  type GetDojoCheckInGroupByPayload<T extends DojoCheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DojoCheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DojoCheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DojoCheckInGroupByOutputType[P]>
            : GetScalarType<T[P], DojoCheckInGroupByOutputType[P]>
        }
      >
    >


  export type DojoCheckInSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    venueId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dojoCheckIn"]>

  export type DojoCheckInSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    venueId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dojoCheckIn"]>

  export type DojoCheckInSelectScalar = {
    id?: boolean
    userId?: boolean
    venueId?: boolean
    createdAt?: boolean
  }

  export type DojoCheckInInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type DojoCheckInIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $DojoCheckInPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DojoCheckIn"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      venueId: string
      createdAt: Date
    }, ExtArgs["result"]["dojoCheckIn"]>
    composites: {}
  }

  type DojoCheckInGetPayload<S extends boolean | null | undefined | DojoCheckInDefaultArgs> = $Result.GetResult<Prisma.$DojoCheckInPayload, S>

  type DojoCheckInCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DojoCheckInFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DojoCheckInCountAggregateInputType | true
    }

  export interface DojoCheckInDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DojoCheckIn'], meta: { name: 'DojoCheckIn' } }
    /**
     * Find zero or one DojoCheckIn that matches the filter.
     * @param {DojoCheckInFindUniqueArgs} args - Arguments to find a DojoCheckIn
     * @example
     * // Get one DojoCheckIn
     * const dojoCheckIn = await prisma.dojoCheckIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DojoCheckInFindUniqueArgs>(args: SelectSubset<T, DojoCheckInFindUniqueArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DojoCheckIn that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DojoCheckInFindUniqueOrThrowArgs} args - Arguments to find a DojoCheckIn
     * @example
     * // Get one DojoCheckIn
     * const dojoCheckIn = await prisma.dojoCheckIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DojoCheckInFindUniqueOrThrowArgs>(args: SelectSubset<T, DojoCheckInFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DojoCheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DojoCheckInFindFirstArgs} args - Arguments to find a DojoCheckIn
     * @example
     * // Get one DojoCheckIn
     * const dojoCheckIn = await prisma.dojoCheckIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DojoCheckInFindFirstArgs>(args?: SelectSubset<T, DojoCheckInFindFirstArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DojoCheckIn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DojoCheckInFindFirstOrThrowArgs} args - Arguments to find a DojoCheckIn
     * @example
     * // Get one DojoCheckIn
     * const dojoCheckIn = await prisma.dojoCheckIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DojoCheckInFindFirstOrThrowArgs>(args?: SelectSubset<T, DojoCheckInFindFirstOrThrowArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DojoCheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DojoCheckInFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DojoCheckIns
     * const dojoCheckIns = await prisma.dojoCheckIn.findMany()
     * 
     * // Get first 10 DojoCheckIns
     * const dojoCheckIns = await prisma.dojoCheckIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dojoCheckInWithIdOnly = await prisma.dojoCheckIn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DojoCheckInFindManyArgs>(args?: SelectSubset<T, DojoCheckInFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DojoCheckIn.
     * @param {DojoCheckInCreateArgs} args - Arguments to create a DojoCheckIn.
     * @example
     * // Create one DojoCheckIn
     * const DojoCheckIn = await prisma.dojoCheckIn.create({
     *   data: {
     *     // ... data to create a DojoCheckIn
     *   }
     * })
     * 
     */
    create<T extends DojoCheckInCreateArgs>(args: SelectSubset<T, DojoCheckInCreateArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DojoCheckIns.
     * @param {DojoCheckInCreateManyArgs} args - Arguments to create many DojoCheckIns.
     * @example
     * // Create many DojoCheckIns
     * const dojoCheckIn = await prisma.dojoCheckIn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DojoCheckInCreateManyArgs>(args?: SelectSubset<T, DojoCheckInCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DojoCheckIns and returns the data saved in the database.
     * @param {DojoCheckInCreateManyAndReturnArgs} args - Arguments to create many DojoCheckIns.
     * @example
     * // Create many DojoCheckIns
     * const dojoCheckIn = await prisma.dojoCheckIn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DojoCheckIns and only return the `id`
     * const dojoCheckInWithIdOnly = await prisma.dojoCheckIn.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DojoCheckInCreateManyAndReturnArgs>(args?: SelectSubset<T, DojoCheckInCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DojoCheckIn.
     * @param {DojoCheckInDeleteArgs} args - Arguments to delete one DojoCheckIn.
     * @example
     * // Delete one DojoCheckIn
     * const DojoCheckIn = await prisma.dojoCheckIn.delete({
     *   where: {
     *     // ... filter to delete one DojoCheckIn
     *   }
     * })
     * 
     */
    delete<T extends DojoCheckInDeleteArgs>(args: SelectSubset<T, DojoCheckInDeleteArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DojoCheckIn.
     * @param {DojoCheckInUpdateArgs} args - Arguments to update one DojoCheckIn.
     * @example
     * // Update one DojoCheckIn
     * const dojoCheckIn = await prisma.dojoCheckIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DojoCheckInUpdateArgs>(args: SelectSubset<T, DojoCheckInUpdateArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DojoCheckIns.
     * @param {DojoCheckInDeleteManyArgs} args - Arguments to filter DojoCheckIns to delete.
     * @example
     * // Delete a few DojoCheckIns
     * const { count } = await prisma.dojoCheckIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DojoCheckInDeleteManyArgs>(args?: SelectSubset<T, DojoCheckInDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DojoCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DojoCheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DojoCheckIns
     * const dojoCheckIn = await prisma.dojoCheckIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DojoCheckInUpdateManyArgs>(args: SelectSubset<T, DojoCheckInUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DojoCheckIn.
     * @param {DojoCheckInUpsertArgs} args - Arguments to update or create a DojoCheckIn.
     * @example
     * // Update or create a DojoCheckIn
     * const dojoCheckIn = await prisma.dojoCheckIn.upsert({
     *   create: {
     *     // ... data to create a DojoCheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DojoCheckIn we want to update
     *   }
     * })
     */
    upsert<T extends DojoCheckInUpsertArgs>(args: SelectSubset<T, DojoCheckInUpsertArgs<ExtArgs>>): Prisma__DojoCheckInClient<$Result.GetResult<Prisma.$DojoCheckInPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DojoCheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DojoCheckInCountArgs} args - Arguments to filter DojoCheckIns to count.
     * @example
     * // Count the number of DojoCheckIns
     * const count = await prisma.dojoCheckIn.count({
     *   where: {
     *     // ... the filter for the DojoCheckIns we want to count
     *   }
     * })
    **/
    count<T extends DojoCheckInCountArgs>(
      args?: Subset<T, DojoCheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DojoCheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DojoCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DojoCheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DojoCheckInAggregateArgs>(args: Subset<T, DojoCheckInAggregateArgs>): Prisma.PrismaPromise<GetDojoCheckInAggregateType<T>>

    /**
     * Group by DojoCheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DojoCheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DojoCheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DojoCheckInGroupByArgs['orderBy'] }
        : { orderBy?: DojoCheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DojoCheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDojoCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DojoCheckIn model
   */
  readonly fields: DojoCheckInFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DojoCheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DojoCheckInClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DojoCheckIn model
   */ 
  interface DojoCheckInFieldRefs {
    readonly id: FieldRef<"DojoCheckIn", 'String'>
    readonly userId: FieldRef<"DojoCheckIn", 'String'>
    readonly venueId: FieldRef<"DojoCheckIn", 'String'>
    readonly createdAt: FieldRef<"DojoCheckIn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DojoCheckIn findUnique
   */
  export type DojoCheckInFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * Filter, which DojoCheckIn to fetch.
     */
    where: DojoCheckInWhereUniqueInput
  }

  /**
   * DojoCheckIn findUniqueOrThrow
   */
  export type DojoCheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * Filter, which DojoCheckIn to fetch.
     */
    where: DojoCheckInWhereUniqueInput
  }

  /**
   * DojoCheckIn findFirst
   */
  export type DojoCheckInFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * Filter, which DojoCheckIn to fetch.
     */
    where?: DojoCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DojoCheckIns to fetch.
     */
    orderBy?: DojoCheckInOrderByWithRelationInput | DojoCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DojoCheckIns.
     */
    cursor?: DojoCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DojoCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DojoCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DojoCheckIns.
     */
    distinct?: DojoCheckInScalarFieldEnum | DojoCheckInScalarFieldEnum[]
  }

  /**
   * DojoCheckIn findFirstOrThrow
   */
  export type DojoCheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * Filter, which DojoCheckIn to fetch.
     */
    where?: DojoCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DojoCheckIns to fetch.
     */
    orderBy?: DojoCheckInOrderByWithRelationInput | DojoCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DojoCheckIns.
     */
    cursor?: DojoCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DojoCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DojoCheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DojoCheckIns.
     */
    distinct?: DojoCheckInScalarFieldEnum | DojoCheckInScalarFieldEnum[]
  }

  /**
   * DojoCheckIn findMany
   */
  export type DojoCheckInFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * Filter, which DojoCheckIns to fetch.
     */
    where?: DojoCheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DojoCheckIns to fetch.
     */
    orderBy?: DojoCheckInOrderByWithRelationInput | DojoCheckInOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DojoCheckIns.
     */
    cursor?: DojoCheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DojoCheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DojoCheckIns.
     */
    skip?: number
    distinct?: DojoCheckInScalarFieldEnum | DojoCheckInScalarFieldEnum[]
  }

  /**
   * DojoCheckIn create
   */
  export type DojoCheckInCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a DojoCheckIn.
     */
    data: XOR<DojoCheckInCreateInput, DojoCheckInUncheckedCreateInput>
  }

  /**
   * DojoCheckIn createMany
   */
  export type DojoCheckInCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DojoCheckIns.
     */
    data: DojoCheckInCreateManyInput | DojoCheckInCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DojoCheckIn createManyAndReturn
   */
  export type DojoCheckInCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DojoCheckIns.
     */
    data: DojoCheckInCreateManyInput | DojoCheckInCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DojoCheckIn update
   */
  export type DojoCheckInUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a DojoCheckIn.
     */
    data: XOR<DojoCheckInUpdateInput, DojoCheckInUncheckedUpdateInput>
    /**
     * Choose, which DojoCheckIn to update.
     */
    where: DojoCheckInWhereUniqueInput
  }

  /**
   * DojoCheckIn updateMany
   */
  export type DojoCheckInUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DojoCheckIns.
     */
    data: XOR<DojoCheckInUpdateManyMutationInput, DojoCheckInUncheckedUpdateManyInput>
    /**
     * Filter which DojoCheckIns to update
     */
    where?: DojoCheckInWhereInput
  }

  /**
   * DojoCheckIn upsert
   */
  export type DojoCheckInUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the DojoCheckIn to update in case it exists.
     */
    where: DojoCheckInWhereUniqueInput
    /**
     * In case the DojoCheckIn found by the `where` argument doesn't exist, create a new DojoCheckIn with this data.
     */
    create: XOR<DojoCheckInCreateInput, DojoCheckInUncheckedCreateInput>
    /**
     * In case the DojoCheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DojoCheckInUpdateInput, DojoCheckInUncheckedUpdateInput>
  }

  /**
   * DojoCheckIn delete
   */
  export type DojoCheckInDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
    /**
     * Filter which DojoCheckIn to delete.
     */
    where: DojoCheckInWhereUniqueInput
  }

  /**
   * DojoCheckIn deleteMany
   */
  export type DojoCheckInDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DojoCheckIns to delete
     */
    where?: DojoCheckInWhereInput
  }

  /**
   * DojoCheckIn without action
   */
  export type DojoCheckInDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DojoCheckIn
     */
    select?: DojoCheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DojoCheckInInclude<ExtArgs> | null
  }


  /**
   * Model VenueSpecial
   */

  export type AggregateVenueSpecial = {
    _count: VenueSpecialCountAggregateOutputType | null
    _min: VenueSpecialMinAggregateOutputType | null
    _max: VenueSpecialMaxAggregateOutputType | null
  }

  export type VenueSpecialMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    title: string | null
    description: string | null
    type: string | null
    isActive: boolean | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueSpecialMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    title: string | null
    description: string | null
    type: string | null
    isActive: boolean | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueSpecialCountAggregateOutputType = {
    id: number
    venueId: number
    title: number
    description: number
    type: number
    isActive: number
    validUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenueSpecialMinAggregateInputType = {
    id?: true
    venueId?: true
    title?: true
    description?: true
    type?: true
    isActive?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueSpecialMaxAggregateInputType = {
    id?: true
    venueId?: true
    title?: true
    description?: true
    type?: true
    isActive?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueSpecialCountAggregateInputType = {
    id?: true
    venueId?: true
    title?: true
    description?: true
    type?: true
    isActive?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenueSpecialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueSpecial to aggregate.
     */
    where?: VenueSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueSpecials to fetch.
     */
    orderBy?: VenueSpecialOrderByWithRelationInput | VenueSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueSpecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VenueSpecials
    **/
    _count?: true | VenueSpecialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueSpecialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueSpecialMaxAggregateInputType
  }

  export type GetVenueSpecialAggregateType<T extends VenueSpecialAggregateArgs> = {
        [P in keyof T & keyof AggregateVenueSpecial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenueSpecial[P]>
      : GetScalarType<T[P], AggregateVenueSpecial[P]>
  }




  export type VenueSpecialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueSpecialWhereInput
    orderBy?: VenueSpecialOrderByWithAggregationInput | VenueSpecialOrderByWithAggregationInput[]
    by: VenueSpecialScalarFieldEnum[] | VenueSpecialScalarFieldEnum
    having?: VenueSpecialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueSpecialCountAggregateInputType | true
    _min?: VenueSpecialMinAggregateInputType
    _max?: VenueSpecialMaxAggregateInputType
  }

  export type VenueSpecialGroupByOutputType = {
    id: string
    venueId: string
    title: string
    description: string | null
    type: string
    isActive: boolean
    validUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VenueSpecialCountAggregateOutputType | null
    _min: VenueSpecialMinAggregateOutputType | null
    _max: VenueSpecialMaxAggregateOutputType | null
  }

  type GetVenueSpecialGroupByPayload<T extends VenueSpecialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueSpecialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueSpecialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueSpecialGroupByOutputType[P]>
            : GetScalarType<T[P], VenueSpecialGroupByOutputType[P]>
        }
      >
    >


  export type VenueSpecialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    isActive?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueSpecial"]>

  export type VenueSpecialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    isActive?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueSpecial"]>

  export type VenueSpecialSelectScalar = {
    id?: boolean
    venueId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    isActive?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenueSpecialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type VenueSpecialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $VenueSpecialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VenueSpecial"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      title: string
      description: string | null
      type: string
      isActive: boolean
      validUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venueSpecial"]>
    composites: {}
  }

  type VenueSpecialGetPayload<S extends boolean | null | undefined | VenueSpecialDefaultArgs> = $Result.GetResult<Prisma.$VenueSpecialPayload, S>

  type VenueSpecialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VenueSpecialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VenueSpecialCountAggregateInputType | true
    }

  export interface VenueSpecialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VenueSpecial'], meta: { name: 'VenueSpecial' } }
    /**
     * Find zero or one VenueSpecial that matches the filter.
     * @param {VenueSpecialFindUniqueArgs} args - Arguments to find a VenueSpecial
     * @example
     * // Get one VenueSpecial
     * const venueSpecial = await prisma.venueSpecial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueSpecialFindUniqueArgs>(args: SelectSubset<T, VenueSpecialFindUniqueArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VenueSpecial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VenueSpecialFindUniqueOrThrowArgs} args - Arguments to find a VenueSpecial
     * @example
     * // Get one VenueSpecial
     * const venueSpecial = await prisma.venueSpecial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueSpecialFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueSpecialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VenueSpecial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueSpecialFindFirstArgs} args - Arguments to find a VenueSpecial
     * @example
     * // Get one VenueSpecial
     * const venueSpecial = await prisma.venueSpecial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueSpecialFindFirstArgs>(args?: SelectSubset<T, VenueSpecialFindFirstArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VenueSpecial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueSpecialFindFirstOrThrowArgs} args - Arguments to find a VenueSpecial
     * @example
     * // Get one VenueSpecial
     * const venueSpecial = await prisma.venueSpecial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueSpecialFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueSpecialFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VenueSpecials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueSpecialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VenueSpecials
     * const venueSpecials = await prisma.venueSpecial.findMany()
     * 
     * // Get first 10 VenueSpecials
     * const venueSpecials = await prisma.venueSpecial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueSpecialWithIdOnly = await prisma.venueSpecial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueSpecialFindManyArgs>(args?: SelectSubset<T, VenueSpecialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VenueSpecial.
     * @param {VenueSpecialCreateArgs} args - Arguments to create a VenueSpecial.
     * @example
     * // Create one VenueSpecial
     * const VenueSpecial = await prisma.venueSpecial.create({
     *   data: {
     *     // ... data to create a VenueSpecial
     *   }
     * })
     * 
     */
    create<T extends VenueSpecialCreateArgs>(args: SelectSubset<T, VenueSpecialCreateArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VenueSpecials.
     * @param {VenueSpecialCreateManyArgs} args - Arguments to create many VenueSpecials.
     * @example
     * // Create many VenueSpecials
     * const venueSpecial = await prisma.venueSpecial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueSpecialCreateManyArgs>(args?: SelectSubset<T, VenueSpecialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VenueSpecials and returns the data saved in the database.
     * @param {VenueSpecialCreateManyAndReturnArgs} args - Arguments to create many VenueSpecials.
     * @example
     * // Create many VenueSpecials
     * const venueSpecial = await prisma.venueSpecial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VenueSpecials and only return the `id`
     * const venueSpecialWithIdOnly = await prisma.venueSpecial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueSpecialCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueSpecialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VenueSpecial.
     * @param {VenueSpecialDeleteArgs} args - Arguments to delete one VenueSpecial.
     * @example
     * // Delete one VenueSpecial
     * const VenueSpecial = await prisma.venueSpecial.delete({
     *   where: {
     *     // ... filter to delete one VenueSpecial
     *   }
     * })
     * 
     */
    delete<T extends VenueSpecialDeleteArgs>(args: SelectSubset<T, VenueSpecialDeleteArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VenueSpecial.
     * @param {VenueSpecialUpdateArgs} args - Arguments to update one VenueSpecial.
     * @example
     * // Update one VenueSpecial
     * const venueSpecial = await prisma.venueSpecial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueSpecialUpdateArgs>(args: SelectSubset<T, VenueSpecialUpdateArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VenueSpecials.
     * @param {VenueSpecialDeleteManyArgs} args - Arguments to filter VenueSpecials to delete.
     * @example
     * // Delete a few VenueSpecials
     * const { count } = await prisma.venueSpecial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueSpecialDeleteManyArgs>(args?: SelectSubset<T, VenueSpecialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VenueSpecials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueSpecialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VenueSpecials
     * const venueSpecial = await prisma.venueSpecial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueSpecialUpdateManyArgs>(args: SelectSubset<T, VenueSpecialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VenueSpecial.
     * @param {VenueSpecialUpsertArgs} args - Arguments to update or create a VenueSpecial.
     * @example
     * // Update or create a VenueSpecial
     * const venueSpecial = await prisma.venueSpecial.upsert({
     *   create: {
     *     // ... data to create a VenueSpecial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VenueSpecial we want to update
     *   }
     * })
     */
    upsert<T extends VenueSpecialUpsertArgs>(args: SelectSubset<T, VenueSpecialUpsertArgs<ExtArgs>>): Prisma__VenueSpecialClient<$Result.GetResult<Prisma.$VenueSpecialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VenueSpecials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueSpecialCountArgs} args - Arguments to filter VenueSpecials to count.
     * @example
     * // Count the number of VenueSpecials
     * const count = await prisma.venueSpecial.count({
     *   where: {
     *     // ... the filter for the VenueSpecials we want to count
     *   }
     * })
    **/
    count<T extends VenueSpecialCountArgs>(
      args?: Subset<T, VenueSpecialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueSpecialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VenueSpecial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueSpecialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueSpecialAggregateArgs>(args: Subset<T, VenueSpecialAggregateArgs>): Prisma.PrismaPromise<GetVenueSpecialAggregateType<T>>

    /**
     * Group by VenueSpecial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueSpecialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueSpecialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueSpecialGroupByArgs['orderBy'] }
        : { orderBy?: VenueSpecialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueSpecialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueSpecialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VenueSpecial model
   */
  readonly fields: VenueSpecialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VenueSpecial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueSpecialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VenueSpecial model
   */ 
  interface VenueSpecialFieldRefs {
    readonly id: FieldRef<"VenueSpecial", 'String'>
    readonly venueId: FieldRef<"VenueSpecial", 'String'>
    readonly title: FieldRef<"VenueSpecial", 'String'>
    readonly description: FieldRef<"VenueSpecial", 'String'>
    readonly type: FieldRef<"VenueSpecial", 'String'>
    readonly isActive: FieldRef<"VenueSpecial", 'Boolean'>
    readonly validUntil: FieldRef<"VenueSpecial", 'DateTime'>
    readonly createdAt: FieldRef<"VenueSpecial", 'DateTime'>
    readonly updatedAt: FieldRef<"VenueSpecial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VenueSpecial findUnique
   */
  export type VenueSpecialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * Filter, which VenueSpecial to fetch.
     */
    where: VenueSpecialWhereUniqueInput
  }

  /**
   * VenueSpecial findUniqueOrThrow
   */
  export type VenueSpecialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * Filter, which VenueSpecial to fetch.
     */
    where: VenueSpecialWhereUniqueInput
  }

  /**
   * VenueSpecial findFirst
   */
  export type VenueSpecialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * Filter, which VenueSpecial to fetch.
     */
    where?: VenueSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueSpecials to fetch.
     */
    orderBy?: VenueSpecialOrderByWithRelationInput | VenueSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueSpecials.
     */
    cursor?: VenueSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueSpecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueSpecials.
     */
    distinct?: VenueSpecialScalarFieldEnum | VenueSpecialScalarFieldEnum[]
  }

  /**
   * VenueSpecial findFirstOrThrow
   */
  export type VenueSpecialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * Filter, which VenueSpecial to fetch.
     */
    where?: VenueSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueSpecials to fetch.
     */
    orderBy?: VenueSpecialOrderByWithRelationInput | VenueSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueSpecials.
     */
    cursor?: VenueSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueSpecials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueSpecials.
     */
    distinct?: VenueSpecialScalarFieldEnum | VenueSpecialScalarFieldEnum[]
  }

  /**
   * VenueSpecial findMany
   */
  export type VenueSpecialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * Filter, which VenueSpecials to fetch.
     */
    where?: VenueSpecialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueSpecials to fetch.
     */
    orderBy?: VenueSpecialOrderByWithRelationInput | VenueSpecialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VenueSpecials.
     */
    cursor?: VenueSpecialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueSpecials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueSpecials.
     */
    skip?: number
    distinct?: VenueSpecialScalarFieldEnum | VenueSpecialScalarFieldEnum[]
  }

  /**
   * VenueSpecial create
   */
  export type VenueSpecialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * The data needed to create a VenueSpecial.
     */
    data: XOR<VenueSpecialCreateInput, VenueSpecialUncheckedCreateInput>
  }

  /**
   * VenueSpecial createMany
   */
  export type VenueSpecialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VenueSpecials.
     */
    data: VenueSpecialCreateManyInput | VenueSpecialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VenueSpecial createManyAndReturn
   */
  export type VenueSpecialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VenueSpecials.
     */
    data: VenueSpecialCreateManyInput | VenueSpecialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VenueSpecial update
   */
  export type VenueSpecialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * The data needed to update a VenueSpecial.
     */
    data: XOR<VenueSpecialUpdateInput, VenueSpecialUncheckedUpdateInput>
    /**
     * Choose, which VenueSpecial to update.
     */
    where: VenueSpecialWhereUniqueInput
  }

  /**
   * VenueSpecial updateMany
   */
  export type VenueSpecialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VenueSpecials.
     */
    data: XOR<VenueSpecialUpdateManyMutationInput, VenueSpecialUncheckedUpdateManyInput>
    /**
     * Filter which VenueSpecials to update
     */
    where?: VenueSpecialWhereInput
  }

  /**
   * VenueSpecial upsert
   */
  export type VenueSpecialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * The filter to search for the VenueSpecial to update in case it exists.
     */
    where: VenueSpecialWhereUniqueInput
    /**
     * In case the VenueSpecial found by the `where` argument doesn't exist, create a new VenueSpecial with this data.
     */
    create: XOR<VenueSpecialCreateInput, VenueSpecialUncheckedCreateInput>
    /**
     * In case the VenueSpecial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueSpecialUpdateInput, VenueSpecialUncheckedUpdateInput>
  }

  /**
   * VenueSpecial delete
   */
  export type VenueSpecialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
    /**
     * Filter which VenueSpecial to delete.
     */
    where: VenueSpecialWhereUniqueInput
  }

  /**
   * VenueSpecial deleteMany
   */
  export type VenueSpecialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueSpecials to delete
     */
    where?: VenueSpecialWhereInput
  }

  /**
   * VenueSpecial without action
   */
  export type VenueSpecialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueSpecial
     */
    select?: VenueSpecialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueSpecialInclude<ExtArgs> | null
  }


  /**
   * Model UserInventoryItem
   */

  export type AggregateUserInventoryItem = {
    _count: UserInventoryItemCountAggregateOutputType | null
    _min: UserInventoryItemMinAggregateOutputType | null
    _max: UserInventoryItemMaxAggregateOutputType | null
  }

  export type UserInventoryItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    marketplaceItemId: string | null
    createdAt: Date | null
  }

  export type UserInventoryItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    marketplaceItemId: string | null
    createdAt: Date | null
  }

  export type UserInventoryItemCountAggregateOutputType = {
    id: number
    userId: number
    marketplaceItemId: number
    createdAt: number
    _all: number
  }


  export type UserInventoryItemMinAggregateInputType = {
    id?: true
    userId?: true
    marketplaceItemId?: true
    createdAt?: true
  }

  export type UserInventoryItemMaxAggregateInputType = {
    id?: true
    userId?: true
    marketplaceItemId?: true
    createdAt?: true
  }

  export type UserInventoryItemCountAggregateInputType = {
    id?: true
    userId?: true
    marketplaceItemId?: true
    createdAt?: true
    _all?: true
  }

  export type UserInventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventoryItem to aggregate.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInventoryItems
    **/
    _count?: true | UserInventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInventoryItemMaxAggregateInputType
  }

  export type GetUserInventoryItemAggregateType<T extends UserInventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInventoryItem[P]>
      : GetScalarType<T[P], AggregateUserInventoryItem[P]>
  }




  export type UserInventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryItemWhereInput
    orderBy?: UserInventoryItemOrderByWithAggregationInput | UserInventoryItemOrderByWithAggregationInput[]
    by: UserInventoryItemScalarFieldEnum[] | UserInventoryItemScalarFieldEnum
    having?: UserInventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInventoryItemCountAggregateInputType | true
    _min?: UserInventoryItemMinAggregateInputType
    _max?: UserInventoryItemMaxAggregateInputType
  }

  export type UserInventoryItemGroupByOutputType = {
    id: string
    userId: string
    marketplaceItemId: string
    createdAt: Date
    _count: UserInventoryItemCountAggregateOutputType | null
    _min: UserInventoryItemMinAggregateOutputType | null
    _max: UserInventoryItemMaxAggregateOutputType | null
  }

  type GetUserInventoryItemGroupByPayload<T extends UserInventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], UserInventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type UserInventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    marketplaceItemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventoryItem"]>

  export type UserInventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    marketplaceItemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventoryItem"]>

  export type UserInventoryItemSelectScalar = {
    id?: boolean
    userId?: boolean
    marketplaceItemId?: boolean
    createdAt?: boolean
  }

  export type UserInventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
  }
  export type UserInventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
  }

  export type $UserInventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInventoryItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      marketplaceItem: Prisma.$MarketplaceItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      marketplaceItemId: string
      createdAt: Date
    }, ExtArgs["result"]["userInventoryItem"]>
    composites: {}
  }

  type UserInventoryItemGetPayload<S extends boolean | null | undefined | UserInventoryItemDefaultArgs> = $Result.GetResult<Prisma.$UserInventoryItemPayload, S>

  type UserInventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserInventoryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserInventoryItemCountAggregateInputType | true
    }

  export interface UserInventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInventoryItem'], meta: { name: 'UserInventoryItem' } }
    /**
     * Find zero or one UserInventoryItem that matches the filter.
     * @param {UserInventoryItemFindUniqueArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInventoryItemFindUniqueArgs>(args: SelectSubset<T, UserInventoryItemFindUniqueArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserInventoryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserInventoryItemFindUniqueOrThrowArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserInventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemFindFirstArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInventoryItemFindFirstArgs>(args?: SelectSubset<T, UserInventoryItemFindFirstArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserInventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemFindFirstOrThrowArgs} args - Arguments to find a UserInventoryItem
     * @example
     * // Get one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserInventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInventoryItems
     * const userInventoryItems = await prisma.userInventoryItem.findMany()
     * 
     * // Get first 10 UserInventoryItems
     * const userInventoryItems = await prisma.userInventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInventoryItemWithIdOnly = await prisma.userInventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInventoryItemFindManyArgs>(args?: SelectSubset<T, UserInventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserInventoryItem.
     * @param {UserInventoryItemCreateArgs} args - Arguments to create a UserInventoryItem.
     * @example
     * // Create one UserInventoryItem
     * const UserInventoryItem = await prisma.userInventoryItem.create({
     *   data: {
     *     // ... data to create a UserInventoryItem
     *   }
     * })
     * 
     */
    create<T extends UserInventoryItemCreateArgs>(args: SelectSubset<T, UserInventoryItemCreateArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserInventoryItems.
     * @param {UserInventoryItemCreateManyArgs} args - Arguments to create many UserInventoryItems.
     * @example
     * // Create many UserInventoryItems
     * const userInventoryItem = await prisma.userInventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInventoryItemCreateManyArgs>(args?: SelectSubset<T, UserInventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInventoryItems and returns the data saved in the database.
     * @param {UserInventoryItemCreateManyAndReturnArgs} args - Arguments to create many UserInventoryItems.
     * @example
     * // Create many UserInventoryItems
     * const userInventoryItem = await prisma.userInventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInventoryItems and only return the `id`
     * const userInventoryItemWithIdOnly = await prisma.userInventoryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserInventoryItem.
     * @param {UserInventoryItemDeleteArgs} args - Arguments to delete one UserInventoryItem.
     * @example
     * // Delete one UserInventoryItem
     * const UserInventoryItem = await prisma.userInventoryItem.delete({
     *   where: {
     *     // ... filter to delete one UserInventoryItem
     *   }
     * })
     * 
     */
    delete<T extends UserInventoryItemDeleteArgs>(args: SelectSubset<T, UserInventoryItemDeleteArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserInventoryItem.
     * @param {UserInventoryItemUpdateArgs} args - Arguments to update one UserInventoryItem.
     * @example
     * // Update one UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInventoryItemUpdateArgs>(args: SelectSubset<T, UserInventoryItemUpdateArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserInventoryItems.
     * @param {UserInventoryItemDeleteManyArgs} args - Arguments to filter UserInventoryItems to delete.
     * @example
     * // Delete a few UserInventoryItems
     * const { count } = await prisma.userInventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInventoryItemDeleteManyArgs>(args?: SelectSubset<T, UserInventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInventoryItems
     * const userInventoryItem = await prisma.userInventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInventoryItemUpdateManyArgs>(args: SelectSubset<T, UserInventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserInventoryItem.
     * @param {UserInventoryItemUpsertArgs} args - Arguments to update or create a UserInventoryItem.
     * @example
     * // Update or create a UserInventoryItem
     * const userInventoryItem = await prisma.userInventoryItem.upsert({
     *   create: {
     *     // ... data to create a UserInventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends UserInventoryItemUpsertArgs>(args: SelectSubset<T, UserInventoryItemUpsertArgs<ExtArgs>>): Prisma__UserInventoryItemClient<$Result.GetResult<Prisma.$UserInventoryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserInventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemCountArgs} args - Arguments to filter UserInventoryItems to count.
     * @example
     * // Count the number of UserInventoryItems
     * const count = await prisma.userInventoryItem.count({
     *   where: {
     *     // ... the filter for the UserInventoryItems we want to count
     *   }
     * })
    **/
    count<T extends UserInventoryItemCountArgs>(
      args?: Subset<T, UserInventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInventoryItemAggregateArgs>(args: Subset<T, UserInventoryItemAggregateArgs>): Prisma.PrismaPromise<GetUserInventoryItemAggregateType<T>>

    /**
     * Group by UserInventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: UserInventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInventoryItem model
   */
  readonly fields: UserInventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    marketplaceItem<T extends MarketplaceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceItemDefaultArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInventoryItem model
   */ 
  interface UserInventoryItemFieldRefs {
    readonly id: FieldRef<"UserInventoryItem", 'String'>
    readonly userId: FieldRef<"UserInventoryItem", 'String'>
    readonly marketplaceItemId: FieldRef<"UserInventoryItem", 'String'>
    readonly createdAt: FieldRef<"UserInventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInventoryItem findUnique
   */
  export type UserInventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem findUniqueOrThrow
   */
  export type UserInventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem findFirst
   */
  export type UserInventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventoryItems.
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventoryItems.
     */
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * UserInventoryItem findFirstOrThrow
   */
  export type UserInventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItem to fetch.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventoryItems.
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventoryItems.
     */
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * UserInventoryItem findMany
   */
  export type UserInventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which UserInventoryItems to fetch.
     */
    where?: UserInventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventoryItems to fetch.
     */
    orderBy?: UserInventoryItemOrderByWithRelationInput | UserInventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInventoryItems.
     */
    cursor?: UserInventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventoryItems.
     */
    skip?: number
    distinct?: UserInventoryItemScalarFieldEnum | UserInventoryItemScalarFieldEnum[]
  }

  /**
   * UserInventoryItem create
   */
  export type UserInventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInventoryItem.
     */
    data: XOR<UserInventoryItemCreateInput, UserInventoryItemUncheckedCreateInput>
  }

  /**
   * UserInventoryItem createMany
   */
  export type UserInventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInventoryItems.
     */
    data: UserInventoryItemCreateManyInput | UserInventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInventoryItem createManyAndReturn
   */
  export type UserInventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserInventoryItems.
     */
    data: UserInventoryItemCreateManyInput | UserInventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInventoryItem update
   */
  export type UserInventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInventoryItem.
     */
    data: XOR<UserInventoryItemUpdateInput, UserInventoryItemUncheckedUpdateInput>
    /**
     * Choose, which UserInventoryItem to update.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem updateMany
   */
  export type UserInventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInventoryItems.
     */
    data: XOR<UserInventoryItemUpdateManyMutationInput, UserInventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which UserInventoryItems to update
     */
    where?: UserInventoryItemWhereInput
  }

  /**
   * UserInventoryItem upsert
   */
  export type UserInventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInventoryItem to update in case it exists.
     */
    where: UserInventoryItemWhereUniqueInput
    /**
     * In case the UserInventoryItem found by the `where` argument doesn't exist, create a new UserInventoryItem with this data.
     */
    create: XOR<UserInventoryItemCreateInput, UserInventoryItemUncheckedCreateInput>
    /**
     * In case the UserInventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInventoryItemUpdateInput, UserInventoryItemUncheckedUpdateInput>
  }

  /**
   * UserInventoryItem delete
   */
  export type UserInventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
    /**
     * Filter which UserInventoryItem to delete.
     */
    where: UserInventoryItemWhereUniqueInput
  }

  /**
   * UserInventoryItem deleteMany
   */
  export type UserInventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventoryItems to delete
     */
    where?: UserInventoryItemWhereInput
  }

  /**
   * UserInventoryItem without action
   */
  export type UserInventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventoryItem
     */
    select?: UserInventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    category: $Enums.FeedbackCategory | null
    status: $Enums.FeedbackStatus | null
    priority: $Enums.FeedbackPriority | null
    adminNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    category: $Enums.FeedbackCategory | null
    status: $Enums.FeedbackStatus | null
    priority: $Enums.FeedbackPriority | null
    adminNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
    resolvedBy: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    category: number
    status: number
    priority: number
    adminNotes: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    resolvedBy: number
    _all: number
  }


  export type FeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    category?: true
    status?: true
    priority?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    category?: true
    status?: true
    priority?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    resolvedBy?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    category?: true
    status?: true
    priority?: true
    adminNotes?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    resolvedBy?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    userId: string
    message: string
    category: $Enums.FeedbackCategory
    status: $Enums.FeedbackStatus
    priority: $Enums.FeedbackPriority
    adminNotes: string | null
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    resolvedBy: string | null
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    category?: boolean
    status?: boolean
    priority?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Feedback$resolverArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    category?: boolean
    status?: boolean
    priority?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Feedback$resolverArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    category?: boolean
    status?: boolean
    priority?: boolean
    adminNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Feedback$resolverArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resolver?: boolean | Feedback$resolverArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resolver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      message: string
      category: $Enums.FeedbackCategory
      status: $Enums.FeedbackStatus
      priority: $Enums.FeedbackPriority
      adminNotes: string | null
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
      resolvedBy: string | null
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resolver<T extends Feedback$resolverArgs<ExtArgs> = {}>(args?: Subset<T, Feedback$resolverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly userId: FieldRef<"Feedback", 'String'>
    readonly message: FieldRef<"Feedback", 'String'>
    readonly category: FieldRef<"Feedback", 'FeedbackCategory'>
    readonly status: FieldRef<"Feedback", 'FeedbackStatus'>
    readonly priority: FieldRef<"Feedback", 'FeedbackPriority'>
    readonly adminNotes: FieldRef<"Feedback", 'String'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"Feedback", 'DateTime'>
    readonly resolvedAt: FieldRef<"Feedback", 'DateTime'>
    readonly resolvedBy: FieldRef<"Feedback", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback.resolver
   */
  export type Feedback$resolverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    likes: number | null
    shares: number | null
    views: number | null
  }

  export type ContentSumAggregateOutputType = {
    likes: number | null
    shares: number | null
    views: number | null
  }

  export type ContentMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    userId: string | null
    title: string | null
    description: string | null
    contentType: $Enums.ContentType | null
    fileUrl: string | null
    thumbnailUrl: string | null
    status: $Enums.ContentStatus | null
    visibility: $Enums.ContentVisibility | null
    metadata: string | null
    tags: string | null
    likes: number | null
    shares: number | null
    views: number | null
    moderatedBy: string | null
    moderatedAt: Date | null
    moderationNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    userId: string | null
    title: string | null
    description: string | null
    contentType: $Enums.ContentType | null
    fileUrl: string | null
    thumbnailUrl: string | null
    status: $Enums.ContentStatus | null
    visibility: $Enums.ContentVisibility | null
    metadata: string | null
    tags: string | null
    likes: number | null
    shares: number | null
    views: number | null
    moderatedBy: string | null
    moderatedAt: Date | null
    moderationNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentCountAggregateOutputType = {
    id: number
    contentId: number
    userId: number
    title: number
    description: number
    contentType: number
    fileUrl: number
    thumbnailUrl: number
    status: number
    visibility: number
    metadata: number
    tags: number
    likes: number
    shares: number
    views: number
    moderatedBy: number
    moderatedAt: number
    moderationNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    likes?: true
    shares?: true
    views?: true
  }

  export type ContentSumAggregateInputType = {
    likes?: true
    shares?: true
    views?: true
  }

  export type ContentMinAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    title?: true
    description?: true
    contentType?: true
    fileUrl?: true
    thumbnailUrl?: true
    status?: true
    visibility?: true
    metadata?: true
    tags?: true
    likes?: true
    shares?: true
    views?: true
    moderatedBy?: true
    moderatedAt?: true
    moderationNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentMaxAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    title?: true
    description?: true
    contentType?: true
    fileUrl?: true
    thumbnailUrl?: true
    status?: true
    visibility?: true
    metadata?: true
    tags?: true
    likes?: true
    shares?: true
    views?: true
    moderatedBy?: true
    moderatedAt?: true
    moderationNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentCountAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    title?: true
    description?: true
    contentType?: true
    fileUrl?: true
    thumbnailUrl?: true
    status?: true
    visibility?: true
    metadata?: true
    tags?: true
    likes?: true
    shares?: true
    views?: true
    moderatedBy?: true
    moderatedAt?: true
    moderationNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Content to aggregate.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithAggregationInput | ContentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _avg?: ContentAvgAggregateInputType
    _sum?: ContentSumAggregateInputType
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    id: string
    contentId: string
    userId: string
    title: string
    description: string | null
    contentType: $Enums.ContentType
    fileUrl: string | null
    thumbnailUrl: string | null
    status: $Enums.ContentStatus
    visibility: $Enums.ContentVisibility
    metadata: string
    tags: string
    likes: number
    shares: number
    views: number
    moderatedBy: string | null
    moderatedAt: Date | null
    moderationNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    visibility?: boolean
    metadata?: boolean
    tags?: boolean
    likes?: boolean
    shares?: boolean
    views?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    moderationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    moderator?: boolean | Content$moderatorArgs<ExtArgs>
    likedBy?: boolean | Content$likedByArgs<ExtArgs>
    sharedEntries?: boolean | Content$sharedEntriesArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    visibility?: boolean
    metadata?: boolean
    tags?: boolean
    likes?: boolean
    shares?: boolean
    views?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    moderationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    moderator?: boolean | Content$moderatorArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectScalar = {
    id?: boolean
    contentId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    status?: boolean
    visibility?: boolean
    metadata?: boolean
    tags?: boolean
    likes?: boolean
    shares?: boolean
    views?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    moderationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    moderator?: boolean | Content$moderatorArgs<ExtArgs>
    likedBy?: boolean | Content$likedByArgs<ExtArgs>
    sharedEntries?: boolean | Content$sharedEntriesArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    moderator?: boolean | Content$moderatorArgs<ExtArgs>
  }

  export type $ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Content"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      moderator: Prisma.$UserPayload<ExtArgs> | null
      likedBy: Prisma.$ContentLikePayload<ExtArgs>[]
      sharedEntries: Prisma.$ContentSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      userId: string
      title: string
      description: string | null
      contentType: $Enums.ContentType
      fileUrl: string | null
      thumbnailUrl: string | null
      status: $Enums.ContentStatus
      visibility: $Enums.ContentVisibility
      metadata: string
      tags: string
      likes: number
      shares: number
      views: number
      moderatedBy: string | null
      moderatedAt: Date | null
      moderationNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["content"]>
    composites: {}
  }

  type ContentGetPayload<S extends boolean | null | undefined | ContentDefaultArgs> = $Result.GetResult<Prisma.$ContentPayload, S>

  type ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Content'], meta: { name: 'Content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFindUniqueArgs>(args: SelectSubset<T, ContentFindUniqueArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Content that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFindFirstArgs>(args?: SelectSubset<T, ContentFindFirstArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentWithIdOnly = await prisma.content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentFindManyArgs>(args?: SelectSubset<T, ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
     */
    create<T extends ContentCreateArgs>(args: SelectSubset<T, ContentCreateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contents.
     * @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCreateManyArgs>(args?: SelectSubset<T, ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contents and returns the data saved in the database.
     * @param {ContentCreateManyAndReturnArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
     */
    delete<T extends ContentDeleteArgs>(args: SelectSubset<T, ContentDeleteArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateArgs>(args: SelectSubset<T, ContentUpdateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentDeleteManyArgs>(args?: SelectSubset<T, ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateManyArgs>(args: SelectSubset<T, ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpsertArgs>(args: SelectSubset<T, ContentUpsertArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Content model
   */
  readonly fields: ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    moderator<T extends Content$moderatorArgs<ExtArgs> = {}>(args?: Subset<T, Content$moderatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    likedBy<T extends Content$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Content$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "findMany"> | Null>
    sharedEntries<T extends Content$sharedEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Content$sharedEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Content model
   */ 
  interface ContentFieldRefs {
    readonly id: FieldRef<"Content", 'String'>
    readonly contentId: FieldRef<"Content", 'String'>
    readonly userId: FieldRef<"Content", 'String'>
    readonly title: FieldRef<"Content", 'String'>
    readonly description: FieldRef<"Content", 'String'>
    readonly contentType: FieldRef<"Content", 'ContentType'>
    readonly fileUrl: FieldRef<"Content", 'String'>
    readonly thumbnailUrl: FieldRef<"Content", 'String'>
    readonly status: FieldRef<"Content", 'ContentStatus'>
    readonly visibility: FieldRef<"Content", 'ContentVisibility'>
    readonly metadata: FieldRef<"Content", 'String'>
    readonly tags: FieldRef<"Content", 'String'>
    readonly likes: FieldRef<"Content", 'Int'>
    readonly shares: FieldRef<"Content", 'Int'>
    readonly views: FieldRef<"Content", 'Int'>
    readonly moderatedBy: FieldRef<"Content", 'String'>
    readonly moderatedAt: FieldRef<"Content", 'DateTime'>
    readonly moderationNotes: FieldRef<"Content", 'String'>
    readonly createdAt: FieldRef<"Content", 'DateTime'>
    readonly updatedAt: FieldRef<"Content", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findUniqueOrThrow
   */
  export type ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findFirstOrThrow
   */
  export type ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findMany
   */
  export type ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Contents to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content create
   */
  export type ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Content.
     */
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }

  /**
   * Content createMany
   */
  export type ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Content createManyAndReturn
   */
  export type ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Content update
   */
  export type ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Content.
     */
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
  }

  /**
   * Content upsert
   */
  export type ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Content to update in case it exists.
     */
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
     */
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }

  /**
   * Content delete
   */
  export type ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter which Content to delete.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contents to delete
     */
    where?: ContentWhereInput
  }

  /**
   * Content.moderator
   */
  export type Content$moderatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Content.likedBy
   */
  export type Content$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    where?: ContentLikeWhereInput
    orderBy?: ContentLikeOrderByWithRelationInput | ContentLikeOrderByWithRelationInput[]
    cursor?: ContentLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentLikeScalarFieldEnum | ContentLikeScalarFieldEnum[]
  }

  /**
   * Content.sharedEntries
   */
  export type Content$sharedEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    where?: ContentShareWhereInput
    orderBy?: ContentShareOrderByWithRelationInput | ContentShareOrderByWithRelationInput[]
    cursor?: ContentShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentShareScalarFieldEnum | ContentShareScalarFieldEnum[]
  }

  /**
   * Content without action
   */
  export type ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
  }


  /**
   * Model ContentLike
   */

  export type AggregateContentLike = {
    _count: ContentLikeCountAggregateOutputType | null
    _avg: ContentLikeAvgAggregateOutputType | null
    _sum: ContentLikeSumAggregateOutputType | null
    _min: ContentLikeMinAggregateOutputType | null
    _max: ContentLikeMaxAggregateOutputType | null
  }

  export type ContentLikeAvgAggregateOutputType = {
    likes: number | null
  }

  export type ContentLikeSumAggregateOutputType = {
    likes: number | null
  }

  export type ContentLikeMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    userId: string | null
    likes: number | null
    createdAt: Date | null
  }

  export type ContentLikeMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    userId: string | null
    likes: number | null
    createdAt: Date | null
  }

  export type ContentLikeCountAggregateOutputType = {
    id: number
    contentId: number
    userId: number
    likes: number
    createdAt: number
    _all: number
  }


  export type ContentLikeAvgAggregateInputType = {
    likes?: true
  }

  export type ContentLikeSumAggregateInputType = {
    likes?: true
  }

  export type ContentLikeMinAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    likes?: true
    createdAt?: true
  }

  export type ContentLikeMaxAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    likes?: true
    createdAt?: true
  }

  export type ContentLikeCountAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    likes?: true
    createdAt?: true
    _all?: true
  }

  export type ContentLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentLike to aggregate.
     */
    where?: ContentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLikes to fetch.
     */
    orderBy?: ContentLikeOrderByWithRelationInput | ContentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentLikes
    **/
    _count?: true | ContentLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentLikeMaxAggregateInputType
  }

  export type GetContentLikeAggregateType<T extends ContentLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateContentLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentLike[P]>
      : GetScalarType<T[P], AggregateContentLike[P]>
  }




  export type ContentLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentLikeWhereInput
    orderBy?: ContentLikeOrderByWithAggregationInput | ContentLikeOrderByWithAggregationInput[]
    by: ContentLikeScalarFieldEnum[] | ContentLikeScalarFieldEnum
    having?: ContentLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentLikeCountAggregateInputType | true
    _avg?: ContentLikeAvgAggregateInputType
    _sum?: ContentLikeSumAggregateInputType
    _min?: ContentLikeMinAggregateInputType
    _max?: ContentLikeMaxAggregateInputType
  }

  export type ContentLikeGroupByOutputType = {
    id: string
    contentId: string
    userId: string
    likes: number
    createdAt: Date
    _count: ContentLikeCountAggregateOutputType | null
    _avg: ContentLikeAvgAggregateOutputType | null
    _sum: ContentLikeSumAggregateOutputType | null
    _min: ContentLikeMinAggregateOutputType | null
    _max: ContentLikeMaxAggregateOutputType | null
  }

  type GetContentLikeGroupByPayload<T extends ContentLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentLikeGroupByOutputType[P]>
            : GetScalarType<T[P], ContentLikeGroupByOutputType[P]>
        }
      >
    >


  export type ContentLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    userId?: boolean
    likes?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentLike"]>

  export type ContentLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    userId?: boolean
    likes?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentLike"]>

  export type ContentLikeSelectScalar = {
    id?: boolean
    contentId?: boolean
    userId?: boolean
    likes?: boolean
    createdAt?: boolean
  }

  export type ContentLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContentLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContentLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentLike"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      userId: string
      likes: number
      createdAt: Date
    }, ExtArgs["result"]["contentLike"]>
    composites: {}
  }

  type ContentLikeGetPayload<S extends boolean | null | undefined | ContentLikeDefaultArgs> = $Result.GetResult<Prisma.$ContentLikePayload, S>

  type ContentLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentLikeCountAggregateInputType | true
    }

  export interface ContentLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentLike'], meta: { name: 'ContentLike' } }
    /**
     * Find zero or one ContentLike that matches the filter.
     * @param {ContentLikeFindUniqueArgs} args - Arguments to find a ContentLike
     * @example
     * // Get one ContentLike
     * const contentLike = await prisma.contentLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentLikeFindUniqueArgs>(args: SelectSubset<T, ContentLikeFindUniqueArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentLikeFindUniqueOrThrowArgs} args - Arguments to find a ContentLike
     * @example
     * // Get one ContentLike
     * const contentLike = await prisma.contentLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLikeFindFirstArgs} args - Arguments to find a ContentLike
     * @example
     * // Get one ContentLike
     * const contentLike = await prisma.contentLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentLikeFindFirstArgs>(args?: SelectSubset<T, ContentLikeFindFirstArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLikeFindFirstOrThrowArgs} args - Arguments to find a ContentLike
     * @example
     * // Get one ContentLike
     * const contentLike = await prisma.contentLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentLikes
     * const contentLikes = await prisma.contentLike.findMany()
     * 
     * // Get first 10 ContentLikes
     * const contentLikes = await prisma.contentLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentLikeWithIdOnly = await prisma.contentLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentLikeFindManyArgs>(args?: SelectSubset<T, ContentLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentLike.
     * @param {ContentLikeCreateArgs} args - Arguments to create a ContentLike.
     * @example
     * // Create one ContentLike
     * const ContentLike = await prisma.contentLike.create({
     *   data: {
     *     // ... data to create a ContentLike
     *   }
     * })
     * 
     */
    create<T extends ContentLikeCreateArgs>(args: SelectSubset<T, ContentLikeCreateArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentLikes.
     * @param {ContentLikeCreateManyArgs} args - Arguments to create many ContentLikes.
     * @example
     * // Create many ContentLikes
     * const contentLike = await prisma.contentLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentLikeCreateManyArgs>(args?: SelectSubset<T, ContentLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentLikes and returns the data saved in the database.
     * @param {ContentLikeCreateManyAndReturnArgs} args - Arguments to create many ContentLikes.
     * @example
     * // Create many ContentLikes
     * const contentLike = await prisma.contentLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentLikes and only return the `id`
     * const contentLikeWithIdOnly = await prisma.contentLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentLike.
     * @param {ContentLikeDeleteArgs} args - Arguments to delete one ContentLike.
     * @example
     * // Delete one ContentLike
     * const ContentLike = await prisma.contentLike.delete({
     *   where: {
     *     // ... filter to delete one ContentLike
     *   }
     * })
     * 
     */
    delete<T extends ContentLikeDeleteArgs>(args: SelectSubset<T, ContentLikeDeleteArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentLike.
     * @param {ContentLikeUpdateArgs} args - Arguments to update one ContentLike.
     * @example
     * // Update one ContentLike
     * const contentLike = await prisma.contentLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentLikeUpdateArgs>(args: SelectSubset<T, ContentLikeUpdateArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentLikes.
     * @param {ContentLikeDeleteManyArgs} args - Arguments to filter ContentLikes to delete.
     * @example
     * // Delete a few ContentLikes
     * const { count } = await prisma.contentLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentLikeDeleteManyArgs>(args?: SelectSubset<T, ContentLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentLikes
     * const contentLike = await prisma.contentLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentLikeUpdateManyArgs>(args: SelectSubset<T, ContentLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentLike.
     * @param {ContentLikeUpsertArgs} args - Arguments to update or create a ContentLike.
     * @example
     * // Update or create a ContentLike
     * const contentLike = await prisma.contentLike.upsert({
     *   create: {
     *     // ... data to create a ContentLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentLike we want to update
     *   }
     * })
     */
    upsert<T extends ContentLikeUpsertArgs>(args: SelectSubset<T, ContentLikeUpsertArgs<ExtArgs>>): Prisma__ContentLikeClient<$Result.GetResult<Prisma.$ContentLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLikeCountArgs} args - Arguments to filter ContentLikes to count.
     * @example
     * // Count the number of ContentLikes
     * const count = await prisma.contentLike.count({
     *   where: {
     *     // ... the filter for the ContentLikes we want to count
     *   }
     * })
    **/
    count<T extends ContentLikeCountArgs>(
      args?: Subset<T, ContentLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentLikeAggregateArgs>(args: Subset<T, ContentLikeAggregateArgs>): Prisma.PrismaPromise<GetContentLikeAggregateType<T>>

    /**
     * Group by ContentLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentLikeGroupByArgs['orderBy'] }
        : { orderBy?: ContentLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentLike model
   */
  readonly fields: ContentLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentLike model
   */ 
  interface ContentLikeFieldRefs {
    readonly id: FieldRef<"ContentLike", 'String'>
    readonly contentId: FieldRef<"ContentLike", 'String'>
    readonly userId: FieldRef<"ContentLike", 'String'>
    readonly likes: FieldRef<"ContentLike", 'Int'>
    readonly createdAt: FieldRef<"ContentLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentLike findUnique
   */
  export type ContentLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * Filter, which ContentLike to fetch.
     */
    where: ContentLikeWhereUniqueInput
  }

  /**
   * ContentLike findUniqueOrThrow
   */
  export type ContentLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * Filter, which ContentLike to fetch.
     */
    where: ContentLikeWhereUniqueInput
  }

  /**
   * ContentLike findFirst
   */
  export type ContentLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * Filter, which ContentLike to fetch.
     */
    where?: ContentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLikes to fetch.
     */
    orderBy?: ContentLikeOrderByWithRelationInput | ContentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentLikes.
     */
    cursor?: ContentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentLikes.
     */
    distinct?: ContentLikeScalarFieldEnum | ContentLikeScalarFieldEnum[]
  }

  /**
   * ContentLike findFirstOrThrow
   */
  export type ContentLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * Filter, which ContentLike to fetch.
     */
    where?: ContentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLikes to fetch.
     */
    orderBy?: ContentLikeOrderByWithRelationInput | ContentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentLikes.
     */
    cursor?: ContentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentLikes.
     */
    distinct?: ContentLikeScalarFieldEnum | ContentLikeScalarFieldEnum[]
  }

  /**
   * ContentLike findMany
   */
  export type ContentLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * Filter, which ContentLikes to fetch.
     */
    where?: ContentLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLikes to fetch.
     */
    orderBy?: ContentLikeOrderByWithRelationInput | ContentLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentLikes.
     */
    cursor?: ContentLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLikes.
     */
    skip?: number
    distinct?: ContentLikeScalarFieldEnum | ContentLikeScalarFieldEnum[]
  }

  /**
   * ContentLike create
   */
  export type ContentLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentLike.
     */
    data: XOR<ContentLikeCreateInput, ContentLikeUncheckedCreateInput>
  }

  /**
   * ContentLike createMany
   */
  export type ContentLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentLikes.
     */
    data: ContentLikeCreateManyInput | ContentLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentLike createManyAndReturn
   */
  export type ContentLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentLikes.
     */
    data: ContentLikeCreateManyInput | ContentLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentLike update
   */
  export type ContentLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentLike.
     */
    data: XOR<ContentLikeUpdateInput, ContentLikeUncheckedUpdateInput>
    /**
     * Choose, which ContentLike to update.
     */
    where: ContentLikeWhereUniqueInput
  }

  /**
   * ContentLike updateMany
   */
  export type ContentLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentLikes.
     */
    data: XOR<ContentLikeUpdateManyMutationInput, ContentLikeUncheckedUpdateManyInput>
    /**
     * Filter which ContentLikes to update
     */
    where?: ContentLikeWhereInput
  }

  /**
   * ContentLike upsert
   */
  export type ContentLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentLike to update in case it exists.
     */
    where: ContentLikeWhereUniqueInput
    /**
     * In case the ContentLike found by the `where` argument doesn't exist, create a new ContentLike with this data.
     */
    create: XOR<ContentLikeCreateInput, ContentLikeUncheckedCreateInput>
    /**
     * In case the ContentLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentLikeUpdateInput, ContentLikeUncheckedUpdateInput>
  }

  /**
   * ContentLike delete
   */
  export type ContentLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
    /**
     * Filter which ContentLike to delete.
     */
    where: ContentLikeWhereUniqueInput
  }

  /**
   * ContentLike deleteMany
   */
  export type ContentLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentLikes to delete
     */
    where?: ContentLikeWhereInput
  }

  /**
   * ContentLike without action
   */
  export type ContentLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLike
     */
    select?: ContentLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLikeInclude<ExtArgs> | null
  }


  /**
   * Model ContentShare
   */

  export type AggregateContentShare = {
    _count: ContentShareCountAggregateOutputType | null
    _min: ContentShareMinAggregateOutputType | null
    _max: ContentShareMaxAggregateOutputType | null
  }

  export type ContentShareMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    userId: string | null
    sharedWithId: string | null
    createdAt: Date | null
  }

  export type ContentShareMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    userId: string | null
    sharedWithId: string | null
    createdAt: Date | null
  }

  export type ContentShareCountAggregateOutputType = {
    id: number
    contentId: number
    userId: number
    sharedWithId: number
    createdAt: number
    _all: number
  }


  export type ContentShareMinAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    sharedWithId?: true
    createdAt?: true
  }

  export type ContentShareMaxAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    sharedWithId?: true
    createdAt?: true
  }

  export type ContentShareCountAggregateInputType = {
    id?: true
    contentId?: true
    userId?: true
    sharedWithId?: true
    createdAt?: true
    _all?: true
  }

  export type ContentShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentShare to aggregate.
     */
    where?: ContentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentShares to fetch.
     */
    orderBy?: ContentShareOrderByWithRelationInput | ContentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentShares
    **/
    _count?: true | ContentShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentShareMaxAggregateInputType
  }

  export type GetContentShareAggregateType<T extends ContentShareAggregateArgs> = {
        [P in keyof T & keyof AggregateContentShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentShare[P]>
      : GetScalarType<T[P], AggregateContentShare[P]>
  }




  export type ContentShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentShareWhereInput
    orderBy?: ContentShareOrderByWithAggregationInput | ContentShareOrderByWithAggregationInput[]
    by: ContentShareScalarFieldEnum[] | ContentShareScalarFieldEnum
    having?: ContentShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentShareCountAggregateInputType | true
    _min?: ContentShareMinAggregateInputType
    _max?: ContentShareMaxAggregateInputType
  }

  export type ContentShareGroupByOutputType = {
    id: string
    contentId: string
    userId: string
    sharedWithId: string
    createdAt: Date
    _count: ContentShareCountAggregateOutputType | null
    _min: ContentShareMinAggregateOutputType | null
    _max: ContentShareMaxAggregateOutputType | null
  }

  type GetContentShareGroupByPayload<T extends ContentShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentShareGroupByOutputType[P]>
            : GetScalarType<T[P], ContentShareGroupByOutputType[P]>
        }
      >
    >


  export type ContentShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    userId?: boolean
    sharedWithId?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sharedWith?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentShare"]>

  export type ContentShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    userId?: boolean
    sharedWithId?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sharedWith?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentShare"]>

  export type ContentShareSelectScalar = {
    id?: boolean
    contentId?: boolean
    userId?: boolean
    sharedWithId?: boolean
    createdAt?: boolean
  }

  export type ContentShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sharedWith?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContentShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sharedWith?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContentSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentShare"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      sharedWith: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      userId: string
      sharedWithId: string
      createdAt: Date
    }, ExtArgs["result"]["contentShare"]>
    composites: {}
  }

  type ContentShareGetPayload<S extends boolean | null | undefined | ContentShareDefaultArgs> = $Result.GetResult<Prisma.$ContentSharePayload, S>

  type ContentShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentShareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentShareCountAggregateInputType | true
    }

  export interface ContentShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentShare'], meta: { name: 'ContentShare' } }
    /**
     * Find zero or one ContentShare that matches the filter.
     * @param {ContentShareFindUniqueArgs} args - Arguments to find a ContentShare
     * @example
     * // Get one ContentShare
     * const contentShare = await prisma.contentShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentShareFindUniqueArgs>(args: SelectSubset<T, ContentShareFindUniqueArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentShare that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentShareFindUniqueOrThrowArgs} args - Arguments to find a ContentShare
     * @example
     * // Get one ContentShare
     * const contentShare = await prisma.contentShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentShareFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentShareFindFirstArgs} args - Arguments to find a ContentShare
     * @example
     * // Get one ContentShare
     * const contentShare = await prisma.contentShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentShareFindFirstArgs>(args?: SelectSubset<T, ContentShareFindFirstArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentShareFindFirstOrThrowArgs} args - Arguments to find a ContentShare
     * @example
     * // Get one ContentShare
     * const contentShare = await prisma.contentShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentShareFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentShares
     * const contentShares = await prisma.contentShare.findMany()
     * 
     * // Get first 10 ContentShares
     * const contentShares = await prisma.contentShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentShareWithIdOnly = await prisma.contentShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentShareFindManyArgs>(args?: SelectSubset<T, ContentShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentShare.
     * @param {ContentShareCreateArgs} args - Arguments to create a ContentShare.
     * @example
     * // Create one ContentShare
     * const ContentShare = await prisma.contentShare.create({
     *   data: {
     *     // ... data to create a ContentShare
     *   }
     * })
     * 
     */
    create<T extends ContentShareCreateArgs>(args: SelectSubset<T, ContentShareCreateArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentShares.
     * @param {ContentShareCreateManyArgs} args - Arguments to create many ContentShares.
     * @example
     * // Create many ContentShares
     * const contentShare = await prisma.contentShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentShareCreateManyArgs>(args?: SelectSubset<T, ContentShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentShares and returns the data saved in the database.
     * @param {ContentShareCreateManyAndReturnArgs} args - Arguments to create many ContentShares.
     * @example
     * // Create many ContentShares
     * const contentShare = await prisma.contentShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentShares and only return the `id`
     * const contentShareWithIdOnly = await prisma.contentShare.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentShareCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentShare.
     * @param {ContentShareDeleteArgs} args - Arguments to delete one ContentShare.
     * @example
     * // Delete one ContentShare
     * const ContentShare = await prisma.contentShare.delete({
     *   where: {
     *     // ... filter to delete one ContentShare
     *   }
     * })
     * 
     */
    delete<T extends ContentShareDeleteArgs>(args: SelectSubset<T, ContentShareDeleteArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentShare.
     * @param {ContentShareUpdateArgs} args - Arguments to update one ContentShare.
     * @example
     * // Update one ContentShare
     * const contentShare = await prisma.contentShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentShareUpdateArgs>(args: SelectSubset<T, ContentShareUpdateArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentShares.
     * @param {ContentShareDeleteManyArgs} args - Arguments to filter ContentShares to delete.
     * @example
     * // Delete a few ContentShares
     * const { count } = await prisma.contentShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentShareDeleteManyArgs>(args?: SelectSubset<T, ContentShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentShares
     * const contentShare = await prisma.contentShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentShareUpdateManyArgs>(args: SelectSubset<T, ContentShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentShare.
     * @param {ContentShareUpsertArgs} args - Arguments to update or create a ContentShare.
     * @example
     * // Update or create a ContentShare
     * const contentShare = await prisma.contentShare.upsert({
     *   create: {
     *     // ... data to create a ContentShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentShare we want to update
     *   }
     * })
     */
    upsert<T extends ContentShareUpsertArgs>(args: SelectSubset<T, ContentShareUpsertArgs<ExtArgs>>): Prisma__ContentShareClient<$Result.GetResult<Prisma.$ContentSharePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentShareCountArgs} args - Arguments to filter ContentShares to count.
     * @example
     * // Count the number of ContentShares
     * const count = await prisma.contentShare.count({
     *   where: {
     *     // ... the filter for the ContentShares we want to count
     *   }
     * })
    **/
    count<T extends ContentShareCountArgs>(
      args?: Subset<T, ContentShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentShareAggregateArgs>(args: Subset<T, ContentShareAggregateArgs>): Prisma.PrismaPromise<GetContentShareAggregateType<T>>

    /**
     * Group by ContentShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentShareGroupByArgs['orderBy'] }
        : { orderBy?: ContentShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentShare model
   */
  readonly fields: ContentShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sharedWith<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentShare model
   */ 
  interface ContentShareFieldRefs {
    readonly id: FieldRef<"ContentShare", 'String'>
    readonly contentId: FieldRef<"ContentShare", 'String'>
    readonly userId: FieldRef<"ContentShare", 'String'>
    readonly sharedWithId: FieldRef<"ContentShare", 'String'>
    readonly createdAt: FieldRef<"ContentShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentShare findUnique
   */
  export type ContentShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * Filter, which ContentShare to fetch.
     */
    where: ContentShareWhereUniqueInput
  }

  /**
   * ContentShare findUniqueOrThrow
   */
  export type ContentShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * Filter, which ContentShare to fetch.
     */
    where: ContentShareWhereUniqueInput
  }

  /**
   * ContentShare findFirst
   */
  export type ContentShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * Filter, which ContentShare to fetch.
     */
    where?: ContentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentShares to fetch.
     */
    orderBy?: ContentShareOrderByWithRelationInput | ContentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentShares.
     */
    cursor?: ContentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentShares.
     */
    distinct?: ContentShareScalarFieldEnum | ContentShareScalarFieldEnum[]
  }

  /**
   * ContentShare findFirstOrThrow
   */
  export type ContentShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * Filter, which ContentShare to fetch.
     */
    where?: ContentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentShares to fetch.
     */
    orderBy?: ContentShareOrderByWithRelationInput | ContentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentShares.
     */
    cursor?: ContentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentShares.
     */
    distinct?: ContentShareScalarFieldEnum | ContentShareScalarFieldEnum[]
  }

  /**
   * ContentShare findMany
   */
  export type ContentShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * Filter, which ContentShares to fetch.
     */
    where?: ContentShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentShares to fetch.
     */
    orderBy?: ContentShareOrderByWithRelationInput | ContentShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentShares.
     */
    cursor?: ContentShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentShares.
     */
    skip?: number
    distinct?: ContentShareScalarFieldEnum | ContentShareScalarFieldEnum[]
  }

  /**
   * ContentShare create
   */
  export type ContentShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentShare.
     */
    data: XOR<ContentShareCreateInput, ContentShareUncheckedCreateInput>
  }

  /**
   * ContentShare createMany
   */
  export type ContentShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentShares.
     */
    data: ContentShareCreateManyInput | ContentShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentShare createManyAndReturn
   */
  export type ContentShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentShares.
     */
    data: ContentShareCreateManyInput | ContentShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentShare update
   */
  export type ContentShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentShare.
     */
    data: XOR<ContentShareUpdateInput, ContentShareUncheckedUpdateInput>
    /**
     * Choose, which ContentShare to update.
     */
    where: ContentShareWhereUniqueInput
  }

  /**
   * ContentShare updateMany
   */
  export type ContentShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentShares.
     */
    data: XOR<ContentShareUpdateManyMutationInput, ContentShareUncheckedUpdateManyInput>
    /**
     * Filter which ContentShares to update
     */
    where?: ContentShareWhereInput
  }

  /**
   * ContentShare upsert
   */
  export type ContentShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentShare to update in case it exists.
     */
    where: ContentShareWhereUniqueInput
    /**
     * In case the ContentShare found by the `where` argument doesn't exist, create a new ContentShare with this data.
     */
    create: XOR<ContentShareCreateInput, ContentShareUncheckedCreateInput>
    /**
     * In case the ContentShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentShareUpdateInput, ContentShareUncheckedUpdateInput>
  }

  /**
   * ContentShare delete
   */
  export type ContentShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
    /**
     * Filter which ContentShare to delete.
     */
    where: ContentShareWhereUniqueInput
  }

  /**
   * ContentShare deleteMany
   */
  export type ContentShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentShares to delete
     */
    where?: ContentShareWhereInput
  }

  /**
   * ContentShare without action
   */
  export type ContentShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentShare
     */
    select?: ContentShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentShareInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    deviceId: string | null
    deviceInfo: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    deviceId: string | null
    deviceInfo: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    deviceId: number
    deviceInfo: number
    expiresAt: number
    isRevoked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    deviceId?: true
    deviceInfo?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    deviceId?: true
    deviceInfo?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    deviceId?: true
    deviceInfo?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    deviceId: string | null
    deviceInfo: string | null
    expiresAt: Date
    isRevoked: boolean
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    deviceId?: boolean
    deviceInfo?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    deviceId?: boolean
    deviceInfo?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    deviceId?: boolean
    deviceInfo?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      deviceId: string | null
      deviceInfo: string | null
      expiresAt: Date
      isRevoked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly tokenHash: FieldRef<"RefreshToken", 'String'>
    readonly deviceId: FieldRef<"RefreshToken", 'String'>
    readonly deviceInfo: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly isRevoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    role: 'role',
    isBanned: 'isBanned',
    avatarUrl: 'avatarUrl',
    dojoCoinBalance: 'dojoCoinBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    emailVerified: 'emailVerified',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    location: 'location',
    skillRating: 'skillRating',
    clanTitle: 'clanTitle',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailNotifications: 'emailNotifications',
    pushNotifications: 'pushNotifications',
    darkMode: 'darkMode',
    language: 'language',
    timezone: 'timezone',
    privacySettings: 'privacySettings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    lat: 'lat',
    lng: 'lng',
    address: 'address',
    ownerId: 'ownerId',
    controllingClanId: 'controllingClanId',
    incomeModifier: 'incomeModifier',
    defenseLevel: 'defenseLevel',
    status: 'status',
    photos: 'photos',
    rating: 'rating',
    features: 'features',
    tables: 'tables',
    reviews: 'reviews',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const CheckInScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    venueId: 'venueId',
    via: 'via',
    createdAt: 'createdAt'
  };

  export type CheckInScalarFieldEnum = (typeof CheckInScalarFieldEnum)[keyof typeof CheckInScalarFieldEnum]


  export const ClanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tag: 'tag',
    leaderId: 'leaderId',
    maxMembers: 'maxMembers',
    dojoCoinBalance: 'dojoCoinBalance',
    seasonalPoints: 'seasonalPoints',
    bannerUrl: 'bannerUrl',
    color: 'color',
    level: 'level',
    experience: 'experience',
    reputation: 'reputation',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClanScalarFieldEnum = (typeof ClanScalarFieldEnum)[keyof typeof ClanScalarFieldEnum]


  export const ClanMemberScalarFieldEnum: {
    id: 'id',
    clanId: 'clanId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type ClanMemberScalarFieldEnum = (typeof ClanMemberScalarFieldEnum)[keyof typeof ClanMemberScalarFieldEnum]


  export const TerritoryScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    name: 'name',
    ownerId: 'ownerId',
    clanId: 'clanId',
    level: 'level',
    defenseScore: 'defenseScore',
    resources: 'resources',
    strategicValue: 'strategicValue',
    resourceRate: 'resourceRate',
    lastTickAt: 'lastTickAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TerritoryScalarFieldEnum = (typeof TerritoryScalarFieldEnum)[keyof typeof TerritoryScalarFieldEnum]


  export const TerritoryEventScalarFieldEnum: {
    id: 'id',
    territoryId: 'territoryId',
    type: 'type',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type TerritoryEventScalarFieldEnum = (typeof TerritoryEventScalarFieldEnum)[keyof typeof TerritoryEventScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    name: 'name',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    isSponsored: 'isSponsored',
    sponsoredBy: 'sponsoredBy',
    startDate: 'startDate',
    endDate: 'endDate',
    sponsorBannerUrl: 'sponsorBannerUrl',
    maxPlayers: 'maxPlayers',
    entryFee: 'entryFee',
    rewards: 'rewards',
    prizePool: 'prizePool',
    format: 'format',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const TournamentParticipantScalarFieldEnum: {
    id: 'id',
    tournamentId: 'tournamentId',
    userId: 'userId',
    seed: 'seed',
    finalRank: 'finalRank',
    createdAt: 'createdAt'
  };

  export type TournamentParticipantScalarFieldEnum = (typeof TournamentParticipantScalarFieldEnum)[keyof typeof TournamentParticipantScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    tournamentId: 'tournamentId',
    venueId: 'venueId',
    tableId: 'tableId',
    playerAId: 'playerAId',
    playerBId: 'playerBId',
    winnerId: 'winnerId',
    loserId: 'loserId',
    status: 'status',
    scoreA: 'scoreA',
    scoreB: 'scoreB',
    round: 'round',
    wager: 'wager',
    aiAnalysisJson: 'aiAnalysisJson',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const MatchEventScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    type: 'type',
    payload: 'payload',
    ts: 'ts'
  };

  export type MatchEventScalarFieldEnum = (typeof MatchEventScalarFieldEnum)[keyof typeof MatchEventScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    challengerId: 'challengerId',
    defenderId: 'defenderId',
    venueId: 'venueId',
    status: 'status',
    stakeCoins: 'stakeCoins',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    chain: 'chain',
    address: 'address',
    createdAt: 'createdAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    type: 'type',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const NFTScalarFieldEnum: {
    id: 'id',
    contract: 'contract',
    tokenId: 'tokenId',
    chain: 'chain',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NFTScalarFieldEnum = (typeof NFTScalarFieldEnum)[keyof typeof NFTScalarFieldEnum]


  export const UserNFTScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    nftId: 'nftId',
    createdAt: 'createdAt'
  };

  export type UserNFTScalarFieldEnum = (typeof UserNFTScalarFieldEnum)[keyof typeof UserNFTScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    desc: 'desc',
    description: 'description',
    category: 'category',
    points: 'points',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    earnedAt: 'earnedAt'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    payload: 'payload',
    read: 'read',
    isRead: 'isRead',
    recipientId: 'recipientId',
    title: 'title',
    priority: 'priority',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    target: 'target',
    metadata: 'metadata',
    ts: 'ts'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    requesterId: 'requesterId',
    addresseeId: 'addresseeId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    read: 'read',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const ActivityEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    data: 'data',
    venueId: 'venueId',
    matchId: 'matchId',
    tournamentId: 'tournamentId',
    clanId: 'clanId',
    metadata: 'metadata',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityEventScalarFieldEnum = (typeof ActivityEventScalarFieldEnum)[keyof typeof ActivityEventScalarFieldEnum]


  export const VenueQuestScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    title: 'title',
    description: 'description',
    reward: 'reward',
    rewardDojoCoins: 'rewardDojoCoins',
    active: 'active',
    isActive: 'isActive',
    requirements: 'requirements',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenueQuestScalarFieldEnum = (typeof VenueQuestScalarFieldEnum)[keyof typeof VenueQuestScalarFieldEnum]


  export const GameSessionScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    gameId: 'gameId',
    venueId: 'venueId',
    status: 'status',
    gameType: 'gameType',
    rules: 'rules',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    playerIds: 'playerIds',
    currentPlayerId: 'currentPlayerId',
    ballStates: 'ballStates',
    fouls: 'fouls',
    score: 'score',
    events: 'events',
    totalShots: 'totalShots',
    totalFouls: 'totalFouls',
    totalFrames: 'totalFrames',
    lastUpdated: 'lastUpdated',
    winnerId: 'winnerId',
    data: 'data',
    frameCount: 'frameCount',
    shotCount: 'shotCount',
    foulCount: 'foulCount',
    shots: 'shots',
    statistics: 'statistics',
    aiCommentary: 'aiCommentary',
    matchId: 'matchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameSessionScalarFieldEnum = (typeof GameSessionScalarFieldEnum)[keyof typeof GameSessionScalarFieldEnum]


  export const MarketplaceItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    category: 'category',
    imageUrl: 'imageUrl',
    available: 'available',
    communityItemId: 'communityItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketplaceItemScalarFieldEnum = (typeof MarketplaceItemScalarFieldEnum)[keyof typeof MarketplaceItemScalarFieldEnum]


  export const CommunityCosmeticItemScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    category: 'category',
    designFileUrl: 'designFileUrl',
    previewImageUrl: 'previewImageUrl',
    status: 'status',
    rejectionReason: 'rejectionReason',
    approvedItemId: 'approvedItemId',
    reviewerId: 'reviewerId',
    reviewedAt: 'reviewedAt',
    metadata: 'metadata',
    tags: 'tags',
    likes: 'likes',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityCosmeticItemScalarFieldEnum = (typeof CommunityCosmeticItemScalarFieldEnum)[keyof typeof CommunityCosmeticItemScalarFieldEnum]


  export const CosmeticItemLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cosmeticItemId: 'cosmeticItemId',
    createdAt: 'createdAt'
  };

  export type CosmeticItemLikeScalarFieldEnum = (typeof CosmeticItemLikeScalarFieldEnum)[keyof typeof CosmeticItemLikeScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const ShadowRunScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    type: 'type',
    status: 'status',
    cost: 'cost',
    reward: 'reward',
    completedAt: 'completedAt',
    initiatingClanId: 'initiatingClanId',
    targetVenueId: 'targetVenueId',
    outcome: 'outcome',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShadowRunScalarFieldEnum = (typeof ShadowRunScalarFieldEnum)[keyof typeof ShadowRunScalarFieldEnum]


  export const DojoCheckInScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    venueId: 'venueId',
    createdAt: 'createdAt'
  };

  export type DojoCheckInScalarFieldEnum = (typeof DojoCheckInScalarFieldEnum)[keyof typeof DojoCheckInScalarFieldEnum]


  export const VenueSpecialScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    title: 'title',
    description: 'description',
    type: 'type',
    isActive: 'isActive',
    validUntil: 'validUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenueSpecialScalarFieldEnum = (typeof VenueSpecialScalarFieldEnum)[keyof typeof VenueSpecialScalarFieldEnum]


  export const UserInventoryItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    marketplaceItemId: 'marketplaceItemId',
    createdAt: 'createdAt'
  };

  export type UserInventoryItemScalarFieldEnum = (typeof UserInventoryItemScalarFieldEnum)[keyof typeof UserInventoryItemScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    category: 'category',
    status: 'status',
    priority: 'priority',
    adminNotes: 'adminNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const ContentScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    userId: 'userId',
    title: 'title',
    description: 'description',
    contentType: 'contentType',
    fileUrl: 'fileUrl',
    thumbnailUrl: 'thumbnailUrl',
    status: 'status',
    visibility: 'visibility',
    metadata: 'metadata',
    tags: 'tags',
    likes: 'likes',
    shares: 'shares',
    views: 'views',
    moderatedBy: 'moderatedBy',
    moderatedAt: 'moderatedAt',
    moderationNotes: 'moderationNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const ContentLikeScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    userId: 'userId',
    likes: 'likes',
    createdAt: 'createdAt'
  };

  export type ContentLikeScalarFieldEnum = (typeof ContentLikeScalarFieldEnum)[keyof typeof ContentLikeScalarFieldEnum]


  export const ContentShareScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    userId: 'userId',
    sharedWithId: 'sharedWithId',
    createdAt: 'createdAt'
  };

  export type ContentShareScalarFieldEnum = (typeof ContentShareScalarFieldEnum)[keyof typeof ContentShareScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    deviceId: 'deviceId',
    deviceInfo: 'deviceInfo',
    expiresAt: 'expiresAt',
    isRevoked: 'isRevoked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TableStatus'
   */
  export type EnumTableStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableStatus'>
    


  /**
   * Reference to a field of type 'TableStatus[]'
   */
  export type ListEnumTableStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableStatus[]'>
    


  /**
   * Reference to a field of type 'CheckInMethod'
   */
  export type EnumCheckInMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckInMethod'>
    


  /**
   * Reference to a field of type 'CheckInMethod[]'
   */
  export type ListEnumCheckInMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckInMethod[]'>
    


  /**
   * Reference to a field of type 'ClanRole'
   */
  export type EnumClanRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClanRole'>
    


  /**
   * Reference to a field of type 'ClanRole[]'
   */
  export type ListEnumClanRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClanRole[]'>
    


  /**
   * Reference to a field of type 'TerritoryEventType'
   */
  export type EnumTerritoryEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerritoryEventType'>
    


  /**
   * Reference to a field of type 'TerritoryEventType[]'
   */
  export type ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerritoryEventType[]'>
    


  /**
   * Reference to a field of type 'TournamentStatus'
   */
  export type EnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus'>
    


  /**
   * Reference to a field of type 'TournamentStatus[]'
   */
  export type ListEnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus[]'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'MatchEventType'
   */
  export type EnumMatchEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchEventType'>
    


  /**
   * Reference to a field of type 'MatchEventType[]'
   */
  export type ListEnumMatchEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchEventType[]'>
    


  /**
   * Reference to a field of type 'ChallengeStatus'
   */
  export type EnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus'>
    


  /**
   * Reference to a field of type 'ChallengeStatus[]'
   */
  export type ListEnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus[]'>
    


  /**
   * Reference to a field of type 'TxType'
   */
  export type EnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType'>
    


  /**
   * Reference to a field of type 'TxType[]'
   */
  export type ListEnumTxTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TxType[]'>
    


  /**
   * Reference to a field of type 'FriendshipStatus'
   */
  export type EnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus'>
    


  /**
   * Reference to a field of type 'FriendshipStatus[]'
   */
  export type ListEnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'CosmeticCategory'
   */
  export type EnumCosmeticCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CosmeticCategory'>
    


  /**
   * Reference to a field of type 'CosmeticCategory[]'
   */
  export type ListEnumCosmeticCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CosmeticCategory[]'>
    


  /**
   * Reference to a field of type 'SubmissionStatus'
   */
  export type EnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus'>
    


  /**
   * Reference to a field of type 'SubmissionStatus[]'
   */
  export type ListEnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackCategory'
   */
  export type EnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory'>
    


  /**
   * Reference to a field of type 'FeedbackCategory[]'
   */
  export type ListEnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory[]'>
    


  /**
   * Reference to a field of type 'FeedbackStatus'
   */
  export type EnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus'>
    


  /**
   * Reference to a field of type 'FeedbackStatus[]'
   */
  export type ListEnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackPriority'
   */
  export type EnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority'>
    


  /**
   * Reference to a field of type 'FeedbackPriority[]'
   */
  export type ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'ContentStatus'
   */
  export type EnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus'>
    


  /**
   * Reference to a field of type 'ContentStatus[]'
   */
  export type ListEnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus[]'>
    


  /**
   * Reference to a field of type 'ContentVisibility'
   */
  export type EnumContentVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentVisibility'>
    


  /**
   * Reference to a field of type 'ContentVisibility[]'
   */
  export type ListEnumContentVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentVisibility[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isBanned?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    dojoCoinBalance?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    wallets?: WalletListRelationFilter
    nfts?: UserNFTListRelationFilter
    achievements?: UserAchievementListRelationFilter
    memberships?: ClanMemberListRelationFilter
    territories?: TerritoryListRelationFilter
    checkIns?: CheckInListRelationFilter
    challengesAsChallenger?: ChallengeListRelationFilter
    challengesAsDefender?: ChallengeListRelationFilter
    ledClans?: ClanListRelationFilter
    matchesAsPlayerA?: MatchListRelationFilter
    matchesAsPlayerB?: MatchListRelationFilter
    tournaments?: TournamentParticipantListRelationFilter
    transactions?: TransactionListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    venues?: VenueListRelationFilter
    friendshipsAsRequester?: FriendshipListRelationFilter
    friendshipsAsAddressee?: FriendshipListRelationFilter
    sentMessages?: DirectMessageListRelationFilter
    receivedMessages?: DirectMessageListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
    gameSessions?: GameSessionListRelationFilter
    shadowRuns?: ShadowRunListRelationFilter
    dojoCheckIns?: DojoCheckInListRelationFilter
    inventoryItems?: UserInventoryItemListRelationFilter
    feedback?: FeedbackListRelationFilter
    resolvedFeedback?: FeedbackListRelationFilter
    content?: ContentListRelationFilter
    moderatedContent?: ContentListRelationFilter
    contentLikes?: ContentLikeListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    sharedContent?: ContentShareListRelationFilter
    receivedShares?: ContentShareListRelationFilter
    communityItems?: CommunityCosmeticItemListRelationFilter
    reviewedItems?: CommunityCosmeticItemListRelationFilter
    cosmeticLikes?: CosmeticItemLikeListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isBanned?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dojoCoinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    settings?: UserSettingsOrderByWithRelationInput
    wallets?: WalletOrderByRelationAggregateInput
    nfts?: UserNFTOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    memberships?: ClanMemberOrderByRelationAggregateInput
    territories?: TerritoryOrderByRelationAggregateInput
    checkIns?: CheckInOrderByRelationAggregateInput
    challengesAsChallenger?: ChallengeOrderByRelationAggregateInput
    challengesAsDefender?: ChallengeOrderByRelationAggregateInput
    ledClans?: ClanOrderByRelationAggregateInput
    matchesAsPlayerA?: MatchOrderByRelationAggregateInput
    matchesAsPlayerB?: MatchOrderByRelationAggregateInput
    tournaments?: TournamentParticipantOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    venues?: VenueOrderByRelationAggregateInput
    friendshipsAsRequester?: FriendshipOrderByRelationAggregateInput
    friendshipsAsAddressee?: FriendshipOrderByRelationAggregateInput
    sentMessages?: DirectMessageOrderByRelationAggregateInput
    receivedMessages?: DirectMessageOrderByRelationAggregateInput
    activityEvents?: ActivityEventOrderByRelationAggregateInput
    gameSessions?: GameSessionOrderByRelationAggregateInput
    shadowRuns?: ShadowRunOrderByRelationAggregateInput
    dojoCheckIns?: DojoCheckInOrderByRelationAggregateInput
    inventoryItems?: UserInventoryItemOrderByRelationAggregateInput
    feedback?: FeedbackOrderByRelationAggregateInput
    resolvedFeedback?: FeedbackOrderByRelationAggregateInput
    content?: ContentOrderByRelationAggregateInput
    moderatedContent?: ContentOrderByRelationAggregateInput
    contentLikes?: ContentLikeOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    sharedContent?: ContentShareOrderByRelationAggregateInput
    receivedShares?: ContentShareOrderByRelationAggregateInput
    communityItems?: CommunityCosmeticItemOrderByRelationAggregateInput
    reviewedItems?: CommunityCosmeticItemOrderByRelationAggregateInput
    cosmeticLikes?: CosmeticItemLikeOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isBanned?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    dojoCoinBalance?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    settings?: XOR<UserSettingsNullableRelationFilter, UserSettingsWhereInput> | null
    wallets?: WalletListRelationFilter
    nfts?: UserNFTListRelationFilter
    achievements?: UserAchievementListRelationFilter
    memberships?: ClanMemberListRelationFilter
    territories?: TerritoryListRelationFilter
    checkIns?: CheckInListRelationFilter
    challengesAsChallenger?: ChallengeListRelationFilter
    challengesAsDefender?: ChallengeListRelationFilter
    ledClans?: ClanListRelationFilter
    matchesAsPlayerA?: MatchListRelationFilter
    matchesAsPlayerB?: MatchListRelationFilter
    tournaments?: TournamentParticipantListRelationFilter
    transactions?: TransactionListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    venues?: VenueListRelationFilter
    friendshipsAsRequester?: FriendshipListRelationFilter
    friendshipsAsAddressee?: FriendshipListRelationFilter
    sentMessages?: DirectMessageListRelationFilter
    receivedMessages?: DirectMessageListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
    gameSessions?: GameSessionListRelationFilter
    shadowRuns?: ShadowRunListRelationFilter
    dojoCheckIns?: DojoCheckInListRelationFilter
    inventoryItems?: UserInventoryItemListRelationFilter
    feedback?: FeedbackListRelationFilter
    resolvedFeedback?: FeedbackListRelationFilter
    content?: ContentListRelationFilter
    moderatedContent?: ContentListRelationFilter
    contentLikes?: ContentLikeListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    sharedContent?: ContentShareListRelationFilter
    receivedShares?: ContentShareListRelationFilter
    communityItems?: CommunityCosmeticItemListRelationFilter
    reviewedItems?: CommunityCosmeticItemListRelationFilter
    cosmeticLikes?: CosmeticItemLikeListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isBanned?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dojoCoinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    dojoCoinBalance?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    displayName?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    skillRating?: IntFilter<"Profile"> | number
    clanTitle?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    skillRating?: SortOrder
    clanTitle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    displayName?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    skillRating?: IntFilter<"Profile"> | number
    clanTitle?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    skillRating?: SortOrder
    clanTitle?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    displayName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    skillRating?: IntWithAggregatesFilter<"Profile"> | number
    clanTitle?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    pushNotifications?: BoolFilter<"UserSettings"> | boolean
    darkMode?: BoolFilter<"UserSettings"> | boolean
    language?: StringFilter<"UserSettings"> | string
    timezone?: StringFilter<"UserSettings"> | string
    privacySettings?: StringFilter<"UserSettings"> | string
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    emailNotifications?: BoolFilter<"UserSettings"> | boolean
    pushNotifications?: BoolFilter<"UserSettings"> | boolean
    darkMode?: BoolFilter<"UserSettings"> | boolean
    language?: StringFilter<"UserSettings"> | string
    timezone?: StringFilter<"UserSettings"> | string
    privacySettings?: StringFilter<"UserSettings"> | string
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    emailNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    pushNotifications?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    darkMode?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    language?: StringWithAggregatesFilter<"UserSettings"> | string
    timezone?: StringWithAggregatesFilter<"UserSettings"> | string
    privacySettings?: StringWithAggregatesFilter<"UserSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: StringFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    description?: StringNullableFilter<"Venue"> | string | null
    lat?: FloatFilter<"Venue"> | number
    lng?: FloatFilter<"Venue"> | number
    address?: StringNullableFilter<"Venue"> | string | null
    ownerId?: StringNullableFilter<"Venue"> | string | null
    controllingClanId?: StringNullableFilter<"Venue"> | string | null
    incomeModifier?: FloatFilter<"Venue"> | number
    defenseLevel?: IntFilter<"Venue"> | number
    status?: StringFilter<"Venue"> | string
    photos?: StringFilter<"Venue"> | string
    rating?: FloatFilter<"Venue"> | number
    features?: StringFilter<"Venue"> | string
    tables?: IntFilter<"Venue"> | number
    reviews?: StringFilter<"Venue"> | string
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    controllingClan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
    tablesList?: TableListRelationFilter
    tournaments?: TournamentListRelationFilter
    territories?: TerritoryListRelationFilter
    checkIns?: CheckInListRelationFilter
    challenges?: ChallengeListRelationFilter
    matches?: MatchListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
    quests?: VenueQuestListRelationFilter
    specials?: VenueSpecialListRelationFilter
    dojoCheckIns?: DojoCheckInListRelationFilter
    shadowRuns?: ShadowRunListRelationFilter
    gameSessions?: GameSessionListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    controllingClanId?: SortOrderInput | SortOrder
    incomeModifier?: SortOrder
    defenseLevel?: SortOrder
    status?: SortOrder
    photos?: SortOrder
    rating?: SortOrder
    features?: SortOrder
    tables?: SortOrder
    reviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    controllingClan?: ClanOrderByWithRelationInput
    tablesList?: TableOrderByRelationAggregateInput
    tournaments?: TournamentOrderByRelationAggregateInput
    territories?: TerritoryOrderByRelationAggregateInput
    checkIns?: CheckInOrderByRelationAggregateInput
    challenges?: ChallengeOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
    activityEvents?: ActivityEventOrderByRelationAggregateInput
    quests?: VenueQuestOrderByRelationAggregateInput
    specials?: VenueSpecialOrderByRelationAggregateInput
    dojoCheckIns?: DojoCheckInOrderByRelationAggregateInput
    shadowRuns?: ShadowRunOrderByRelationAggregateInput
    gameSessions?: GameSessionOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    name?: StringFilter<"Venue"> | string
    description?: StringNullableFilter<"Venue"> | string | null
    lat?: FloatFilter<"Venue"> | number
    lng?: FloatFilter<"Venue"> | number
    address?: StringNullableFilter<"Venue"> | string | null
    ownerId?: StringNullableFilter<"Venue"> | string | null
    controllingClanId?: StringNullableFilter<"Venue"> | string | null
    incomeModifier?: FloatFilter<"Venue"> | number
    defenseLevel?: IntFilter<"Venue"> | number
    status?: StringFilter<"Venue"> | string
    photos?: StringFilter<"Venue"> | string
    rating?: FloatFilter<"Venue"> | number
    features?: StringFilter<"Venue"> | string
    tables?: IntFilter<"Venue"> | number
    reviews?: StringFilter<"Venue"> | string
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    controllingClan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
    tablesList?: TableListRelationFilter
    tournaments?: TournamentListRelationFilter
    territories?: TerritoryListRelationFilter
    checkIns?: CheckInListRelationFilter
    challenges?: ChallengeListRelationFilter
    matches?: MatchListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
    quests?: VenueQuestListRelationFilter
    specials?: VenueSpecialListRelationFilter
    dojoCheckIns?: DojoCheckInListRelationFilter
    shadowRuns?: ShadowRunListRelationFilter
    gameSessions?: GameSessionListRelationFilter
  }, "id">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    controllingClanId?: SortOrderInput | SortOrder
    incomeModifier?: SortOrder
    defenseLevel?: SortOrder
    status?: SortOrder
    photos?: SortOrder
    rating?: SortOrder
    features?: SortOrder
    tables?: SortOrder
    reviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Venue"> | string
    name?: StringWithAggregatesFilter<"Venue"> | string
    description?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    lat?: FloatWithAggregatesFilter<"Venue"> | number
    lng?: FloatWithAggregatesFilter<"Venue"> | number
    address?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    controllingClanId?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    incomeModifier?: FloatWithAggregatesFilter<"Venue"> | number
    defenseLevel?: IntWithAggregatesFilter<"Venue"> | number
    status?: StringWithAggregatesFilter<"Venue"> | string
    photos?: StringWithAggregatesFilter<"Venue"> | string
    rating?: FloatWithAggregatesFilter<"Venue"> | number
    features?: StringWithAggregatesFilter<"Venue"> | string
    tables?: IntWithAggregatesFilter<"Venue"> | number
    reviews?: StringWithAggregatesFilter<"Venue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    id?: StringFilter<"Table"> | string
    venueId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    status?: EnumTableStatusFilter<"Table"> | $Enums.TableStatus
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    matches?: MatchListRelationFilter
  }

  export type TableOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venue?: VenueOrderByWithRelationInput
    matches?: MatchOrderByRelationAggregateInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    venueId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    status?: EnumTableStatusFilter<"Table"> | $Enums.TableStatus
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    matches?: MatchListRelationFilter
  }, "id">

  export type TableOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TableCountOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Table"> | string
    venueId?: StringWithAggregatesFilter<"Table"> | string
    name?: StringWithAggregatesFilter<"Table"> | string
    status?: EnumTableStatusWithAggregatesFilter<"Table"> | $Enums.TableStatus
    createdAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
  }

  export type CheckInWhereInput = {
    AND?: CheckInWhereInput | CheckInWhereInput[]
    OR?: CheckInWhereInput[]
    NOT?: CheckInWhereInput | CheckInWhereInput[]
    id?: StringFilter<"CheckIn"> | string
    userId?: StringFilter<"CheckIn"> | string
    venueId?: StringFilter<"CheckIn"> | string
    via?: EnumCheckInMethodFilter<"CheckIn"> | $Enums.CheckInMethod
    createdAt?: DateTimeFilter<"CheckIn"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type CheckInOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type CheckInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckInWhereInput | CheckInWhereInput[]
    OR?: CheckInWhereInput[]
    NOT?: CheckInWhereInput | CheckInWhereInput[]
    userId?: StringFilter<"CheckIn"> | string
    venueId?: StringFilter<"CheckIn"> | string
    via?: EnumCheckInMethodFilter<"CheckIn"> | $Enums.CheckInMethod
    createdAt?: DateTimeFilter<"CheckIn"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type CheckInOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
    _count?: CheckInCountOrderByAggregateInput
    _max?: CheckInMaxOrderByAggregateInput
    _min?: CheckInMinOrderByAggregateInput
  }

  export type CheckInScalarWhereWithAggregatesInput = {
    AND?: CheckInScalarWhereWithAggregatesInput | CheckInScalarWhereWithAggregatesInput[]
    OR?: CheckInScalarWhereWithAggregatesInput[]
    NOT?: CheckInScalarWhereWithAggregatesInput | CheckInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheckIn"> | string
    userId?: StringWithAggregatesFilter<"CheckIn"> | string
    venueId?: StringWithAggregatesFilter<"CheckIn"> | string
    via?: EnumCheckInMethodWithAggregatesFilter<"CheckIn"> | $Enums.CheckInMethod
    createdAt?: DateTimeWithAggregatesFilter<"CheckIn"> | Date | string
  }

  export type ClanWhereInput = {
    AND?: ClanWhereInput | ClanWhereInput[]
    OR?: ClanWhereInput[]
    NOT?: ClanWhereInput | ClanWhereInput[]
    id?: StringFilter<"Clan"> | string
    name?: StringFilter<"Clan"> | string
    description?: StringNullableFilter<"Clan"> | string | null
    tag?: StringFilter<"Clan"> | string
    leaderId?: StringFilter<"Clan"> | string
    maxMembers?: IntFilter<"Clan"> | number
    dojoCoinBalance?: IntFilter<"Clan"> | number
    seasonalPoints?: IntFilter<"Clan"> | number
    bannerUrl?: StringNullableFilter<"Clan"> | string | null
    color?: StringFilter<"Clan"> | string
    level?: IntFilter<"Clan"> | number
    experience?: IntFilter<"Clan"> | number
    reputation?: IntFilter<"Clan"> | number
    isActive?: BoolFilter<"Clan"> | boolean
    createdAt?: DateTimeFilter<"Clan"> | Date | string
    updatedAt?: DateTimeFilter<"Clan"> | Date | string
    leader?: XOR<UserRelationFilter, UserWhereInput>
    members?: ClanMemberListRelationFilter
    territories?: TerritoryListRelationFilter
    controlledVenues?: VenueListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
    shadowRuns?: ShadowRunListRelationFilter
  }

  export type ClanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tag?: SortOrder
    leaderId?: SortOrder
    maxMembers?: SortOrder
    dojoCoinBalance?: SortOrder
    seasonalPoints?: SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    color?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    reputation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leader?: UserOrderByWithRelationInput
    members?: ClanMemberOrderByRelationAggregateInput
    territories?: TerritoryOrderByRelationAggregateInput
    controlledVenues?: VenueOrderByRelationAggregateInput
    activityEvents?: ActivityEventOrderByRelationAggregateInput
    shadowRuns?: ShadowRunOrderByRelationAggregateInput
  }

  export type ClanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    tag?: string
    AND?: ClanWhereInput | ClanWhereInput[]
    OR?: ClanWhereInput[]
    NOT?: ClanWhereInput | ClanWhereInput[]
    description?: StringNullableFilter<"Clan"> | string | null
    leaderId?: StringFilter<"Clan"> | string
    maxMembers?: IntFilter<"Clan"> | number
    dojoCoinBalance?: IntFilter<"Clan"> | number
    seasonalPoints?: IntFilter<"Clan"> | number
    bannerUrl?: StringNullableFilter<"Clan"> | string | null
    color?: StringFilter<"Clan"> | string
    level?: IntFilter<"Clan"> | number
    experience?: IntFilter<"Clan"> | number
    reputation?: IntFilter<"Clan"> | number
    isActive?: BoolFilter<"Clan"> | boolean
    createdAt?: DateTimeFilter<"Clan"> | Date | string
    updatedAt?: DateTimeFilter<"Clan"> | Date | string
    leader?: XOR<UserRelationFilter, UserWhereInput>
    members?: ClanMemberListRelationFilter
    territories?: TerritoryListRelationFilter
    controlledVenues?: VenueListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
    shadowRuns?: ShadowRunListRelationFilter
  }, "id" | "name" | "tag">

  export type ClanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tag?: SortOrder
    leaderId?: SortOrder
    maxMembers?: SortOrder
    dojoCoinBalance?: SortOrder
    seasonalPoints?: SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    color?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    reputation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClanCountOrderByAggregateInput
    _avg?: ClanAvgOrderByAggregateInput
    _max?: ClanMaxOrderByAggregateInput
    _min?: ClanMinOrderByAggregateInput
    _sum?: ClanSumOrderByAggregateInput
  }

  export type ClanScalarWhereWithAggregatesInput = {
    AND?: ClanScalarWhereWithAggregatesInput | ClanScalarWhereWithAggregatesInput[]
    OR?: ClanScalarWhereWithAggregatesInput[]
    NOT?: ClanScalarWhereWithAggregatesInput | ClanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clan"> | string
    name?: StringWithAggregatesFilter<"Clan"> | string
    description?: StringNullableWithAggregatesFilter<"Clan"> | string | null
    tag?: StringWithAggregatesFilter<"Clan"> | string
    leaderId?: StringWithAggregatesFilter<"Clan"> | string
    maxMembers?: IntWithAggregatesFilter<"Clan"> | number
    dojoCoinBalance?: IntWithAggregatesFilter<"Clan"> | number
    seasonalPoints?: IntWithAggregatesFilter<"Clan"> | number
    bannerUrl?: StringNullableWithAggregatesFilter<"Clan"> | string | null
    color?: StringWithAggregatesFilter<"Clan"> | string
    level?: IntWithAggregatesFilter<"Clan"> | number
    experience?: IntWithAggregatesFilter<"Clan"> | number
    reputation?: IntWithAggregatesFilter<"Clan"> | number
    isActive?: BoolWithAggregatesFilter<"Clan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Clan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clan"> | Date | string
  }

  export type ClanMemberWhereInput = {
    AND?: ClanMemberWhereInput | ClanMemberWhereInput[]
    OR?: ClanMemberWhereInput[]
    NOT?: ClanMemberWhereInput | ClanMemberWhereInput[]
    id?: StringFilter<"ClanMember"> | string
    clanId?: StringFilter<"ClanMember"> | string
    userId?: StringFilter<"ClanMember"> | string
    role?: EnumClanRoleFilter<"ClanMember"> | $Enums.ClanRole
    joinedAt?: DateTimeFilter<"ClanMember"> | Date | string
    clan?: XOR<ClanRelationFilter, ClanWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClanMemberOrderByWithRelationInput = {
    id?: SortOrder
    clanId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    clan?: ClanOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ClanMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    clanId_userId?: ClanMemberClanId_userIdCompoundUniqueInput
    AND?: ClanMemberWhereInput | ClanMemberWhereInput[]
    OR?: ClanMemberWhereInput[]
    NOT?: ClanMemberWhereInput | ClanMemberWhereInput[]
    clanId?: StringFilter<"ClanMember"> | string
    role?: EnumClanRoleFilter<"ClanMember"> | $Enums.ClanRole
    joinedAt?: DateTimeFilter<"ClanMember"> | Date | string
    clan?: XOR<ClanRelationFilter, ClanWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "clanId_userId">

  export type ClanMemberOrderByWithAggregationInput = {
    id?: SortOrder
    clanId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: ClanMemberCountOrderByAggregateInput
    _max?: ClanMemberMaxOrderByAggregateInput
    _min?: ClanMemberMinOrderByAggregateInput
  }

  export type ClanMemberScalarWhereWithAggregatesInput = {
    AND?: ClanMemberScalarWhereWithAggregatesInput | ClanMemberScalarWhereWithAggregatesInput[]
    OR?: ClanMemberScalarWhereWithAggregatesInput[]
    NOT?: ClanMemberScalarWhereWithAggregatesInput | ClanMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClanMember"> | string
    clanId?: StringWithAggregatesFilter<"ClanMember"> | string
    userId?: StringWithAggregatesFilter<"ClanMember"> | string
    role?: EnumClanRoleWithAggregatesFilter<"ClanMember"> | $Enums.ClanRole
    joinedAt?: DateTimeWithAggregatesFilter<"ClanMember"> | Date | string
  }

  export type TerritoryWhereInput = {
    AND?: TerritoryWhereInput | TerritoryWhereInput[]
    OR?: TerritoryWhereInput[]
    NOT?: TerritoryWhereInput | TerritoryWhereInput[]
    id?: StringFilter<"Territory"> | string
    venueId?: StringFilter<"Territory"> | string
    name?: StringFilter<"Territory"> | string
    ownerId?: StringNullableFilter<"Territory"> | string | null
    clanId?: StringNullableFilter<"Territory"> | string | null
    level?: IntFilter<"Territory"> | number
    defenseScore?: IntFilter<"Territory"> | number
    resources?: StringFilter<"Territory"> | string
    strategicValue?: IntFilter<"Territory"> | number
    resourceRate?: StringFilter<"Territory"> | string
    lastTickAt?: DateTimeNullableFilter<"Territory"> | Date | string | null
    createdAt?: DateTimeFilter<"Territory"> | Date | string
    updatedAt?: DateTimeFilter<"Territory"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    clan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
    events?: TerritoryEventListRelationFilter
  }

  export type TerritoryOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    clanId?: SortOrderInput | SortOrder
    level?: SortOrder
    defenseScore?: SortOrder
    resources?: SortOrder
    strategicValue?: SortOrder
    resourceRate?: SortOrder
    lastTickAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venue?: VenueOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    clan?: ClanOrderByWithRelationInput
    events?: TerritoryEventOrderByRelationAggregateInput
  }

  export type TerritoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TerritoryWhereInput | TerritoryWhereInput[]
    OR?: TerritoryWhereInput[]
    NOT?: TerritoryWhereInput | TerritoryWhereInput[]
    venueId?: StringFilter<"Territory"> | string
    name?: StringFilter<"Territory"> | string
    ownerId?: StringNullableFilter<"Territory"> | string | null
    clanId?: StringNullableFilter<"Territory"> | string | null
    level?: IntFilter<"Territory"> | number
    defenseScore?: IntFilter<"Territory"> | number
    resources?: StringFilter<"Territory"> | string
    strategicValue?: IntFilter<"Territory"> | number
    resourceRate?: StringFilter<"Territory"> | string
    lastTickAt?: DateTimeNullableFilter<"Territory"> | Date | string | null
    createdAt?: DateTimeFilter<"Territory"> | Date | string
    updatedAt?: DateTimeFilter<"Territory"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    clan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
    events?: TerritoryEventListRelationFilter
  }, "id">

  export type TerritoryOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    clanId?: SortOrderInput | SortOrder
    level?: SortOrder
    defenseScore?: SortOrder
    resources?: SortOrder
    strategicValue?: SortOrder
    resourceRate?: SortOrder
    lastTickAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TerritoryCountOrderByAggregateInput
    _avg?: TerritoryAvgOrderByAggregateInput
    _max?: TerritoryMaxOrderByAggregateInput
    _min?: TerritoryMinOrderByAggregateInput
    _sum?: TerritorySumOrderByAggregateInput
  }

  export type TerritoryScalarWhereWithAggregatesInput = {
    AND?: TerritoryScalarWhereWithAggregatesInput | TerritoryScalarWhereWithAggregatesInput[]
    OR?: TerritoryScalarWhereWithAggregatesInput[]
    NOT?: TerritoryScalarWhereWithAggregatesInput | TerritoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Territory"> | string
    venueId?: StringWithAggregatesFilter<"Territory"> | string
    name?: StringWithAggregatesFilter<"Territory"> | string
    ownerId?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    clanId?: StringNullableWithAggregatesFilter<"Territory"> | string | null
    level?: IntWithAggregatesFilter<"Territory"> | number
    defenseScore?: IntWithAggregatesFilter<"Territory"> | number
    resources?: StringWithAggregatesFilter<"Territory"> | string
    strategicValue?: IntWithAggregatesFilter<"Territory"> | number
    resourceRate?: StringWithAggregatesFilter<"Territory"> | string
    lastTickAt?: DateTimeNullableWithAggregatesFilter<"Territory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Territory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Territory"> | Date | string
  }

  export type TerritoryEventWhereInput = {
    AND?: TerritoryEventWhereInput | TerritoryEventWhereInput[]
    OR?: TerritoryEventWhereInput[]
    NOT?: TerritoryEventWhereInput | TerritoryEventWhereInput[]
    id?: StringFilter<"TerritoryEvent"> | string
    territoryId?: StringFilter<"TerritoryEvent"> | string
    type?: EnumTerritoryEventTypeFilter<"TerritoryEvent"> | $Enums.TerritoryEventType
    metadata?: StringFilter<"TerritoryEvent"> | string
    createdAt?: DateTimeFilter<"TerritoryEvent"> | Date | string
    territory?: XOR<TerritoryRelationFilter, TerritoryWhereInput>
  }

  export type TerritoryEventOrderByWithRelationInput = {
    id?: SortOrder
    territoryId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    territory?: TerritoryOrderByWithRelationInput
  }

  export type TerritoryEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TerritoryEventWhereInput | TerritoryEventWhereInput[]
    OR?: TerritoryEventWhereInput[]
    NOT?: TerritoryEventWhereInput | TerritoryEventWhereInput[]
    territoryId?: StringFilter<"TerritoryEvent"> | string
    type?: EnumTerritoryEventTypeFilter<"TerritoryEvent"> | $Enums.TerritoryEventType
    metadata?: StringFilter<"TerritoryEvent"> | string
    createdAt?: DateTimeFilter<"TerritoryEvent"> | Date | string
    territory?: XOR<TerritoryRelationFilter, TerritoryWhereInput>
  }, "id">

  export type TerritoryEventOrderByWithAggregationInput = {
    id?: SortOrder
    territoryId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: TerritoryEventCountOrderByAggregateInput
    _max?: TerritoryEventMaxOrderByAggregateInput
    _min?: TerritoryEventMinOrderByAggregateInput
  }

  export type TerritoryEventScalarWhereWithAggregatesInput = {
    AND?: TerritoryEventScalarWhereWithAggregatesInput | TerritoryEventScalarWhereWithAggregatesInput[]
    OR?: TerritoryEventScalarWhereWithAggregatesInput[]
    NOT?: TerritoryEventScalarWhereWithAggregatesInput | TerritoryEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TerritoryEvent"> | string
    territoryId?: StringWithAggregatesFilter<"TerritoryEvent"> | string
    type?: EnumTerritoryEventTypeWithAggregatesFilter<"TerritoryEvent"> | $Enums.TerritoryEventType
    metadata?: StringWithAggregatesFilter<"TerritoryEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TerritoryEvent"> | Date | string
  }

  export type TournamentWhereInput = {
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    id?: StringFilter<"Tournament"> | string
    venueId?: StringNullableFilter<"Tournament"> | string | null
    name?: StringFilter<"Tournament"> | string
    status?: EnumTournamentStatusFilter<"Tournament"> | $Enums.TournamentStatus
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    endTime?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    isSponsored?: BoolFilter<"Tournament"> | boolean
    sponsoredBy?: StringNullableFilter<"Tournament"> | string | null
    startDate?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    sponsorBannerUrl?: StringNullableFilter<"Tournament"> | string | null
    maxPlayers?: IntFilter<"Tournament"> | number
    entryFee?: IntFilter<"Tournament"> | number
    rewards?: StringNullableFilter<"Tournament"> | string | null
    prizePool?: IntFilter<"Tournament"> | number
    format?: StringFilter<"Tournament"> | string
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeFilter<"Tournament"> | Date | string
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
    participants?: TournamentParticipantListRelationFilter
    matches?: MatchListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
  }

  export type TournamentOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isSponsored?: SortOrder
    sponsoredBy?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    sponsorBannerUrl?: SortOrderInput | SortOrder
    maxPlayers?: SortOrder
    entryFee?: SortOrder
    rewards?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venue?: VenueOrderByWithRelationInput
    participants?: TournamentParticipantOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
    activityEvents?: ActivityEventOrderByRelationAggregateInput
  }

  export type TournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    venueId?: StringNullableFilter<"Tournament"> | string | null
    name?: StringFilter<"Tournament"> | string
    status?: EnumTournamentStatusFilter<"Tournament"> | $Enums.TournamentStatus
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    endTime?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    isSponsored?: BoolFilter<"Tournament"> | boolean
    sponsoredBy?: StringNullableFilter<"Tournament"> | string | null
    startDate?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    sponsorBannerUrl?: StringNullableFilter<"Tournament"> | string | null
    maxPlayers?: IntFilter<"Tournament"> | number
    entryFee?: IntFilter<"Tournament"> | number
    rewards?: StringNullableFilter<"Tournament"> | string | null
    prizePool?: IntFilter<"Tournament"> | number
    format?: StringFilter<"Tournament"> | string
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeFilter<"Tournament"> | Date | string
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
    participants?: TournamentParticipantListRelationFilter
    matches?: MatchListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
  }, "id">

  export type TournamentOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    isSponsored?: SortOrder
    sponsoredBy?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    sponsorBannerUrl?: SortOrderInput | SortOrder
    maxPlayers?: SortOrder
    entryFee?: SortOrder
    rewards?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TournamentCountOrderByAggregateInput
    _avg?: TournamentAvgOrderByAggregateInput
    _max?: TournamentMaxOrderByAggregateInput
    _min?: TournamentMinOrderByAggregateInput
    _sum?: TournamentSumOrderByAggregateInput
  }

  export type TournamentScalarWhereWithAggregatesInput = {
    AND?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    OR?: TournamentScalarWhereWithAggregatesInput[]
    NOT?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tournament"> | string
    venueId?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    name?: StringWithAggregatesFilter<"Tournament"> | string
    status?: EnumTournamentStatusWithAggregatesFilter<"Tournament"> | $Enums.TournamentStatus
    startTime?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Tournament"> | Date | string | null
    isSponsored?: BoolWithAggregatesFilter<"Tournament"> | boolean
    sponsoredBy?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Tournament"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Tournament"> | Date | string | null
    sponsorBannerUrl?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    maxPlayers?: IntWithAggregatesFilter<"Tournament"> | number
    entryFee?: IntWithAggregatesFilter<"Tournament"> | number
    rewards?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    prizePool?: IntWithAggregatesFilter<"Tournament"> | number
    format?: StringWithAggregatesFilter<"Tournament"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
  }

  export type TournamentParticipantWhereInput = {
    AND?: TournamentParticipantWhereInput | TournamentParticipantWhereInput[]
    OR?: TournamentParticipantWhereInput[]
    NOT?: TournamentParticipantWhereInput | TournamentParticipantWhereInput[]
    id?: StringFilter<"TournamentParticipant"> | string
    tournamentId?: StringFilter<"TournamentParticipant"> | string
    userId?: StringFilter<"TournamentParticipant"> | string
    seed?: IntNullableFilter<"TournamentParticipant"> | number | null
    finalRank?: IntNullableFilter<"TournamentParticipant"> | number | null
    createdAt?: DateTimeFilter<"TournamentParticipant"> | Date | string
    tournament?: XOR<TournamentRelationFilter, TournamentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TournamentParticipantOrderByWithRelationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    seed?: SortOrderInput | SortOrder
    finalRank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tournament?: TournamentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TournamentParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournamentId_userId?: TournamentParticipantTournamentIdUserIdCompoundUniqueInput
    AND?: TournamentParticipantWhereInput | TournamentParticipantWhereInput[]
    OR?: TournamentParticipantWhereInput[]
    NOT?: TournamentParticipantWhereInput | TournamentParticipantWhereInput[]
    tournamentId?: StringFilter<"TournamentParticipant"> | string
    userId?: StringFilter<"TournamentParticipant"> | string
    seed?: IntNullableFilter<"TournamentParticipant"> | number | null
    finalRank?: IntNullableFilter<"TournamentParticipant"> | number | null
    createdAt?: DateTimeFilter<"TournamentParticipant"> | Date | string
    tournament?: XOR<TournamentRelationFilter, TournamentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "tournamentId_userId">

  export type TournamentParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    seed?: SortOrderInput | SortOrder
    finalRank?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TournamentParticipantCountOrderByAggregateInput
    _avg?: TournamentParticipantAvgOrderByAggregateInput
    _max?: TournamentParticipantMaxOrderByAggregateInput
    _min?: TournamentParticipantMinOrderByAggregateInput
    _sum?: TournamentParticipantSumOrderByAggregateInput
  }

  export type TournamentParticipantScalarWhereWithAggregatesInput = {
    AND?: TournamentParticipantScalarWhereWithAggregatesInput | TournamentParticipantScalarWhereWithAggregatesInput[]
    OR?: TournamentParticipantScalarWhereWithAggregatesInput[]
    NOT?: TournamentParticipantScalarWhereWithAggregatesInput | TournamentParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TournamentParticipant"> | string
    tournamentId?: StringWithAggregatesFilter<"TournamentParticipant"> | string
    userId?: StringWithAggregatesFilter<"TournamentParticipant"> | string
    seed?: IntNullableWithAggregatesFilter<"TournamentParticipant"> | number | null
    finalRank?: IntNullableWithAggregatesFilter<"TournamentParticipant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TournamentParticipant"> | Date | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: StringFilter<"Match"> | string
    tournamentId?: StringNullableFilter<"Match"> | string | null
    venueId?: StringNullableFilter<"Match"> | string | null
    tableId?: StringNullableFilter<"Match"> | string | null
    playerAId?: StringFilter<"Match"> | string
    playerBId?: StringFilter<"Match"> | string
    winnerId?: StringNullableFilter<"Match"> | string | null
    loserId?: StringNullableFilter<"Match"> | string | null
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    scoreA?: IntFilter<"Match"> | number
    scoreB?: IntFilter<"Match"> | number
    round?: IntNullableFilter<"Match"> | number | null
    wager?: IntFilter<"Match"> | number
    aiAnalysisJson?: StringNullableFilter<"Match"> | string | null
    startedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    tournament?: XOR<TournamentNullableRelationFilter, TournamentWhereInput> | null
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
    table?: XOR<TableNullableRelationFilter, TableWhereInput> | null
    playerA?: XOR<UserRelationFilter, UserWhereInput>
    playerB?: XOR<UserRelationFilter, UserWhereInput>
    events?: MatchEventListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    venueId?: SortOrderInput | SortOrder
    tableId?: SortOrderInput | SortOrder
    playerAId?: SortOrder
    playerBId?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    loserId?: SortOrderInput | SortOrder
    status?: SortOrder
    scoreA?: SortOrder
    scoreB?: SortOrder
    round?: SortOrderInput | SortOrder
    wager?: SortOrder
    aiAnalysisJson?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tournament?: TournamentOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    table?: TableOrderByWithRelationInput
    playerA?: UserOrderByWithRelationInput
    playerB?: UserOrderByWithRelationInput
    events?: MatchEventOrderByRelationAggregateInput
    activityEvents?: ActivityEventOrderByRelationAggregateInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    tournamentId?: StringNullableFilter<"Match"> | string | null
    venueId?: StringNullableFilter<"Match"> | string | null
    tableId?: StringNullableFilter<"Match"> | string | null
    playerAId?: StringFilter<"Match"> | string
    playerBId?: StringFilter<"Match"> | string
    winnerId?: StringNullableFilter<"Match"> | string | null
    loserId?: StringNullableFilter<"Match"> | string | null
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    scoreA?: IntFilter<"Match"> | number
    scoreB?: IntFilter<"Match"> | number
    round?: IntNullableFilter<"Match"> | number | null
    wager?: IntFilter<"Match"> | number
    aiAnalysisJson?: StringNullableFilter<"Match"> | string | null
    startedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    tournament?: XOR<TournamentNullableRelationFilter, TournamentWhereInput> | null
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
    table?: XOR<TableNullableRelationFilter, TableWhereInput> | null
    playerA?: XOR<UserRelationFilter, UserWhereInput>
    playerB?: XOR<UserRelationFilter, UserWhereInput>
    events?: MatchEventListRelationFilter
    activityEvents?: ActivityEventListRelationFilter
  }, "id">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    venueId?: SortOrderInput | SortOrder
    tableId?: SortOrderInput | SortOrder
    playerAId?: SortOrder
    playerBId?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    loserId?: SortOrderInput | SortOrder
    status?: SortOrder
    scoreA?: SortOrder
    scoreB?: SortOrder
    round?: SortOrderInput | SortOrder
    wager?: SortOrder
    aiAnalysisJson?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Match"> | string
    tournamentId?: StringNullableWithAggregatesFilter<"Match"> | string | null
    venueId?: StringNullableWithAggregatesFilter<"Match"> | string | null
    tableId?: StringNullableWithAggregatesFilter<"Match"> | string | null
    playerAId?: StringWithAggregatesFilter<"Match"> | string
    playerBId?: StringWithAggregatesFilter<"Match"> | string
    winnerId?: StringNullableWithAggregatesFilter<"Match"> | string | null
    loserId?: StringNullableWithAggregatesFilter<"Match"> | string | null
    status?: EnumMatchStatusWithAggregatesFilter<"Match"> | $Enums.MatchStatus
    scoreA?: IntWithAggregatesFilter<"Match"> | number
    scoreB?: IntWithAggregatesFilter<"Match"> | number
    round?: IntNullableWithAggregatesFilter<"Match"> | number | null
    wager?: IntWithAggregatesFilter<"Match"> | number
    aiAnalysisJson?: StringNullableWithAggregatesFilter<"Match"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Match"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type MatchEventWhereInput = {
    AND?: MatchEventWhereInput | MatchEventWhereInput[]
    OR?: MatchEventWhereInput[]
    NOT?: MatchEventWhereInput | MatchEventWhereInput[]
    id?: StringFilter<"MatchEvent"> | string
    matchId?: StringFilter<"MatchEvent"> | string
    type?: EnumMatchEventTypeFilter<"MatchEvent"> | $Enums.MatchEventType
    payload?: StringFilter<"MatchEvent"> | string
    ts?: DateTimeFilter<"MatchEvent"> | Date | string
    match?: XOR<MatchRelationFilter, MatchWhereInput>
  }

  export type MatchEventOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    ts?: SortOrder
    match?: MatchOrderByWithRelationInput
  }

  export type MatchEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchEventWhereInput | MatchEventWhereInput[]
    OR?: MatchEventWhereInput[]
    NOT?: MatchEventWhereInput | MatchEventWhereInput[]
    matchId?: StringFilter<"MatchEvent"> | string
    type?: EnumMatchEventTypeFilter<"MatchEvent"> | $Enums.MatchEventType
    payload?: StringFilter<"MatchEvent"> | string
    ts?: DateTimeFilter<"MatchEvent"> | Date | string
    match?: XOR<MatchRelationFilter, MatchWhereInput>
  }, "id">

  export type MatchEventOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    ts?: SortOrder
    _count?: MatchEventCountOrderByAggregateInput
    _max?: MatchEventMaxOrderByAggregateInput
    _min?: MatchEventMinOrderByAggregateInput
  }

  export type MatchEventScalarWhereWithAggregatesInput = {
    AND?: MatchEventScalarWhereWithAggregatesInput | MatchEventScalarWhereWithAggregatesInput[]
    OR?: MatchEventScalarWhereWithAggregatesInput[]
    NOT?: MatchEventScalarWhereWithAggregatesInput | MatchEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchEvent"> | string
    matchId?: StringWithAggregatesFilter<"MatchEvent"> | string
    type?: EnumMatchEventTypeWithAggregatesFilter<"MatchEvent"> | $Enums.MatchEventType
    payload?: StringWithAggregatesFilter<"MatchEvent"> | string
    ts?: DateTimeWithAggregatesFilter<"MatchEvent"> | Date | string
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: StringFilter<"Challenge"> | string
    challengerId?: StringFilter<"Challenge"> | string
    defenderId?: StringFilter<"Challenge"> | string
    venueId?: StringNullableFilter<"Challenge"> | string | null
    status?: EnumChallengeStatusFilter<"Challenge"> | $Enums.ChallengeStatus
    stakeCoins?: IntFilter<"Challenge"> | number
    expiresAt?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    challenger?: XOR<UserRelationFilter, UserWhereInput>
    defender?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    challengerId?: SortOrder
    defenderId?: SortOrder
    venueId?: SortOrderInput | SortOrder
    status?: SortOrder
    stakeCoins?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    challenger?: UserOrderByWithRelationInput
    defender?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    challengerId?: StringFilter<"Challenge"> | string
    defenderId?: StringFilter<"Challenge"> | string
    venueId?: StringNullableFilter<"Challenge"> | string | null
    status?: EnumChallengeStatusFilter<"Challenge"> | $Enums.ChallengeStatus
    stakeCoins?: IntFilter<"Challenge"> | number
    expiresAt?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    challenger?: XOR<UserRelationFilter, UserWhereInput>
    defender?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    challengerId?: SortOrder
    defenderId?: SortOrder
    venueId?: SortOrderInput | SortOrder
    status?: SortOrder
    stakeCoins?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Challenge"> | string
    challengerId?: StringWithAggregatesFilter<"Challenge"> | string
    defenderId?: StringWithAggregatesFilter<"Challenge"> | string
    venueId?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    status?: EnumChallengeStatusWithAggregatesFilter<"Challenge"> | $Enums.ChallengeStatus
    stakeCoins?: IntWithAggregatesFilter<"Challenge"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Challenge"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    chain?: StringFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chain_address?: WalletChainAddressCompoundUniqueInput
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    userId?: StringFilter<"Wallet"> | string
    chain?: StringFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "chain_address">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    chain?: StringWithAggregatesFilter<"Wallet"> | string
    address?: StringWithAggregatesFilter<"Wallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    type?: EnumTxTypeFilter<"Transaction"> | $Enums.TxType
    metadata?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    type?: EnumTxTypeFilter<"Transaction"> | $Enums.TxType
    metadata?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTxTypeWithAggregatesFilter<"Transaction"> | $Enums.TxType
    metadata?: StringWithAggregatesFilter<"Transaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type NFTWhereInput = {
    AND?: NFTWhereInput | NFTWhereInput[]
    OR?: NFTWhereInput[]
    NOT?: NFTWhereInput | NFTWhereInput[]
    id?: StringFilter<"NFT"> | string
    contract?: StringFilter<"NFT"> | string
    tokenId?: StringFilter<"NFT"> | string
    chain?: StringFilter<"NFT"> | string
    metadata?: StringFilter<"NFT"> | string
    createdAt?: DateTimeFilter<"NFT"> | Date | string
    users?: UserNFTListRelationFilter
  }

  export type NFTOrderByWithRelationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    chain?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    users?: UserNFTOrderByRelationAggregateInput
  }

  export type NFTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract_tokenId_chain?: NFTContractTokenIdChainCompoundUniqueInput
    AND?: NFTWhereInput | NFTWhereInput[]
    OR?: NFTWhereInput[]
    NOT?: NFTWhereInput | NFTWhereInput[]
    contract?: StringFilter<"NFT"> | string
    tokenId?: StringFilter<"NFT"> | string
    chain?: StringFilter<"NFT"> | string
    metadata?: StringFilter<"NFT"> | string
    createdAt?: DateTimeFilter<"NFT"> | Date | string
    users?: UserNFTListRelationFilter
  }, "id" | "contract_tokenId_chain">

  export type NFTOrderByWithAggregationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    chain?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: NFTCountOrderByAggregateInput
    _max?: NFTMaxOrderByAggregateInput
    _min?: NFTMinOrderByAggregateInput
  }

  export type NFTScalarWhereWithAggregatesInput = {
    AND?: NFTScalarWhereWithAggregatesInput | NFTScalarWhereWithAggregatesInput[]
    OR?: NFTScalarWhereWithAggregatesInput[]
    NOT?: NFTScalarWhereWithAggregatesInput | NFTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NFT"> | string
    contract?: StringWithAggregatesFilter<"NFT"> | string
    tokenId?: StringWithAggregatesFilter<"NFT"> | string
    chain?: StringWithAggregatesFilter<"NFT"> | string
    metadata?: StringWithAggregatesFilter<"NFT"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NFT"> | Date | string
  }

  export type UserNFTWhereInput = {
    AND?: UserNFTWhereInput | UserNFTWhereInput[]
    OR?: UserNFTWhereInput[]
    NOT?: UserNFTWhereInput | UserNFTWhereInput[]
    id?: StringFilter<"UserNFT"> | string
    userId?: StringFilter<"UserNFT"> | string
    nftId?: StringFilter<"UserNFT"> | string
    createdAt?: DateTimeFilter<"UserNFT"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    nft?: XOR<NFTRelationFilter, NFTWhereInput>
  }

  export type UserNFTOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    nftId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    nft?: NFTOrderByWithRelationInput
  }

  export type UserNFTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_nftId?: UserNFTUserIdNftIdCompoundUniqueInput
    AND?: UserNFTWhereInput | UserNFTWhereInput[]
    OR?: UserNFTWhereInput[]
    NOT?: UserNFTWhereInput | UserNFTWhereInput[]
    userId?: StringFilter<"UserNFT"> | string
    nftId?: StringFilter<"UserNFT"> | string
    createdAt?: DateTimeFilter<"UserNFT"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    nft?: XOR<NFTRelationFilter, NFTWhereInput>
  }, "id" | "userId_nftId">

  export type UserNFTOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    nftId?: SortOrder
    createdAt?: SortOrder
    _count?: UserNFTCountOrderByAggregateInput
    _max?: UserNFTMaxOrderByAggregateInput
    _min?: UserNFTMinOrderByAggregateInput
  }

  export type UserNFTScalarWhereWithAggregatesInput = {
    AND?: UserNFTScalarWhereWithAggregatesInput | UserNFTScalarWhereWithAggregatesInput[]
    OR?: UserNFTScalarWhereWithAggregatesInput[]
    NOT?: UserNFTScalarWhereWithAggregatesInput | UserNFTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserNFT"> | string
    userId?: StringWithAggregatesFilter<"UserNFT"> | string
    nftId?: StringWithAggregatesFilter<"UserNFT"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserNFT"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    key?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    desc?: StringNullableFilter<"Achievement"> | string | null
    description?: StringNullableFilter<"Achievement"> | string | null
    category?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    users?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    users?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    name?: StringFilter<"Achievement"> | string
    desc?: StringNullableFilter<"Achievement"> | string | null
    description?: StringNullableFilter<"Achievement"> | string | null
    category?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    users?: UserAchievementListRelationFilter
  }, "id" | "key">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    key?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    desc?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    category?: StringWithAggregatesFilter<"Achievement"> | string
    points?: IntWithAggregatesFilter<"Achievement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    payload?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    isRead?: BoolFilter<"Notification"> | boolean
    recipientId?: StringNullableFilter<"Notification"> | string | null
    title?: StringNullableFilter<"Notification"> | string | null
    priority?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    payload?: SortOrder
    read?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    payload?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    isRead?: BoolFilter<"Notification"> | boolean
    recipientId?: StringNullableFilter<"Notification"> | string | null
    title?: StringNullableFilter<"Notification"> | string | null
    priority?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    payload?: SortOrder
    read?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    payload?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    recipientId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    priority?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: StringFilter<"AuditLog"> | string
    ts?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    metadata?: SortOrder
    ts?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: StringFilter<"AuditLog"> | string
    ts?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    target?: SortOrderInput | SortOrder
    metadata?: SortOrder
    ts?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    target?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: StringWithAggregatesFilter<"AuditLog"> | string
    ts?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: StringFilter<"Friendship"> | string
    requesterId?: StringFilter<"Friendship"> | string
    addresseeId?: StringFilter<"Friendship"> | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeFilter<"Friendship"> | Date | string
    requester?: XOR<UserRelationFilter, UserWhereInput>
    addressee?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    requester?: UserOrderByWithRelationInput
    addressee?: UserOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requesterId_addresseeId?: FriendshipRequesterIdAddresseeIdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    requesterId?: StringFilter<"Friendship"> | string
    addresseeId?: StringFilter<"Friendship"> | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeFilter<"Friendship"> | Date | string
    requester?: XOR<UserRelationFilter, UserWhereInput>
    addressee?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "requesterId_addresseeId">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friendship"> | string
    requesterId?: StringWithAggregatesFilter<"Friendship"> | string
    addresseeId?: StringWithAggregatesFilter<"Friendship"> | string
    status?: EnumFriendshipStatusWithAggregatesFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
  }

  export type DirectMessageWhereInput = {
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    id?: StringFilter<"DirectMessage"> | string
    senderId?: StringFilter<"DirectMessage"> | string
    receiverId?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    read?: BoolFilter<"DirectMessage"> | boolean
    timestamp?: DateTimeFilter<"DirectMessage"> | Date | string
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type DirectMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    senderId?: StringFilter<"DirectMessage"> | string
    receiverId?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    read?: BoolFilter<"DirectMessage"> | boolean
    timestamp?: DateTimeFilter<"DirectMessage"> | Date | string
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    OR?: DirectMessageScalarWhereWithAggregatesInput[]
    NOT?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DirectMessage"> | string
    senderId?: StringWithAggregatesFilter<"DirectMessage"> | string
    receiverId?: StringWithAggregatesFilter<"DirectMessage"> | string
    content?: StringWithAggregatesFilter<"DirectMessage"> | string
    read?: BoolWithAggregatesFilter<"DirectMessage"> | boolean
    timestamp?: DateTimeWithAggregatesFilter<"DirectMessage"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DirectMessage"> | Date | string
  }

  export type ActivityEventWhereInput = {
    AND?: ActivityEventWhereInput | ActivityEventWhereInput[]
    OR?: ActivityEventWhereInput[]
    NOT?: ActivityEventWhereInput | ActivityEventWhereInput[]
    id?: StringFilter<"ActivityEvent"> | string
    userId?: StringFilter<"ActivityEvent"> | string
    type?: StringFilter<"ActivityEvent"> | string
    message?: StringNullableFilter<"ActivityEvent"> | string | null
    data?: StringFilter<"ActivityEvent"> | string
    venueId?: StringNullableFilter<"ActivityEvent"> | string | null
    matchId?: StringNullableFilter<"ActivityEvent"> | string | null
    tournamentId?: StringNullableFilter<"ActivityEvent"> | string | null
    clanId?: StringNullableFilter<"ActivityEvent"> | string | null
    metadata?: StringNullableFilter<"ActivityEvent"> | string | null
    isPublic?: BoolFilter<"ActivityEvent"> | boolean
    createdAt?: DateTimeFilter<"ActivityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityEvent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
    match?: XOR<MatchNullableRelationFilter, MatchWhereInput> | null
    tournament?: XOR<TournamentNullableRelationFilter, TournamentWhereInput> | null
    clan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
  }

  export type ActivityEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    data?: SortOrder
    venueId?: SortOrderInput | SortOrder
    matchId?: SortOrderInput | SortOrder
    tournamentId?: SortOrderInput | SortOrder
    clanId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    match?: MatchOrderByWithRelationInput
    tournament?: TournamentOrderByWithRelationInput
    clan?: ClanOrderByWithRelationInput
  }

  export type ActivityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityEventWhereInput | ActivityEventWhereInput[]
    OR?: ActivityEventWhereInput[]
    NOT?: ActivityEventWhereInput | ActivityEventWhereInput[]
    userId?: StringFilter<"ActivityEvent"> | string
    type?: StringFilter<"ActivityEvent"> | string
    message?: StringNullableFilter<"ActivityEvent"> | string | null
    data?: StringFilter<"ActivityEvent"> | string
    venueId?: StringNullableFilter<"ActivityEvent"> | string | null
    matchId?: StringNullableFilter<"ActivityEvent"> | string | null
    tournamentId?: StringNullableFilter<"ActivityEvent"> | string | null
    clanId?: StringNullableFilter<"ActivityEvent"> | string | null
    metadata?: StringNullableFilter<"ActivityEvent"> | string | null
    isPublic?: BoolFilter<"ActivityEvent"> | boolean
    createdAt?: DateTimeFilter<"ActivityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityEvent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
    match?: XOR<MatchNullableRelationFilter, MatchWhereInput> | null
    tournament?: XOR<TournamentNullableRelationFilter, TournamentWhereInput> | null
    clan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
  }, "id">

  export type ActivityEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    data?: SortOrder
    venueId?: SortOrderInput | SortOrder
    matchId?: SortOrderInput | SortOrder
    tournamentId?: SortOrderInput | SortOrder
    clanId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityEventCountOrderByAggregateInput
    _max?: ActivityEventMaxOrderByAggregateInput
    _min?: ActivityEventMinOrderByAggregateInput
  }

  export type ActivityEventScalarWhereWithAggregatesInput = {
    AND?: ActivityEventScalarWhereWithAggregatesInput | ActivityEventScalarWhereWithAggregatesInput[]
    OR?: ActivityEventScalarWhereWithAggregatesInput[]
    NOT?: ActivityEventScalarWhereWithAggregatesInput | ActivityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityEvent"> | string
    userId?: StringWithAggregatesFilter<"ActivityEvent"> | string
    type?: StringWithAggregatesFilter<"ActivityEvent"> | string
    message?: StringNullableWithAggregatesFilter<"ActivityEvent"> | string | null
    data?: StringWithAggregatesFilter<"ActivityEvent"> | string
    venueId?: StringNullableWithAggregatesFilter<"ActivityEvent"> | string | null
    matchId?: StringNullableWithAggregatesFilter<"ActivityEvent"> | string | null
    tournamentId?: StringNullableWithAggregatesFilter<"ActivityEvent"> | string | null
    clanId?: StringNullableWithAggregatesFilter<"ActivityEvent"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"ActivityEvent"> | string | null
    isPublic?: BoolWithAggregatesFilter<"ActivityEvent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ActivityEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActivityEvent"> | Date | string
  }

  export type VenueQuestWhereInput = {
    AND?: VenueQuestWhereInput | VenueQuestWhereInput[]
    OR?: VenueQuestWhereInput[]
    NOT?: VenueQuestWhereInput | VenueQuestWhereInput[]
    id?: StringFilter<"VenueQuest"> | string
    venueId?: StringFilter<"VenueQuest"> | string
    title?: StringFilter<"VenueQuest"> | string
    description?: StringFilter<"VenueQuest"> | string
    reward?: StringFilter<"VenueQuest"> | string
    rewardDojoCoins?: IntFilter<"VenueQuest"> | number
    active?: BoolFilter<"VenueQuest"> | boolean
    isActive?: BoolFilter<"VenueQuest"> | boolean
    requirements?: StringFilter<"VenueQuest"> | string
    type?: StringFilter<"VenueQuest"> | string
    createdAt?: DateTimeFilter<"VenueQuest"> | Date | string
    updatedAt?: DateTimeFilter<"VenueQuest"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type VenueQuestOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    rewardDojoCoins?: SortOrder
    active?: SortOrder
    isActive?: SortOrder
    requirements?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type VenueQuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VenueQuestWhereInput | VenueQuestWhereInput[]
    OR?: VenueQuestWhereInput[]
    NOT?: VenueQuestWhereInput | VenueQuestWhereInput[]
    venueId?: StringFilter<"VenueQuest"> | string
    title?: StringFilter<"VenueQuest"> | string
    description?: StringFilter<"VenueQuest"> | string
    reward?: StringFilter<"VenueQuest"> | string
    rewardDojoCoins?: IntFilter<"VenueQuest"> | number
    active?: BoolFilter<"VenueQuest"> | boolean
    isActive?: BoolFilter<"VenueQuest"> | boolean
    requirements?: StringFilter<"VenueQuest"> | string
    type?: StringFilter<"VenueQuest"> | string
    createdAt?: DateTimeFilter<"VenueQuest"> | Date | string
    updatedAt?: DateTimeFilter<"VenueQuest"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type VenueQuestOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    rewardDojoCoins?: SortOrder
    active?: SortOrder
    isActive?: SortOrder
    requirements?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenueQuestCountOrderByAggregateInput
    _avg?: VenueQuestAvgOrderByAggregateInput
    _max?: VenueQuestMaxOrderByAggregateInput
    _min?: VenueQuestMinOrderByAggregateInput
    _sum?: VenueQuestSumOrderByAggregateInput
  }

  export type VenueQuestScalarWhereWithAggregatesInput = {
    AND?: VenueQuestScalarWhereWithAggregatesInput | VenueQuestScalarWhereWithAggregatesInput[]
    OR?: VenueQuestScalarWhereWithAggregatesInput[]
    NOT?: VenueQuestScalarWhereWithAggregatesInput | VenueQuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VenueQuest"> | string
    venueId?: StringWithAggregatesFilter<"VenueQuest"> | string
    title?: StringWithAggregatesFilter<"VenueQuest"> | string
    description?: StringWithAggregatesFilter<"VenueQuest"> | string
    reward?: StringWithAggregatesFilter<"VenueQuest"> | string
    rewardDojoCoins?: IntWithAggregatesFilter<"VenueQuest"> | number
    active?: BoolWithAggregatesFilter<"VenueQuest"> | boolean
    isActive?: BoolWithAggregatesFilter<"VenueQuest"> | boolean
    requirements?: StringWithAggregatesFilter<"VenueQuest"> | string
    type?: StringWithAggregatesFilter<"VenueQuest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VenueQuest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VenueQuest"> | Date | string
  }

  export type GameSessionWhereInput = {
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    id?: StringFilter<"GameSession"> | string
    playerId?: StringFilter<"GameSession"> | string
    gameId?: StringNullableFilter<"GameSession"> | string | null
    venueId?: StringNullableFilter<"GameSession"> | string | null
    status?: StringFilter<"GameSession"> | string
    gameType?: StringNullableFilter<"GameSession"> | string | null
    rules?: StringFilter<"GameSession"> | string
    startTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    duration?: IntNullableFilter<"GameSession"> | number | null
    playerIds?: StringFilter<"GameSession"> | string
    currentPlayerId?: StringNullableFilter<"GameSession"> | string | null
    ballStates?: StringFilter<"GameSession"> | string
    fouls?: StringFilter<"GameSession"> | string
    score?: StringFilter<"GameSession"> | string
    events?: StringFilter<"GameSession"> | string
    totalShots?: IntFilter<"GameSession"> | number
    totalFouls?: IntFilter<"GameSession"> | number
    totalFrames?: IntFilter<"GameSession"> | number
    lastUpdated?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    winnerId?: StringNullableFilter<"GameSession"> | string | null
    data?: JsonFilter<"GameSession">
    frameCount?: IntFilter<"GameSession"> | number
    shotCount?: IntFilter<"GameSession"> | number
    foulCount?: IntFilter<"GameSession"> | number
    shots?: StringFilter<"GameSession"> | string
    statistics?: StringFilter<"GameSession"> | string
    aiCommentary?: StringFilter<"GameSession"> | string
    matchId?: StringNullableFilter<"GameSession"> | string | null
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
    updatedAt?: DateTimeFilter<"GameSession"> | Date | string
    player?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
  }

  export type GameSessionOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrderInput | SortOrder
    venueId?: SortOrderInput | SortOrder
    status?: SortOrder
    gameType?: SortOrderInput | SortOrder
    rules?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    playerIds?: SortOrder
    currentPlayerId?: SortOrderInput | SortOrder
    ballStates?: SortOrder
    fouls?: SortOrder
    score?: SortOrder
    events?: SortOrder
    totalShots?: SortOrder
    totalFouls?: SortOrder
    totalFrames?: SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    winnerId?: SortOrderInput | SortOrder
    data?: SortOrder
    frameCount?: SortOrder
    shotCount?: SortOrder
    foulCount?: SortOrder
    shots?: SortOrder
    statistics?: SortOrder
    aiCommentary?: SortOrder
    matchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type GameSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    playerId?: StringFilter<"GameSession"> | string
    gameId?: StringNullableFilter<"GameSession"> | string | null
    venueId?: StringNullableFilter<"GameSession"> | string | null
    status?: StringFilter<"GameSession"> | string
    gameType?: StringNullableFilter<"GameSession"> | string | null
    rules?: StringFilter<"GameSession"> | string
    startTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    duration?: IntNullableFilter<"GameSession"> | number | null
    playerIds?: StringFilter<"GameSession"> | string
    currentPlayerId?: StringNullableFilter<"GameSession"> | string | null
    ballStates?: StringFilter<"GameSession"> | string
    fouls?: StringFilter<"GameSession"> | string
    score?: StringFilter<"GameSession"> | string
    events?: StringFilter<"GameSession"> | string
    totalShots?: IntFilter<"GameSession"> | number
    totalFouls?: IntFilter<"GameSession"> | number
    totalFrames?: IntFilter<"GameSession"> | number
    lastUpdated?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    winnerId?: StringNullableFilter<"GameSession"> | string | null
    data?: JsonFilter<"GameSession">
    frameCount?: IntFilter<"GameSession"> | number
    shotCount?: IntFilter<"GameSession"> | number
    foulCount?: IntFilter<"GameSession"> | number
    shots?: StringFilter<"GameSession"> | string
    statistics?: StringFilter<"GameSession"> | string
    aiCommentary?: StringFilter<"GameSession"> | string
    matchId?: StringNullableFilter<"GameSession"> | string | null
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
    updatedAt?: DateTimeFilter<"GameSession"> | Date | string
    player?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
  }, "id">

  export type GameSessionOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrderInput | SortOrder
    venueId?: SortOrderInput | SortOrder
    status?: SortOrder
    gameType?: SortOrderInput | SortOrder
    rules?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    playerIds?: SortOrder
    currentPlayerId?: SortOrderInput | SortOrder
    ballStates?: SortOrder
    fouls?: SortOrder
    score?: SortOrder
    events?: SortOrder
    totalShots?: SortOrder
    totalFouls?: SortOrder
    totalFrames?: SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    winnerId?: SortOrderInput | SortOrder
    data?: SortOrder
    frameCount?: SortOrder
    shotCount?: SortOrder
    foulCount?: SortOrder
    shots?: SortOrder
    statistics?: SortOrder
    aiCommentary?: SortOrder
    matchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameSessionCountOrderByAggregateInput
    _avg?: GameSessionAvgOrderByAggregateInput
    _max?: GameSessionMaxOrderByAggregateInput
    _min?: GameSessionMinOrderByAggregateInput
    _sum?: GameSessionSumOrderByAggregateInput
  }

  export type GameSessionScalarWhereWithAggregatesInput = {
    AND?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    OR?: GameSessionScalarWhereWithAggregatesInput[]
    NOT?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameSession"> | string
    playerId?: StringWithAggregatesFilter<"GameSession"> | string
    gameId?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    venueId?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    status?: StringWithAggregatesFilter<"GameSession"> | string
    gameType?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    rules?: StringWithAggregatesFilter<"GameSession"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"GameSession"> | number | null
    playerIds?: StringWithAggregatesFilter<"GameSession"> | string
    currentPlayerId?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    ballStates?: StringWithAggregatesFilter<"GameSession"> | string
    fouls?: StringWithAggregatesFilter<"GameSession"> | string
    score?: StringWithAggregatesFilter<"GameSession"> | string
    events?: StringWithAggregatesFilter<"GameSession"> | string
    totalShots?: IntWithAggregatesFilter<"GameSession"> | number
    totalFouls?: IntWithAggregatesFilter<"GameSession"> | number
    totalFrames?: IntWithAggregatesFilter<"GameSession"> | number
    lastUpdated?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    winnerId?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    data?: JsonWithAggregatesFilter<"GameSession">
    frameCount?: IntWithAggregatesFilter<"GameSession"> | number
    shotCount?: IntWithAggregatesFilter<"GameSession"> | number
    foulCount?: IntWithAggregatesFilter<"GameSession"> | number
    shots?: StringWithAggregatesFilter<"GameSession"> | string
    statistics?: StringWithAggregatesFilter<"GameSession"> | string
    aiCommentary?: StringWithAggregatesFilter<"GameSession"> | string
    matchId?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
  }

  export type MarketplaceItemWhereInput = {
    AND?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    OR?: MarketplaceItemWhereInput[]
    NOT?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    id?: StringFilter<"MarketplaceItem"> | string
    name?: StringFilter<"MarketplaceItem"> | string
    description?: StringNullableFilter<"MarketplaceItem"> | string | null
    price?: IntFilter<"MarketplaceItem"> | number
    category?: StringFilter<"MarketplaceItem"> | string
    imageUrl?: StringNullableFilter<"MarketplaceItem"> | string | null
    available?: BoolFilter<"MarketplaceItem"> | boolean
    communityItemId?: StringNullableFilter<"MarketplaceItem"> | string | null
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    inventoryItems?: UserInventoryItemListRelationFilter
    communityItem?: XOR<CommunityCosmeticItemNullableRelationFilter, CommunityCosmeticItemWhereInput> | null
  }

  export type MarketplaceItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    available?: SortOrder
    communityItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryItems?: UserInventoryItemOrderByRelationAggregateInput
    communityItem?: CommunityCosmeticItemOrderByWithRelationInput
  }

  export type MarketplaceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    OR?: MarketplaceItemWhereInput[]
    NOT?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    name?: StringFilter<"MarketplaceItem"> | string
    description?: StringNullableFilter<"MarketplaceItem"> | string | null
    price?: IntFilter<"MarketplaceItem"> | number
    category?: StringFilter<"MarketplaceItem"> | string
    imageUrl?: StringNullableFilter<"MarketplaceItem"> | string | null
    available?: BoolFilter<"MarketplaceItem"> | boolean
    communityItemId?: StringNullableFilter<"MarketplaceItem"> | string | null
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    inventoryItems?: UserInventoryItemListRelationFilter
    communityItem?: XOR<CommunityCosmeticItemNullableRelationFilter, CommunityCosmeticItemWhereInput> | null
  }, "id">

  export type MarketplaceItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    available?: SortOrder
    communityItemId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketplaceItemCountOrderByAggregateInput
    _avg?: MarketplaceItemAvgOrderByAggregateInput
    _max?: MarketplaceItemMaxOrderByAggregateInput
    _min?: MarketplaceItemMinOrderByAggregateInput
    _sum?: MarketplaceItemSumOrderByAggregateInput
  }

  export type MarketplaceItemScalarWhereWithAggregatesInput = {
    AND?: MarketplaceItemScalarWhereWithAggregatesInput | MarketplaceItemScalarWhereWithAggregatesInput[]
    OR?: MarketplaceItemScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceItemScalarWhereWithAggregatesInput | MarketplaceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    name?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    description?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    price?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    category?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    available?: BoolWithAggregatesFilter<"MarketplaceItem"> | boolean
    communityItemId?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketplaceItem"> | Date | string
  }

  export type CommunityCosmeticItemWhereInput = {
    AND?: CommunityCosmeticItemWhereInput | CommunityCosmeticItemWhereInput[]
    OR?: CommunityCosmeticItemWhereInput[]
    NOT?: CommunityCosmeticItemWhereInput | CommunityCosmeticItemWhereInput[]
    id?: StringFilter<"CommunityCosmeticItem"> | string
    creatorId?: StringFilter<"CommunityCosmeticItem"> | string
    title?: StringFilter<"CommunityCosmeticItem"> | string
    description?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    category?: EnumCosmeticCategoryFilter<"CommunityCosmeticItem"> | $Enums.CosmeticCategory
    designFileUrl?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    previewImageUrl?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    status?: EnumSubmissionStatusFilter<"CommunityCosmeticItem"> | $Enums.SubmissionStatus
    rejectionReason?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    approvedItemId?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    reviewerId?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    reviewedAt?: DateTimeNullableFilter<"CommunityCosmeticItem"> | Date | string | null
    metadata?: StringFilter<"CommunityCosmeticItem"> | string
    tags?: StringFilter<"CommunityCosmeticItem"> | string
    likes?: IntFilter<"CommunityCosmeticItem"> | number
    views?: IntFilter<"CommunityCosmeticItem"> | number
    createdAt?: DateTimeFilter<"CommunityCosmeticItem"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityCosmeticItem"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    approvedItem?: XOR<MarketplaceItemNullableRelationFilter, MarketplaceItemWhereInput> | null
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    likedBy?: CosmeticItemLikeListRelationFilter
  }

  export type CommunityCosmeticItemOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    designFileUrl?: SortOrderInput | SortOrder
    previewImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedItemId?: SortOrderInput | SortOrder
    reviewerId?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    approvedItem?: MarketplaceItemOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    likedBy?: CosmeticItemLikeOrderByRelationAggregateInput
  }

  export type CommunityCosmeticItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    approvedItemId?: string
    AND?: CommunityCosmeticItemWhereInput | CommunityCosmeticItemWhereInput[]
    OR?: CommunityCosmeticItemWhereInput[]
    NOT?: CommunityCosmeticItemWhereInput | CommunityCosmeticItemWhereInput[]
    creatorId?: StringFilter<"CommunityCosmeticItem"> | string
    title?: StringFilter<"CommunityCosmeticItem"> | string
    description?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    category?: EnumCosmeticCategoryFilter<"CommunityCosmeticItem"> | $Enums.CosmeticCategory
    designFileUrl?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    previewImageUrl?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    status?: EnumSubmissionStatusFilter<"CommunityCosmeticItem"> | $Enums.SubmissionStatus
    rejectionReason?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    reviewerId?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    reviewedAt?: DateTimeNullableFilter<"CommunityCosmeticItem"> | Date | string | null
    metadata?: StringFilter<"CommunityCosmeticItem"> | string
    tags?: StringFilter<"CommunityCosmeticItem"> | string
    likes?: IntFilter<"CommunityCosmeticItem"> | number
    views?: IntFilter<"CommunityCosmeticItem"> | number
    createdAt?: DateTimeFilter<"CommunityCosmeticItem"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityCosmeticItem"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    approvedItem?: XOR<MarketplaceItemNullableRelationFilter, MarketplaceItemWhereInput> | null
    reviewer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    likedBy?: CosmeticItemLikeListRelationFilter
  }, "id" | "approvedItemId">

  export type CommunityCosmeticItemOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    designFileUrl?: SortOrderInput | SortOrder
    previewImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    approvedItemId?: SortOrderInput | SortOrder
    reviewerId?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityCosmeticItemCountOrderByAggregateInput
    _avg?: CommunityCosmeticItemAvgOrderByAggregateInput
    _max?: CommunityCosmeticItemMaxOrderByAggregateInput
    _min?: CommunityCosmeticItemMinOrderByAggregateInput
    _sum?: CommunityCosmeticItemSumOrderByAggregateInput
  }

  export type CommunityCosmeticItemScalarWhereWithAggregatesInput = {
    AND?: CommunityCosmeticItemScalarWhereWithAggregatesInput | CommunityCosmeticItemScalarWhereWithAggregatesInput[]
    OR?: CommunityCosmeticItemScalarWhereWithAggregatesInput[]
    NOT?: CommunityCosmeticItemScalarWhereWithAggregatesInput | CommunityCosmeticItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityCosmeticItem"> | string
    creatorId?: StringWithAggregatesFilter<"CommunityCosmeticItem"> | string
    title?: StringWithAggregatesFilter<"CommunityCosmeticItem"> | string
    description?: StringNullableWithAggregatesFilter<"CommunityCosmeticItem"> | string | null
    category?: EnumCosmeticCategoryWithAggregatesFilter<"CommunityCosmeticItem"> | $Enums.CosmeticCategory
    designFileUrl?: StringNullableWithAggregatesFilter<"CommunityCosmeticItem"> | string | null
    previewImageUrl?: StringNullableWithAggregatesFilter<"CommunityCosmeticItem"> | string | null
    status?: EnumSubmissionStatusWithAggregatesFilter<"CommunityCosmeticItem"> | $Enums.SubmissionStatus
    rejectionReason?: StringNullableWithAggregatesFilter<"CommunityCosmeticItem"> | string | null
    approvedItemId?: StringNullableWithAggregatesFilter<"CommunityCosmeticItem"> | string | null
    reviewerId?: StringNullableWithAggregatesFilter<"CommunityCosmeticItem"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"CommunityCosmeticItem"> | Date | string | null
    metadata?: StringWithAggregatesFilter<"CommunityCosmeticItem"> | string
    tags?: StringWithAggregatesFilter<"CommunityCosmeticItem"> | string
    likes?: IntWithAggregatesFilter<"CommunityCosmeticItem"> | number
    views?: IntWithAggregatesFilter<"CommunityCosmeticItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CommunityCosmeticItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityCosmeticItem"> | Date | string
  }

  export type CosmeticItemLikeWhereInput = {
    AND?: CosmeticItemLikeWhereInput | CosmeticItemLikeWhereInput[]
    OR?: CosmeticItemLikeWhereInput[]
    NOT?: CosmeticItemLikeWhereInput | CosmeticItemLikeWhereInput[]
    id?: StringFilter<"CosmeticItemLike"> | string
    userId?: StringFilter<"CosmeticItemLike"> | string
    cosmeticItemId?: StringFilter<"CosmeticItemLike"> | string
    createdAt?: DateTimeFilter<"CosmeticItemLike"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    cosmeticItem?: XOR<CommunityCosmeticItemRelationFilter, CommunityCosmeticItemWhereInput>
  }

  export type CosmeticItemLikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cosmeticItemId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    cosmeticItem?: CommunityCosmeticItemOrderByWithRelationInput
  }

  export type CosmeticItemLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_cosmeticItemId?: CosmeticItemLikeUserIdCosmeticItemIdCompoundUniqueInput
    AND?: CosmeticItemLikeWhereInput | CosmeticItemLikeWhereInput[]
    OR?: CosmeticItemLikeWhereInput[]
    NOT?: CosmeticItemLikeWhereInput | CosmeticItemLikeWhereInput[]
    userId?: StringFilter<"CosmeticItemLike"> | string
    cosmeticItemId?: StringFilter<"CosmeticItemLike"> | string
    createdAt?: DateTimeFilter<"CosmeticItemLike"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    cosmeticItem?: XOR<CommunityCosmeticItemRelationFilter, CommunityCosmeticItemWhereInput>
  }, "id" | "userId_cosmeticItemId">

  export type CosmeticItemLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cosmeticItemId?: SortOrder
    createdAt?: SortOrder
    _count?: CosmeticItemLikeCountOrderByAggregateInput
    _max?: CosmeticItemLikeMaxOrderByAggregateInput
    _min?: CosmeticItemLikeMinOrderByAggregateInput
  }

  export type CosmeticItemLikeScalarWhereWithAggregatesInput = {
    AND?: CosmeticItemLikeScalarWhereWithAggregatesInput | CosmeticItemLikeScalarWhereWithAggregatesInput[]
    OR?: CosmeticItemLikeScalarWhereWithAggregatesInput[]
    NOT?: CosmeticItemLikeScalarWhereWithAggregatesInput | CosmeticItemLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CosmeticItemLike"> | string
    userId?: StringWithAggregatesFilter<"CosmeticItemLike"> | string
    cosmeticItemId?: StringWithAggregatesFilter<"CosmeticItemLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CosmeticItemLike"> | Date | string
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: StringFilter<"Season"> | string
    name?: StringFilter<"Season"> | string
    description?: StringNullableFilter<"Season"> | string | null
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    isActive?: BoolFilter<"Season"> | boolean
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    name?: StringFilter<"Season"> | string
    description?: StringNullableFilter<"Season"> | string | null
    startDate?: DateTimeFilter<"Season"> | Date | string
    endDate?: DateTimeFilter<"Season"> | Date | string
    isActive?: BoolFilter<"Season"> | boolean
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
  }, "id">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Season"> | string
    name?: StringWithAggregatesFilter<"Season"> | string
    description?: StringNullableWithAggregatesFilter<"Season"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Season"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
  }

  export type ShadowRunWhereInput = {
    AND?: ShadowRunWhereInput | ShadowRunWhereInput[]
    OR?: ShadowRunWhereInput[]
    NOT?: ShadowRunWhereInput | ShadowRunWhereInput[]
    id?: StringFilter<"ShadowRun"> | string
    playerId?: StringFilter<"ShadowRun"> | string
    type?: StringFilter<"ShadowRun"> | string
    status?: StringFilter<"ShadowRun"> | string
    cost?: IntFilter<"ShadowRun"> | number
    reward?: IntNullableFilter<"ShadowRun"> | number | null
    completedAt?: DateTimeNullableFilter<"ShadowRun"> | Date | string | null
    initiatingClanId?: StringNullableFilter<"ShadowRun"> | string | null
    targetVenueId?: StringNullableFilter<"ShadowRun"> | string | null
    outcome?: StringNullableFilter<"ShadowRun"> | string | null
    createdAt?: DateTimeFilter<"ShadowRun"> | Date | string
    updatedAt?: DateTimeFilter<"ShadowRun"> | Date | string
    player?: XOR<UserRelationFilter, UserWhereInput>
    initiatingClan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
    targetVenue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
  }

  export type ShadowRunOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    reward?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    initiatingClanId?: SortOrderInput | SortOrder
    targetVenueId?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: UserOrderByWithRelationInput
    initiatingClan?: ClanOrderByWithRelationInput
    targetVenue?: VenueOrderByWithRelationInput
  }

  export type ShadowRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShadowRunWhereInput | ShadowRunWhereInput[]
    OR?: ShadowRunWhereInput[]
    NOT?: ShadowRunWhereInput | ShadowRunWhereInput[]
    playerId?: StringFilter<"ShadowRun"> | string
    type?: StringFilter<"ShadowRun"> | string
    status?: StringFilter<"ShadowRun"> | string
    cost?: IntFilter<"ShadowRun"> | number
    reward?: IntNullableFilter<"ShadowRun"> | number | null
    completedAt?: DateTimeNullableFilter<"ShadowRun"> | Date | string | null
    initiatingClanId?: StringNullableFilter<"ShadowRun"> | string | null
    targetVenueId?: StringNullableFilter<"ShadowRun"> | string | null
    outcome?: StringNullableFilter<"ShadowRun"> | string | null
    createdAt?: DateTimeFilter<"ShadowRun"> | Date | string
    updatedAt?: DateTimeFilter<"ShadowRun"> | Date | string
    player?: XOR<UserRelationFilter, UserWhereInput>
    initiatingClan?: XOR<ClanNullableRelationFilter, ClanWhereInput> | null
    targetVenue?: XOR<VenueNullableRelationFilter, VenueWhereInput> | null
  }, "id">

  export type ShadowRunOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    reward?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    initiatingClanId?: SortOrderInput | SortOrder
    targetVenueId?: SortOrderInput | SortOrder
    outcome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShadowRunCountOrderByAggregateInput
    _avg?: ShadowRunAvgOrderByAggregateInput
    _max?: ShadowRunMaxOrderByAggregateInput
    _min?: ShadowRunMinOrderByAggregateInput
    _sum?: ShadowRunSumOrderByAggregateInput
  }

  export type ShadowRunScalarWhereWithAggregatesInput = {
    AND?: ShadowRunScalarWhereWithAggregatesInput | ShadowRunScalarWhereWithAggregatesInput[]
    OR?: ShadowRunScalarWhereWithAggregatesInput[]
    NOT?: ShadowRunScalarWhereWithAggregatesInput | ShadowRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShadowRun"> | string
    playerId?: StringWithAggregatesFilter<"ShadowRun"> | string
    type?: StringWithAggregatesFilter<"ShadowRun"> | string
    status?: StringWithAggregatesFilter<"ShadowRun"> | string
    cost?: IntWithAggregatesFilter<"ShadowRun"> | number
    reward?: IntNullableWithAggregatesFilter<"ShadowRun"> | number | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ShadowRun"> | Date | string | null
    initiatingClanId?: StringNullableWithAggregatesFilter<"ShadowRun"> | string | null
    targetVenueId?: StringNullableWithAggregatesFilter<"ShadowRun"> | string | null
    outcome?: StringNullableWithAggregatesFilter<"ShadowRun"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShadowRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShadowRun"> | Date | string
  }

  export type DojoCheckInWhereInput = {
    AND?: DojoCheckInWhereInput | DojoCheckInWhereInput[]
    OR?: DojoCheckInWhereInput[]
    NOT?: DojoCheckInWhereInput | DojoCheckInWhereInput[]
    id?: StringFilter<"DojoCheckIn"> | string
    userId?: StringFilter<"DojoCheckIn"> | string
    venueId?: StringFilter<"DojoCheckIn"> | string
    createdAt?: DateTimeFilter<"DojoCheckIn"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type DojoCheckInOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
  }

  export type DojoCheckInWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DojoCheckInWhereInput | DojoCheckInWhereInput[]
    OR?: DojoCheckInWhereInput[]
    NOT?: DojoCheckInWhereInput | DojoCheckInWhereInput[]
    userId?: StringFilter<"DojoCheckIn"> | string
    venueId?: StringFilter<"DojoCheckIn"> | string
    createdAt?: DateTimeFilter<"DojoCheckIn"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type DojoCheckInOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    createdAt?: SortOrder
    _count?: DojoCheckInCountOrderByAggregateInput
    _max?: DojoCheckInMaxOrderByAggregateInput
    _min?: DojoCheckInMinOrderByAggregateInput
  }

  export type DojoCheckInScalarWhereWithAggregatesInput = {
    AND?: DojoCheckInScalarWhereWithAggregatesInput | DojoCheckInScalarWhereWithAggregatesInput[]
    OR?: DojoCheckInScalarWhereWithAggregatesInput[]
    NOT?: DojoCheckInScalarWhereWithAggregatesInput | DojoCheckInScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DojoCheckIn"> | string
    userId?: StringWithAggregatesFilter<"DojoCheckIn"> | string
    venueId?: StringWithAggregatesFilter<"DojoCheckIn"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DojoCheckIn"> | Date | string
  }

  export type VenueSpecialWhereInput = {
    AND?: VenueSpecialWhereInput | VenueSpecialWhereInput[]
    OR?: VenueSpecialWhereInput[]
    NOT?: VenueSpecialWhereInput | VenueSpecialWhereInput[]
    id?: StringFilter<"VenueSpecial"> | string
    venueId?: StringFilter<"VenueSpecial"> | string
    title?: StringFilter<"VenueSpecial"> | string
    description?: StringNullableFilter<"VenueSpecial"> | string | null
    type?: StringFilter<"VenueSpecial"> | string
    isActive?: BoolFilter<"VenueSpecial"> | boolean
    validUntil?: DateTimeNullableFilter<"VenueSpecial"> | Date | string | null
    createdAt?: DateTimeFilter<"VenueSpecial"> | Date | string
    updatedAt?: DateTimeFilter<"VenueSpecial"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type VenueSpecialOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isActive?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type VenueSpecialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VenueSpecialWhereInput | VenueSpecialWhereInput[]
    OR?: VenueSpecialWhereInput[]
    NOT?: VenueSpecialWhereInput | VenueSpecialWhereInput[]
    venueId?: StringFilter<"VenueSpecial"> | string
    title?: StringFilter<"VenueSpecial"> | string
    description?: StringNullableFilter<"VenueSpecial"> | string | null
    type?: StringFilter<"VenueSpecial"> | string
    isActive?: BoolFilter<"VenueSpecial"> | boolean
    validUntil?: DateTimeNullableFilter<"VenueSpecial"> | Date | string | null
    createdAt?: DateTimeFilter<"VenueSpecial"> | Date | string
    updatedAt?: DateTimeFilter<"VenueSpecial"> | Date | string
    venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type VenueSpecialOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    isActive?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenueSpecialCountOrderByAggregateInput
    _max?: VenueSpecialMaxOrderByAggregateInput
    _min?: VenueSpecialMinOrderByAggregateInput
  }

  export type VenueSpecialScalarWhereWithAggregatesInput = {
    AND?: VenueSpecialScalarWhereWithAggregatesInput | VenueSpecialScalarWhereWithAggregatesInput[]
    OR?: VenueSpecialScalarWhereWithAggregatesInput[]
    NOT?: VenueSpecialScalarWhereWithAggregatesInput | VenueSpecialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VenueSpecial"> | string
    venueId?: StringWithAggregatesFilter<"VenueSpecial"> | string
    title?: StringWithAggregatesFilter<"VenueSpecial"> | string
    description?: StringNullableWithAggregatesFilter<"VenueSpecial"> | string | null
    type?: StringWithAggregatesFilter<"VenueSpecial"> | string
    isActive?: BoolWithAggregatesFilter<"VenueSpecial"> | boolean
    validUntil?: DateTimeNullableWithAggregatesFilter<"VenueSpecial"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VenueSpecial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VenueSpecial"> | Date | string
  }

  export type UserInventoryItemWhereInput = {
    AND?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    OR?: UserInventoryItemWhereInput[]
    NOT?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    id?: StringFilter<"UserInventoryItem"> | string
    userId?: StringFilter<"UserInventoryItem"> | string
    marketplaceItemId?: StringFilter<"UserInventoryItem"> | string
    createdAt?: DateTimeFilter<"UserInventoryItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    marketplaceItem?: XOR<MarketplaceItemRelationFilter, MarketplaceItemWhereInput>
  }

  export type UserInventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    marketplaceItemId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    marketplaceItem?: MarketplaceItemOrderByWithRelationInput
  }

  export type UserInventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    OR?: UserInventoryItemWhereInput[]
    NOT?: UserInventoryItemWhereInput | UserInventoryItemWhereInput[]
    userId?: StringFilter<"UserInventoryItem"> | string
    marketplaceItemId?: StringFilter<"UserInventoryItem"> | string
    createdAt?: DateTimeFilter<"UserInventoryItem"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    marketplaceItem?: XOR<MarketplaceItemRelationFilter, MarketplaceItemWhereInput>
  }, "id">

  export type UserInventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    marketplaceItemId?: SortOrder
    createdAt?: SortOrder
    _count?: UserInventoryItemCountOrderByAggregateInput
    _max?: UserInventoryItemMaxOrderByAggregateInput
    _min?: UserInventoryItemMinOrderByAggregateInput
  }

  export type UserInventoryItemScalarWhereWithAggregatesInput = {
    AND?: UserInventoryItemScalarWhereWithAggregatesInput | UserInventoryItemScalarWhereWithAggregatesInput[]
    OR?: UserInventoryItemScalarWhereWithAggregatesInput[]
    NOT?: UserInventoryItemScalarWhereWithAggregatesInput | UserInventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserInventoryItem"> | string
    userId?: StringWithAggregatesFilter<"UserInventoryItem"> | string
    marketplaceItemId?: StringWithAggregatesFilter<"UserInventoryItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserInventoryItem"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    userId?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    adminNotes?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Feedback"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    resolver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    resolver?: UserOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    userId?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    adminNotes?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Feedback"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    resolver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    adminNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    userId?: StringWithAggregatesFilter<"Feedback"> | string
    message?: StringWithAggregatesFilter<"Feedback"> | string
    category?: EnumFeedbackCategoryWithAggregatesFilter<"Feedback"> | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusWithAggregatesFilter<"Feedback"> | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityWithAggregatesFilter<"Feedback"> | $Enums.FeedbackPriority
    adminNotes?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Feedback"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
  }

  export type ContentWhereInput = {
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    id?: StringFilter<"Content"> | string
    contentId?: StringFilter<"Content"> | string
    userId?: StringFilter<"Content"> | string
    title?: StringFilter<"Content"> | string
    description?: StringNullableFilter<"Content"> | string | null
    contentType?: EnumContentTypeFilter<"Content"> | $Enums.ContentType
    fileUrl?: StringNullableFilter<"Content"> | string | null
    thumbnailUrl?: StringNullableFilter<"Content"> | string | null
    status?: EnumContentStatusFilter<"Content"> | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFilter<"Content"> | $Enums.ContentVisibility
    metadata?: StringFilter<"Content"> | string
    tags?: StringFilter<"Content"> | string
    likes?: IntFilter<"Content"> | number
    shares?: IntFilter<"Content"> | number
    views?: IntFilter<"Content"> | number
    moderatedBy?: StringNullableFilter<"Content"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    moderationNotes?: StringNullableFilter<"Content"> | string | null
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    moderator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    likedBy?: ContentLikeListRelationFilter
    sharedEntries?: ContentShareListRelationFilter
  }

  export type ContentOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentType?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    moderator?: UserOrderByWithRelationInput
    likedBy?: ContentLikeOrderByRelationAggregateInput
    sharedEntries?: ContentShareOrderByRelationAggregateInput
  }

  export type ContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId?: string
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    userId?: StringFilter<"Content"> | string
    title?: StringFilter<"Content"> | string
    description?: StringNullableFilter<"Content"> | string | null
    contentType?: EnumContentTypeFilter<"Content"> | $Enums.ContentType
    fileUrl?: StringNullableFilter<"Content"> | string | null
    thumbnailUrl?: StringNullableFilter<"Content"> | string | null
    status?: EnumContentStatusFilter<"Content"> | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFilter<"Content"> | $Enums.ContentVisibility
    metadata?: StringFilter<"Content"> | string
    tags?: StringFilter<"Content"> | string
    likes?: IntFilter<"Content"> | number
    shares?: IntFilter<"Content"> | number
    views?: IntFilter<"Content"> | number
    moderatedBy?: StringNullableFilter<"Content"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    moderationNotes?: StringNullableFilter<"Content"> | string | null
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    moderator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    likedBy?: ContentLikeListRelationFilter
    sharedEntries?: ContentShareListRelationFilter
  }, "id" | "contentId">

  export type ContentOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentType?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentCountOrderByAggregateInput
    _avg?: ContentAvgOrderByAggregateInput
    _max?: ContentMaxOrderByAggregateInput
    _min?: ContentMinOrderByAggregateInput
    _sum?: ContentSumOrderByAggregateInput
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    OR?: ContentScalarWhereWithAggregatesInput[]
    NOT?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Content"> | string
    contentId?: StringWithAggregatesFilter<"Content"> | string
    userId?: StringWithAggregatesFilter<"Content"> | string
    title?: StringWithAggregatesFilter<"Content"> | string
    description?: StringNullableWithAggregatesFilter<"Content"> | string | null
    contentType?: EnumContentTypeWithAggregatesFilter<"Content"> | $Enums.ContentType
    fileUrl?: StringNullableWithAggregatesFilter<"Content"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Content"> | string | null
    status?: EnumContentStatusWithAggregatesFilter<"Content"> | $Enums.ContentStatus
    visibility?: EnumContentVisibilityWithAggregatesFilter<"Content"> | $Enums.ContentVisibility
    metadata?: StringWithAggregatesFilter<"Content"> | string
    tags?: StringWithAggregatesFilter<"Content"> | string
    likes?: IntWithAggregatesFilter<"Content"> | number
    shares?: IntWithAggregatesFilter<"Content"> | number
    views?: IntWithAggregatesFilter<"Content"> | number
    moderatedBy?: StringNullableWithAggregatesFilter<"Content"> | string | null
    moderatedAt?: DateTimeNullableWithAggregatesFilter<"Content"> | Date | string | null
    moderationNotes?: StringNullableWithAggregatesFilter<"Content"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
  }

  export type ContentLikeWhereInput = {
    AND?: ContentLikeWhereInput | ContentLikeWhereInput[]
    OR?: ContentLikeWhereInput[]
    NOT?: ContentLikeWhereInput | ContentLikeWhereInput[]
    id?: StringFilter<"ContentLike"> | string
    contentId?: StringFilter<"ContentLike"> | string
    userId?: StringFilter<"ContentLike"> | string
    likes?: IntFilter<"ContentLike"> | number
    createdAt?: DateTimeFilter<"ContentLike"> | Date | string
    content?: XOR<ContentRelationFilter, ContentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ContentLikeOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    content?: ContentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ContentLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId_userId?: ContentLikeContentIdUserIdCompoundUniqueInput
    AND?: ContentLikeWhereInput | ContentLikeWhereInput[]
    OR?: ContentLikeWhereInput[]
    NOT?: ContentLikeWhereInput | ContentLikeWhereInput[]
    contentId?: StringFilter<"ContentLike"> | string
    userId?: StringFilter<"ContentLike"> | string
    likes?: IntFilter<"ContentLike"> | number
    createdAt?: DateTimeFilter<"ContentLike"> | Date | string
    content?: XOR<ContentRelationFilter, ContentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "contentId_userId">

  export type ContentLikeOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    _count?: ContentLikeCountOrderByAggregateInput
    _avg?: ContentLikeAvgOrderByAggregateInput
    _max?: ContentLikeMaxOrderByAggregateInput
    _min?: ContentLikeMinOrderByAggregateInput
    _sum?: ContentLikeSumOrderByAggregateInput
  }

  export type ContentLikeScalarWhereWithAggregatesInput = {
    AND?: ContentLikeScalarWhereWithAggregatesInput | ContentLikeScalarWhereWithAggregatesInput[]
    OR?: ContentLikeScalarWhereWithAggregatesInput[]
    NOT?: ContentLikeScalarWhereWithAggregatesInput | ContentLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentLike"> | string
    contentId?: StringWithAggregatesFilter<"ContentLike"> | string
    userId?: StringWithAggregatesFilter<"ContentLike"> | string
    likes?: IntWithAggregatesFilter<"ContentLike"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContentLike"> | Date | string
  }

  export type ContentShareWhereInput = {
    AND?: ContentShareWhereInput | ContentShareWhereInput[]
    OR?: ContentShareWhereInput[]
    NOT?: ContentShareWhereInput | ContentShareWhereInput[]
    id?: StringFilter<"ContentShare"> | string
    contentId?: StringFilter<"ContentShare"> | string
    userId?: StringFilter<"ContentShare"> | string
    sharedWithId?: StringFilter<"ContentShare"> | string
    createdAt?: DateTimeFilter<"ContentShare"> | Date | string
    content?: XOR<ContentRelationFilter, ContentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    sharedWith?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ContentShareOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    sharedWithId?: SortOrder
    createdAt?: SortOrder
    content?: ContentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    sharedWith?: UserOrderByWithRelationInput
  }

  export type ContentShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId_userId_sharedWithId?: ContentShareContentIdUserIdSharedWithIdCompoundUniqueInput
    AND?: ContentShareWhereInput | ContentShareWhereInput[]
    OR?: ContentShareWhereInput[]
    NOT?: ContentShareWhereInput | ContentShareWhereInput[]
    contentId?: StringFilter<"ContentShare"> | string
    userId?: StringFilter<"ContentShare"> | string
    sharedWithId?: StringFilter<"ContentShare"> | string
    createdAt?: DateTimeFilter<"ContentShare"> | Date | string
    content?: XOR<ContentRelationFilter, ContentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    sharedWith?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "contentId_userId_sharedWithId">

  export type ContentShareOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    sharedWithId?: SortOrder
    createdAt?: SortOrder
    _count?: ContentShareCountOrderByAggregateInput
    _max?: ContentShareMaxOrderByAggregateInput
    _min?: ContentShareMinOrderByAggregateInput
  }

  export type ContentShareScalarWhereWithAggregatesInput = {
    AND?: ContentShareScalarWhereWithAggregatesInput | ContentShareScalarWhereWithAggregatesInput[]
    OR?: ContentShareScalarWhereWithAggregatesInput[]
    NOT?: ContentShareScalarWhereWithAggregatesInput | ContentShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentShare"> | string
    contentId?: StringWithAggregatesFilter<"ContentShare"> | string
    userId?: StringWithAggregatesFilter<"ContentShare"> | string
    sharedWithId?: StringWithAggregatesFilter<"ContentShare"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContentShare"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    deviceId?: StringNullableFilter<"RefreshToken"> | string | null
    deviceInfo?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    deviceId?: StringNullableFilter<"RefreshToken"> | string | null
    deviceInfo?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    tokenHash?: StringWithAggregatesFilter<"RefreshToken"> | string
    deviceId?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    deviceInfo?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    avatarUrl?: string | null
    location?: string | null
    skillRating?: number
    clanTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    avatarUrl?: string | null
    location?: string | null
    skillRating?: number
    clanTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    skillRating?: IntFieldUpdateOperationsInput | number
    clanTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    skillRating?: IntFieldUpdateOperationsInput | number
    clanTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    displayName?: string | null
    bio?: string | null
    avatarUrl?: string | null
    location?: string | null
    skillRating?: number
    clanTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    skillRating?: IntFieldUpdateOperationsInput | number
    clanTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    skillRating?: IntFieldUpdateOperationsInput | number
    clanTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: string
    timezone?: string
    privacySettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: string
    timezone?: string
    privacySettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    privacySettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    privacySettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: string
    timezone?: string
    privacySettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    privacySettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    privacySettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueCreateInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableCreateInput = {
    id?: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutTablesListInput
    matches?: MatchCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: string
    venueId: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutTablesListNestedInput
    matches?: MatchUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    id?: string
    venueId: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInCreateInput = {
    id?: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCheckInsInput
    venue: VenueCreateNestedOneWithoutCheckInsInput
  }

  export type CheckInUncheckedCreateInput = {
    id?: string
    userId: string
    venueId: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
  }

  export type CheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCheckInsNestedInput
    venue?: VenueUpdateOneRequiredWithoutCheckInsNestedInput
  }

  export type CheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInCreateManyInput = {
    id?: string
    userId: string
    venueId: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
  }

  export type CheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanCreateInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutLedClansInput
    members?: ClanMemberCreateNestedManyWithoutClanInput
    territories?: TerritoryCreateNestedManyWithoutClanInput
    controlledVenues?: VenueCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    leaderId: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClanMemberUncheckedCreateNestedManyWithoutClanInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutClanInput
    controlledVenues?: VenueUncheckedCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutLedClansNestedInput
    members?: ClanMemberUpdateManyWithoutClanNestedInput
    territories?: TerritoryUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    leaderId?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClanMemberUncheckedUpdateManyWithoutClanNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUncheckedUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    leaderId: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    leaderId?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanMemberCreateInput = {
    id?: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
    clan: ClanCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type ClanMemberUncheckedCreateInput = {
    id?: string
    clanId: string
    userId: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
  }

  export type ClanMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clan?: ClanUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type ClanMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanMemberCreateManyInput = {
    id?: string
    clanId: string
    userId: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
  }

  export type ClanMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryCreateInput = {
    id?: string
    name?: string
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutTerritoriesInput
    owner?: UserCreateNestedOneWithoutTerritoriesInput
    clan?: ClanCreateNestedOneWithoutTerritoriesInput
    events?: TerritoryEventCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryUncheckedCreateInput = {
    id?: string
    venueId: string
    name?: string
    ownerId?: string | null
    clanId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TerritoryEventUncheckedCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutTerritoriesNestedInput
    owner?: UserUpdateOneWithoutTerritoriesNestedInput
    clan?: ClanUpdateOneWithoutTerritoriesNestedInput
    events?: TerritoryEventUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TerritoryEventUncheckedUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryCreateManyInput = {
    id?: string
    venueId: string
    name?: string
    ownerId?: string | null
    clanId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerritoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryEventCreateInput = {
    id?: string
    type: $Enums.TerritoryEventType
    metadata: string
    createdAt?: Date | string
    territory: TerritoryCreateNestedOneWithoutEventsInput
  }

  export type TerritoryEventUncheckedCreateInput = {
    id?: string
    territoryId: string
    type: $Enums.TerritoryEventType
    metadata: string
    createdAt?: Date | string
  }

  export type TerritoryEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTerritoryEventTypeFieldUpdateOperationsInput | $Enums.TerritoryEventType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territory?: TerritoryUpdateOneRequiredWithoutEventsNestedInput
  }

  export type TerritoryEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryId?: StringFieldUpdateOperationsInput | string
    type?: EnumTerritoryEventTypeFieldUpdateOperationsInput | $Enums.TerritoryEventType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryEventCreateManyInput = {
    id?: string
    territoryId: string
    type: $Enums.TerritoryEventType
    metadata: string
    createdAt?: Date | string
  }

  export type TerritoryEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTerritoryEventTypeFieldUpdateOperationsInput | $Enums.TerritoryEventType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    territoryId?: StringFieldUpdateOperationsInput | string
    type?: EnumTerritoryEventTypeFieldUpdateOperationsInput | $Enums.TerritoryEventType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentCreateInput = {
    id?: string
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutTournamentsInput
    participants?: TournamentParticipantCreateNestedManyWithoutTournamentInput
    matches?: MatchCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateInput = {
    id?: string
    venueId?: string | null
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TournamentParticipantUncheckedCreateNestedManyWithoutTournamentInput
    matches?: MatchUncheckedCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutTournamentsNestedInput
    participants?: TournamentParticipantUpdateManyWithoutTournamentNestedInput
    matches?: MatchUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TournamentParticipantUncheckedUpdateManyWithoutTournamentNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentCreateManyInput = {
    id?: string
    venueId?: string | null
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentParticipantCreateInput = {
    id?: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
    tournament: TournamentCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTournamentsInput
  }

  export type TournamentParticipantUncheckedCreateInput = {
    id?: string
    tournamentId: string
    userId: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
  }

  export type TournamentParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type TournamentParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentParticipantCreateManyInput = {
    id?: string
    tournamentId: string
    userId: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
  }

  export type TournamentParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament?: TournamentCreateNestedOneWithoutMatchesInput
    venue?: VenueCreateNestedOneWithoutMatchesInput
    table?: TableCreateNestedOneWithoutMatchesInput
    playerA: UserCreateNestedOneWithoutMatchesAsPlayerAInput
    playerB: UserCreateNestedOneWithoutMatchesAsPlayerBInput
    events?: MatchEventCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: MatchEventUncheckedCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneWithoutMatchesNestedInput
    venue?: VenueUpdateOneWithoutMatchesNestedInput
    table?: TableUpdateOneWithoutMatchesNestedInput
    playerA?: UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput
    playerB?: UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput
    events?: MatchEventUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: MatchEventUncheckedUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchCreateManyInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchEventCreateInput = {
    id?: string
    type: $Enums.MatchEventType
    payload: string
    ts?: Date | string
    match: MatchCreateNestedOneWithoutEventsInput
  }

  export type MatchEventUncheckedCreateInput = {
    id?: string
    matchId: string
    type: $Enums.MatchEventType
    payload: string
    ts?: Date | string
  }

  export type MatchEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchEventTypeFieldUpdateOperationsInput | $Enums.MatchEventType
    payload?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutEventsNestedInput
  }

  export type MatchEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchEventTypeFieldUpdateOperationsInput | $Enums.MatchEventType
    payload?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchEventCreateManyInput = {
    id?: string
    matchId: string
    type: $Enums.MatchEventType
    payload: string
    ts?: Date | string
  }

  export type MatchEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchEventTypeFieldUpdateOperationsInput | $Enums.MatchEventType
    payload?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchEventTypeFieldUpdateOperationsInput | $Enums.MatchEventType
    payload?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateInput = {
    id?: string
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    challenger: UserCreateNestedOneWithoutChallengesAsChallengerInput
    defender: UserCreateNestedOneWithoutChallengesAsDefenderInput
    venue?: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: string
    challengerId: string
    defenderId: string
    venueId?: string | null
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenger?: UserUpdateOneRequiredWithoutChallengesAsChallengerNestedInput
    defender?: UserUpdateOneRequiredWithoutChallengesAsDefenderNestedInput
    venue?: VenueUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateManyInput = {
    id?: string
    challengerId: string
    defenderId: string
    venueId?: string | null
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    chain: string
    address: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletsInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    chain: string
    address: string
    createdAt?: Date | string
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletsNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    chain: string
    address: string
    createdAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    currency?: string
    type: $Enums.TxType
    metadata: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    type: $Enums.TxType
    metadata: string
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    type: $Enums.TxType
    metadata: string
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTCreateInput = {
    id?: string
    contract: string
    tokenId: string
    chain: string
    metadata: string
    createdAt?: Date | string
    users?: UserNFTCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateInput = {
    id?: string
    contract: string
    tokenId: string
    chain: string
    metadata: string
    createdAt?: Date | string
    users?: UserNFTUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserNFTUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserNFTUncheckedUpdateManyWithoutNftNestedInput
  }

  export type NFTCreateManyInput = {
    id?: string
    contract: string
    tokenId: string
    chain: string
    metadata: string
    createdAt?: Date | string
  }

  export type NFTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNFTCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNftsInput
    nft: NFTCreateNestedOneWithoutUsersInput
  }

  export type UserNFTUncheckedCreateInput = {
    id?: string
    userId: string
    nftId: string
    createdAt?: Date | string
  }

  export type UserNFTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNftsNestedInput
    nft?: NFTUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserNFTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNFTCreateManyInput = {
    id?: string
    userId: string
    nftId: string
    createdAt?: Date | string
  }

  export type UserNFTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNFTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    key: string
    name: string
    desc?: string | null
    description?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
    users?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    desc?: string | null
    description?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
    users?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    key: string
    name: string
    desc?: string | null
    description?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUsersInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    earnedAt?: Date | string
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    earnedAt?: Date | string
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message?: string | null
    payload: string
    read?: boolean
    isRead?: boolean
    recipientId?: string | null
    title?: string | null
    priority?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    payload: string
    read?: boolean
    isRead?: boolean
    recipientId?: string | null
    title?: string | null
    priority?: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    payload: string
    read?: boolean
    isRead?: boolean
    recipientId?: string | null
    title?: string | null
    priority?: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    target?: string | null
    metadata: string
    ts?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId?: string | null
    action: string
    target?: string | null
    metadata: string
    ts?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId?: string | null
    action: string
    target?: string | null
    metadata: string
    ts?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutFriendshipsAsRequesterInput
    addressee: UserCreateNestedOneWithoutFriendshipsAsAddresseeInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    requesterId: string
    addresseeId: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutFriendshipsAsRequesterNestedInput
    addressee?: UserUpdateOneRequiredWithoutFriendshipsAsAddresseeNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    requesterId: string
    addresseeId: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateInput = {
    id?: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type DirectMessageUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type DirectMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type DirectMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventCreateInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityEventsInput
    venue?: VenueCreateNestedOneWithoutActivityEventsInput
    match?: MatchCreateNestedOneWithoutActivityEventsInput
    tournament?: TournamentCreateNestedOneWithoutActivityEventsInput
    clan?: ClanCreateNestedOneWithoutActivityEventsInput
  }

  export type ActivityEventUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityEventsNestedInput
    venue?: VenueUpdateOneWithoutActivityEventsNestedInput
    match?: MatchUpdateOneWithoutActivityEventsNestedInput
    tournament?: TournamentUpdateOneWithoutActivityEventsNestedInput
    clan?: ClanUpdateOneWithoutActivityEventsNestedInput
  }

  export type ActivityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventCreateManyInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueQuestCreateInput = {
    id?: string
    title: string
    description: string
    reward?: string
    rewardDojoCoins?: number
    active?: boolean
    isActive?: boolean
    requirements?: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutQuestsInput
  }

  export type VenueQuestUncheckedCreateInput = {
    id?: string
    venueId: string
    title: string
    description: string
    reward?: string
    rewardDojoCoins?: number
    active?: boolean
    isActive?: boolean
    requirements?: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueQuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    rewardDojoCoins?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requirements?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type VenueQuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    rewardDojoCoins?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requirements?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueQuestCreateManyInput = {
    id?: string
    venueId: string
    title: string
    description: string
    reward?: string
    rewardDojoCoins?: number
    active?: boolean
    isActive?: boolean
    requirements?: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueQuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    rewardDojoCoins?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requirements?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueQuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    rewardDojoCoins?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requirements?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionCreateInput = {
    id?: string
    gameId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutGameSessionsInput
    venue?: VenueCreateNestedOneWithoutGameSessionsInput
  }

  export type GameSessionUncheckedCreateInput = {
    id?: string
    playerId: string
    gameId?: string | null
    venueId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutGameSessionsNestedInput
    venue?: VenueUpdateOneWithoutGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionCreateManyInput = {
    id?: string
    playerId: string
    gameId?: string | null
    venueId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    category: string
    imageUrl?: string | null
    available?: boolean
    communityItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutMarketplaceItemInput
    communityItem?: CommunityCosmeticItemCreateNestedOneWithoutApprovedItemInput
  }

  export type MarketplaceItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    category: string
    imageUrl?: string | null
    available?: boolean
    communityItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutMarketplaceItemInput
    communityItem?: CommunityCosmeticItemUncheckedCreateNestedOneWithoutApprovedItemInput
  }

  export type MarketplaceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: UserInventoryItemUpdateManyWithoutMarketplaceItemNestedInput
    communityItem?: CommunityCosmeticItemUpdateOneWithoutApprovedItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutMarketplaceItemNestedInput
    communityItem?: CommunityCosmeticItemUncheckedUpdateOneWithoutApprovedItemNestedInput
  }

  export type MarketplaceItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    category: string
    imageUrl?: string | null
    available?: boolean
    communityItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCosmeticItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCommunityItemsInput
    approvedItem?: MarketplaceItemCreateNestedOneWithoutCommunityItemInput
    reviewer?: UserCreateNestedOneWithoutReviewedItemsInput
    likedBy?: CosmeticItemLikeCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemUncheckedCreateInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    approvedItemId?: string | null
    reviewerId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: CosmeticItemLikeUncheckedCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCommunityItemsNestedInput
    approvedItem?: MarketplaceItemUpdateOneWithoutCommunityItemNestedInput
    reviewer?: UserUpdateOneWithoutReviewedItemsNestedInput
    likedBy?: CosmeticItemLikeUpdateManyWithoutCosmeticItemNestedInput
  }

  export type CommunityCosmeticItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedItemId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: CosmeticItemLikeUncheckedUpdateManyWithoutCosmeticItemNestedInput
  }

  export type CommunityCosmeticItemCreateManyInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    approvedItemId?: string | null
    reviewerId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityCosmeticItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCosmeticItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedItemId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CosmeticItemLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCosmeticLikesInput
    cosmeticItem: CommunityCosmeticItemCreateNestedOneWithoutLikedByInput
  }

  export type CosmeticItemLikeUncheckedCreateInput = {
    id?: string
    userId: string
    cosmeticItemId: string
    createdAt?: Date | string
  }

  export type CosmeticItemLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCosmeticLikesNestedInput
    cosmeticItem?: CommunityCosmeticItemUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type CosmeticItemLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cosmeticItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CosmeticItemLikeCreateManyInput = {
    id?: string
    userId: string
    cosmeticItemId: string
    createdAt?: Date | string
  }

  export type CosmeticItemLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CosmeticItemLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cosmeticItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunCreateInput = {
    id?: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutShadowRunsInput
    initiatingClan?: ClanCreateNestedOneWithoutShadowRunsInput
    targetVenue?: VenueCreateNestedOneWithoutShadowRunsInput
  }

  export type ShadowRunUncheckedCreateInput = {
    id?: string
    playerId: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    initiatingClanId?: string | null
    targetVenueId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShadowRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutShadowRunsNestedInput
    initiatingClan?: ClanUpdateOneWithoutShadowRunsNestedInput
    targetVenue?: VenueUpdateOneWithoutShadowRunsNestedInput
  }

  export type ShadowRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVenueId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunCreateManyInput = {
    id?: string
    playerId: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    initiatingClanId?: string | null
    targetVenueId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShadowRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVenueId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DojoCheckInCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDojoCheckInsInput
    venue: VenueCreateNestedOneWithoutDojoCheckInsInput
  }

  export type DojoCheckInUncheckedCreateInput = {
    id?: string
    userId: string
    venueId: string
    createdAt?: Date | string
  }

  export type DojoCheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDojoCheckInsNestedInput
    venue?: VenueUpdateOneRequiredWithoutDojoCheckInsNestedInput
  }

  export type DojoCheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DojoCheckInCreateManyInput = {
    id?: string
    userId: string
    venueId: string
    createdAt?: Date | string
  }

  export type DojoCheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DojoCheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueSpecialCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isActive?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutSpecialsInput
  }

  export type VenueSpecialUncheckedCreateInput = {
    id?: string
    venueId: string
    title: string
    description?: string | null
    type: string
    isActive?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueSpecialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutSpecialsNestedInput
  }

  export type VenueSpecialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueSpecialCreateManyInput = {
    id?: string
    venueId: string
    title: string
    description?: string | null
    type: string
    isActive?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueSpecialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueSpecialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInventoryItemsInput
    marketplaceItem: MarketplaceItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type UserInventoryItemUncheckedCreateInput = {
    id?: string
    userId: string
    marketplaceItemId: string
    createdAt?: Date | string
  }

  export type UserInventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInventoryItemsNestedInput
    marketplaceItem?: MarketplaceItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type UserInventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemCreateManyInput = {
    id?: string
    userId: string
    marketplaceItemId: string
    createdAt?: Date | string
  }

  export type UserInventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    id?: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFeedbackInput
    resolver?: UserCreateNestedOneWithoutResolvedFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    userId: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFeedbackNestedInput
    resolver?: UserUpdateOneWithoutResolvedFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackCreateManyInput = {
    id?: string
    userId: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentCreateInput = {
    id?: string
    contentId?: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContentInput
    moderator?: UserCreateNestedOneWithoutModeratedContentInput
    likedBy?: ContentLikeCreateNestedManyWithoutContentInput
    sharedEntries?: ContentShareCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateInput = {
    id?: string
    contentId?: string
    userId: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: ContentLikeUncheckedCreateNestedManyWithoutContentInput
    sharedEntries?: ContentShareUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContentNestedInput
    moderator?: UserUpdateOneWithoutModeratedContentNestedInput
    likedBy?: ContentLikeUpdateManyWithoutContentNestedInput
    sharedEntries?: ContentShareUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: ContentLikeUncheckedUpdateManyWithoutContentNestedInput
    sharedEntries?: ContentShareUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateManyInput = {
    id?: string
    contentId?: string
    userId: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentLikeCreateInput = {
    id?: string
    likes?: number
    createdAt?: Date | string
    content: ContentCreateNestedOneWithoutLikedByInput
    user: UserCreateNestedOneWithoutContentLikesInput
  }

  export type ContentLikeUncheckedCreateInput = {
    id?: string
    contentId: string
    userId: string
    likes?: number
    createdAt?: Date | string
  }

  export type ContentLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentUpdateOneRequiredWithoutLikedByNestedInput
    user?: UserUpdateOneRequiredWithoutContentLikesNestedInput
  }

  export type ContentLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentLikeCreateManyInput = {
    id?: string
    contentId: string
    userId: string
    likes?: number
    createdAt?: Date | string
  }

  export type ContentLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareCreateInput = {
    id?: string
    createdAt?: Date | string
    content: ContentCreateNestedOneWithoutSharedEntriesInput
    user: UserCreateNestedOneWithoutSharedContentInput
    sharedWith: UserCreateNestedOneWithoutReceivedSharesInput
  }

  export type ContentShareUncheckedCreateInput = {
    id?: string
    contentId: string
    userId: string
    sharedWithId: string
    createdAt?: Date | string
  }

  export type ContentShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentUpdateOneRequiredWithoutSharedEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutSharedContentNestedInput
    sharedWith?: UserUpdateOneRequiredWithoutReceivedSharesNestedInput
  }

  export type ContentShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharedWithId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareCreateManyInput = {
    id?: string
    contentId: string
    userId: string
    sharedWithId: string
    createdAt?: Date | string
  }

  export type ContentShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharedWithId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    tokenHash: string
    deviceId?: string | null
    deviceInfo?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    deviceId?: string | null
    deviceInfo?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    deviceId?: string | null
    deviceInfo?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type UserSettingsNullableRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type WalletListRelationFilter = {
    every?: WalletWhereInput
    some?: WalletWhereInput
    none?: WalletWhereInput
  }

  export type UserNFTListRelationFilter = {
    every?: UserNFTWhereInput
    some?: UserNFTWhereInput
    none?: UserNFTWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type ClanMemberListRelationFilter = {
    every?: ClanMemberWhereInput
    some?: ClanMemberWhereInput
    none?: ClanMemberWhereInput
  }

  export type TerritoryListRelationFilter = {
    every?: TerritoryWhereInput
    some?: TerritoryWhereInput
    none?: TerritoryWhereInput
  }

  export type CheckInListRelationFilter = {
    every?: CheckInWhereInput
    some?: CheckInWhereInput
    none?: CheckInWhereInput
  }

  export type ChallengeListRelationFilter = {
    every?: ChallengeWhereInput
    some?: ChallengeWhereInput
    none?: ChallengeWhereInput
  }

  export type ClanListRelationFilter = {
    every?: ClanWhereInput
    some?: ClanWhereInput
    none?: ClanWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type TournamentParticipantListRelationFilter = {
    every?: TournamentParticipantWhereInput
    some?: TournamentParticipantWhereInput
    none?: TournamentParticipantWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type VenueListRelationFilter = {
    every?: VenueWhereInput
    some?: VenueWhereInput
    none?: VenueWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type DirectMessageListRelationFilter = {
    every?: DirectMessageWhereInput
    some?: DirectMessageWhereInput
    none?: DirectMessageWhereInput
  }

  export type ActivityEventListRelationFilter = {
    every?: ActivityEventWhereInput
    some?: ActivityEventWhereInput
    none?: ActivityEventWhereInput
  }

  export type GameSessionListRelationFilter = {
    every?: GameSessionWhereInput
    some?: GameSessionWhereInput
    none?: GameSessionWhereInput
  }

  export type ShadowRunListRelationFilter = {
    every?: ShadowRunWhereInput
    some?: ShadowRunWhereInput
    none?: ShadowRunWhereInput
  }

  export type DojoCheckInListRelationFilter = {
    every?: DojoCheckInWhereInput
    some?: DojoCheckInWhereInput
    none?: DojoCheckInWhereInput
  }

  export type UserInventoryItemListRelationFilter = {
    every?: UserInventoryItemWhereInput
    some?: UserInventoryItemWhereInput
    none?: UserInventoryItemWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type ContentListRelationFilter = {
    every?: ContentWhereInput
    some?: ContentWhereInput
    none?: ContentWhereInput
  }

  export type ContentLikeListRelationFilter = {
    every?: ContentLikeWhereInput
    some?: ContentLikeWhereInput
    none?: ContentLikeWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type ContentShareListRelationFilter = {
    every?: ContentShareWhereInput
    some?: ContentShareWhereInput
    none?: ContentShareWhereInput
  }

  export type CommunityCosmeticItemListRelationFilter = {
    every?: CommunityCosmeticItemWhereInput
    some?: CommunityCosmeticItemWhereInput
    none?: CommunityCosmeticItemWhereInput
  }

  export type CosmeticItemLikeListRelationFilter = {
    every?: CosmeticItemLikeWhereInput
    some?: CosmeticItemLikeWhereInput
    none?: CosmeticItemLikeWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type WalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserNFTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClanMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TerritoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShadowRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DojoCheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityCosmeticItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CosmeticItemLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isBanned?: SortOrder
    avatarUrl?: SortOrder
    dojoCoinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    dojoCoinBalance?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isBanned?: SortOrder
    avatarUrl?: SortOrder
    dojoCoinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isBanned?: SortOrder
    avatarUrl?: SortOrder
    dojoCoinBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    dojoCoinBalance?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    location?: SortOrder
    skillRating?: SortOrder
    clanTitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    skillRating?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    location?: SortOrder
    skillRating?: SortOrder
    clanTitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    location?: SortOrder
    skillRating?: SortOrder
    clanTitle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    skillRating?: SortOrder
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotifications?: SortOrder
    pushNotifications?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    privacySettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClanNullableRelationFilter = {
    is?: ClanWhereInput | null
    isNot?: ClanWhereInput | null
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type TournamentListRelationFilter = {
    every?: TournamentWhereInput
    some?: TournamentWhereInput
    none?: TournamentWhereInput
  }

  export type VenueQuestListRelationFilter = {
    every?: VenueQuestWhereInput
    some?: VenueQuestWhereInput
    none?: VenueQuestWhereInput
  }

  export type VenueSpecialListRelationFilter = {
    every?: VenueSpecialWhereInput
    some?: VenueSpecialWhereInput
    none?: VenueSpecialWhereInput
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueQuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueSpecialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrder
    ownerId?: SortOrder
    controllingClanId?: SortOrder
    incomeModifier?: SortOrder
    defenseLevel?: SortOrder
    status?: SortOrder
    photos?: SortOrder
    rating?: SortOrder
    features?: SortOrder
    tables?: SortOrder
    reviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    incomeModifier?: SortOrder
    defenseLevel?: SortOrder
    rating?: SortOrder
    tables?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrder
    ownerId?: SortOrder
    controllingClanId?: SortOrder
    incomeModifier?: SortOrder
    defenseLevel?: SortOrder
    status?: SortOrder
    photos?: SortOrder
    rating?: SortOrder
    features?: SortOrder
    tables?: SortOrder
    reviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    address?: SortOrder
    ownerId?: SortOrder
    controllingClanId?: SortOrder
    incomeModifier?: SortOrder
    defenseLevel?: SortOrder
    status?: SortOrder
    photos?: SortOrder
    rating?: SortOrder
    features?: SortOrder
    tables?: SortOrder
    reviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
    incomeModifier?: SortOrder
    defenseLevel?: SortOrder
    rating?: SortOrder
    tables?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumTableStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TableStatus | EnumTableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTableStatusFilter<$PrismaModel> | $Enums.TableStatus
  }

  export type VenueRelationFilter = {
    is?: VenueWhereInput
    isNot?: VenueWhereInput
  }

  export type TableCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTableStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TableStatus | EnumTableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTableStatusWithAggregatesFilter<$PrismaModel> | $Enums.TableStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTableStatusFilter<$PrismaModel>
    _max?: NestedEnumTableStatusFilter<$PrismaModel>
  }

  export type EnumCheckInMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckInMethod | EnumCheckInMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckInMethodFilter<$PrismaModel> | $Enums.CheckInMethod
  }

  export type CheckInCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
  }

  export type CheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
  }

  export type CheckInMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    via?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCheckInMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckInMethod | EnumCheckInMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckInMethodWithAggregatesFilter<$PrismaModel> | $Enums.CheckInMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCheckInMethodFilter<$PrismaModel>
    _max?: NestedEnumCheckInMethodFilter<$PrismaModel>
  }

  export type ClanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tag?: SortOrder
    leaderId?: SortOrder
    maxMembers?: SortOrder
    dojoCoinBalance?: SortOrder
    seasonalPoints?: SortOrder
    bannerUrl?: SortOrder
    color?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    reputation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClanAvgOrderByAggregateInput = {
    maxMembers?: SortOrder
    dojoCoinBalance?: SortOrder
    seasonalPoints?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    reputation?: SortOrder
  }

  export type ClanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tag?: SortOrder
    leaderId?: SortOrder
    maxMembers?: SortOrder
    dojoCoinBalance?: SortOrder
    seasonalPoints?: SortOrder
    bannerUrl?: SortOrder
    color?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    reputation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tag?: SortOrder
    leaderId?: SortOrder
    maxMembers?: SortOrder
    dojoCoinBalance?: SortOrder
    seasonalPoints?: SortOrder
    bannerUrl?: SortOrder
    color?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    reputation?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClanSumOrderByAggregateInput = {
    maxMembers?: SortOrder
    dojoCoinBalance?: SortOrder
    seasonalPoints?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    reputation?: SortOrder
  }

  export type EnumClanRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ClanRole | EnumClanRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClanRoleFilter<$PrismaModel> | $Enums.ClanRole
  }

  export type ClanRelationFilter = {
    is?: ClanWhereInput
    isNot?: ClanWhereInput
  }

  export type ClanMemberClanId_userIdCompoundUniqueInput = {
    clanId: string
    userId: string
  }

  export type ClanMemberCountOrderByAggregateInput = {
    id?: SortOrder
    clanId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ClanMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    clanId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ClanMemberMinOrderByAggregateInput = {
    id?: SortOrder
    clanId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumClanRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClanRole | EnumClanRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClanRoleWithAggregatesFilter<$PrismaModel> | $Enums.ClanRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClanRoleFilter<$PrismaModel>
    _max?: NestedEnumClanRoleFilter<$PrismaModel>
  }

  export type TerritoryEventListRelationFilter = {
    every?: TerritoryEventWhereInput
    some?: TerritoryEventWhereInput
    none?: TerritoryEventWhereInput
  }

  export type TerritoryEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TerritoryCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    clanId?: SortOrder
    level?: SortOrder
    defenseScore?: SortOrder
    resources?: SortOrder
    strategicValue?: SortOrder
    resourceRate?: SortOrder
    lastTickAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerritoryAvgOrderByAggregateInput = {
    level?: SortOrder
    defenseScore?: SortOrder
    strategicValue?: SortOrder
  }

  export type TerritoryMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    clanId?: SortOrder
    level?: SortOrder
    defenseScore?: SortOrder
    resources?: SortOrder
    strategicValue?: SortOrder
    resourceRate?: SortOrder
    lastTickAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerritoryMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    clanId?: SortOrder
    level?: SortOrder
    defenseScore?: SortOrder
    resources?: SortOrder
    strategicValue?: SortOrder
    resourceRate?: SortOrder
    lastTickAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerritorySumOrderByAggregateInput = {
    level?: SortOrder
    defenseScore?: SortOrder
    strategicValue?: SortOrder
  }

  export type EnumTerritoryEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TerritoryEventType | EnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerritoryEventTypeFilter<$PrismaModel> | $Enums.TerritoryEventType
  }

  export type TerritoryRelationFilter = {
    is?: TerritoryWhereInput
    isNot?: TerritoryWhereInput
  }

  export type TerritoryEventCountOrderByAggregateInput = {
    id?: SortOrder
    territoryId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TerritoryEventMaxOrderByAggregateInput = {
    id?: SortOrder
    territoryId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TerritoryEventMinOrderByAggregateInput = {
    id?: SortOrder
    territoryId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTerritoryEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TerritoryEventType | EnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerritoryEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TerritoryEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTerritoryEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTerritoryEventTypeFilter<$PrismaModel>
  }

  export type EnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type VenueNullableRelationFilter = {
    is?: VenueWhereInput | null
    isNot?: VenueWhereInput | null
  }

  export type TournamentCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isSponsored?: SortOrder
    sponsoredBy?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sponsorBannerUrl?: SortOrder
    maxPlayers?: SortOrder
    entryFee?: SortOrder
    rewards?: SortOrder
    prizePool?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentAvgOrderByAggregateInput = {
    maxPlayers?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type TournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isSponsored?: SortOrder
    sponsoredBy?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sponsorBannerUrl?: SortOrder
    maxPlayers?: SortOrder
    entryFee?: SortOrder
    rewards?: SortOrder
    prizePool?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isSponsored?: SortOrder
    sponsoredBy?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sponsorBannerUrl?: SortOrder
    maxPlayers?: SortOrder
    entryFee?: SortOrder
    rewards?: SortOrder
    prizePool?: SortOrder
    format?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentSumOrderByAggregateInput = {
    maxPlayers?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type EnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type TournamentRelationFilter = {
    is?: TournamentWhereInput
    isNot?: TournamentWhereInput
  }

  export type TournamentParticipantTournamentIdUserIdCompoundUniqueInput = {
    tournamentId: string
    userId: string
  }

  export type TournamentParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    seed?: SortOrder
    finalRank?: SortOrder
    createdAt?: SortOrder
  }

  export type TournamentParticipantAvgOrderByAggregateInput = {
    seed?: SortOrder
    finalRank?: SortOrder
  }

  export type TournamentParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    seed?: SortOrder
    finalRank?: SortOrder
    createdAt?: SortOrder
  }

  export type TournamentParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    seed?: SortOrder
    finalRank?: SortOrder
    createdAt?: SortOrder
  }

  export type TournamentParticipantSumOrderByAggregateInput = {
    seed?: SortOrder
    finalRank?: SortOrder
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type TournamentNullableRelationFilter = {
    is?: TournamentWhereInput | null
    isNot?: TournamentWhereInput | null
  }

  export type TableNullableRelationFilter = {
    is?: TableWhereInput | null
    isNot?: TableWhereInput | null
  }

  export type MatchEventListRelationFilter = {
    every?: MatchEventWhereInput
    some?: MatchEventWhereInput
    none?: MatchEventWhereInput
  }

  export type MatchEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    venueId?: SortOrder
    tableId?: SortOrder
    playerAId?: SortOrder
    playerBId?: SortOrder
    winnerId?: SortOrder
    loserId?: SortOrder
    status?: SortOrder
    scoreA?: SortOrder
    scoreB?: SortOrder
    round?: SortOrder
    wager?: SortOrder
    aiAnalysisJson?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    scoreA?: SortOrder
    scoreB?: SortOrder
    round?: SortOrder
    wager?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    venueId?: SortOrder
    tableId?: SortOrder
    playerAId?: SortOrder
    playerBId?: SortOrder
    winnerId?: SortOrder
    loserId?: SortOrder
    status?: SortOrder
    scoreA?: SortOrder
    scoreB?: SortOrder
    round?: SortOrder
    wager?: SortOrder
    aiAnalysisJson?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    venueId?: SortOrder
    tableId?: SortOrder
    playerAId?: SortOrder
    playerBId?: SortOrder
    winnerId?: SortOrder
    loserId?: SortOrder
    status?: SortOrder
    scoreA?: SortOrder
    scoreB?: SortOrder
    round?: SortOrder
    wager?: SortOrder
    aiAnalysisJson?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    scoreA?: SortOrder
    scoreB?: SortOrder
    round?: SortOrder
    wager?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type EnumMatchEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchEventType | EnumMatchEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchEventTypeFilter<$PrismaModel> | $Enums.MatchEventType
  }

  export type MatchRelationFilter = {
    is?: MatchWhereInput
    isNot?: MatchWhereInput
  }

  export type MatchEventCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    ts?: SortOrder
  }

  export type MatchEventMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    ts?: SortOrder
  }

  export type MatchEventMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    ts?: SortOrder
  }

  export type EnumMatchEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchEventType | EnumMatchEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchEventTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchEventTypeFilter<$PrismaModel>
  }

  export type EnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    challengerId?: SortOrder
    defenderId?: SortOrder
    venueId?: SortOrder
    status?: SortOrder
    stakeCoins?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    stakeCoins?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    challengerId?: SortOrder
    defenderId?: SortOrder
    venueId?: SortOrder
    status?: SortOrder
    stakeCoins?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    challengerId?: SortOrder
    defenderId?: SortOrder
    venueId?: SortOrder
    status?: SortOrder
    stakeCoins?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    stakeCoins?: SortOrder
  }

  export type EnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type WalletChainAddressCompoundUniqueInput = {
    chain: string
    address: string
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeFilter<$PrismaModel> | $Enums.TxType
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxTypeFilter<$PrismaModel>
    _max?: NestedEnumTxTypeFilter<$PrismaModel>
  }

  export type NFTContractTokenIdChainCompoundUniqueInput = {
    contract: string
    tokenId: string
    chain: string
  }

  export type NFTCountOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    chain?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NFTMaxOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    chain?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NFTMinOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    chain?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NFTRelationFilter = {
    is?: NFTWhereInput
    isNot?: NFTWhereInput
  }

  export type UserNFTUserIdNftIdCompoundUniqueInput = {
    userId: string
    nftId: string
  }

  export type UserNFTCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nftId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNFTMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nftId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNFTMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nftId?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    description?: SortOrder
    category?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    earnedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    payload?: SortOrder
    read?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    payload?: SortOrder
    read?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    payload?: SortOrder
    read?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    metadata?: SortOrder
    ts?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    metadata?: SortOrder
    ts?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    metadata?: SortOrder
    ts?: SortOrder
  }

  export type EnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type FriendshipRequesterIdAddresseeIdCompoundUniqueInput = {
    requesterId: string
    addresseeId: string
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    read?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchNullableRelationFilter = {
    is?: MatchWhereInput | null
    isNot?: MatchWhereInput | null
  }

  export type ActivityEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrder
    venueId?: SortOrder
    matchId?: SortOrder
    tournamentId?: SortOrder
    clanId?: SortOrder
    metadata?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrder
    venueId?: SortOrder
    matchId?: SortOrder
    tournamentId?: SortOrder
    clanId?: SortOrder
    metadata?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrder
    venueId?: SortOrder
    matchId?: SortOrder
    tournamentId?: SortOrder
    clanId?: SortOrder
    metadata?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueQuestCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    rewardDojoCoins?: SortOrder
    active?: SortOrder
    isActive?: SortOrder
    requirements?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueQuestAvgOrderByAggregateInput = {
    rewardDojoCoins?: SortOrder
  }

  export type VenueQuestMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    rewardDojoCoins?: SortOrder
    active?: SortOrder
    isActive?: SortOrder
    requirements?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueQuestMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    reward?: SortOrder
    rewardDojoCoins?: SortOrder
    active?: SortOrder
    isActive?: SortOrder
    requirements?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueQuestSumOrderByAggregateInput = {
    rewardDojoCoins?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type GameSessionCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    venueId?: SortOrder
    status?: SortOrder
    gameType?: SortOrder
    rules?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    playerIds?: SortOrder
    currentPlayerId?: SortOrder
    ballStates?: SortOrder
    fouls?: SortOrder
    score?: SortOrder
    events?: SortOrder
    totalShots?: SortOrder
    totalFouls?: SortOrder
    totalFrames?: SortOrder
    lastUpdated?: SortOrder
    winnerId?: SortOrder
    data?: SortOrder
    frameCount?: SortOrder
    shotCount?: SortOrder
    foulCount?: SortOrder
    shots?: SortOrder
    statistics?: SortOrder
    aiCommentary?: SortOrder
    matchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    totalShots?: SortOrder
    totalFouls?: SortOrder
    totalFrames?: SortOrder
    frameCount?: SortOrder
    shotCount?: SortOrder
    foulCount?: SortOrder
  }

  export type GameSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    venueId?: SortOrder
    status?: SortOrder
    gameType?: SortOrder
    rules?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    playerIds?: SortOrder
    currentPlayerId?: SortOrder
    ballStates?: SortOrder
    fouls?: SortOrder
    score?: SortOrder
    events?: SortOrder
    totalShots?: SortOrder
    totalFouls?: SortOrder
    totalFrames?: SortOrder
    lastUpdated?: SortOrder
    winnerId?: SortOrder
    frameCount?: SortOrder
    shotCount?: SortOrder
    foulCount?: SortOrder
    shots?: SortOrder
    statistics?: SortOrder
    aiCommentary?: SortOrder
    matchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSessionMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    gameId?: SortOrder
    venueId?: SortOrder
    status?: SortOrder
    gameType?: SortOrder
    rules?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    playerIds?: SortOrder
    currentPlayerId?: SortOrder
    ballStates?: SortOrder
    fouls?: SortOrder
    score?: SortOrder
    events?: SortOrder
    totalShots?: SortOrder
    totalFouls?: SortOrder
    totalFrames?: SortOrder
    lastUpdated?: SortOrder
    winnerId?: SortOrder
    frameCount?: SortOrder
    shotCount?: SortOrder
    foulCount?: SortOrder
    shots?: SortOrder
    statistics?: SortOrder
    aiCommentary?: SortOrder
    matchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    totalShots?: SortOrder
    totalFouls?: SortOrder
    totalFrames?: SortOrder
    frameCount?: SortOrder
    shotCount?: SortOrder
    foulCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CommunityCosmeticItemNullableRelationFilter = {
    is?: CommunityCosmeticItemWhereInput | null
    isNot?: CommunityCosmeticItemWhereInput | null
  }

  export type MarketplaceItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    available?: SortOrder
    communityItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MarketplaceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    available?: SortOrder
    communityItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    category?: SortOrder
    imageUrl?: SortOrder
    available?: SortOrder
    communityItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumCosmeticCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CosmeticCategory | EnumCosmeticCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCosmeticCategoryFilter<$PrismaModel> | $Enums.CosmeticCategory
  }

  export type EnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type MarketplaceItemNullableRelationFilter = {
    is?: MarketplaceItemWhereInput | null
    isNot?: MarketplaceItemWhereInput | null
  }

  export type CommunityCosmeticItemCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    designFileUrl?: SortOrder
    previewImageUrl?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedItemId?: SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityCosmeticItemAvgOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type CommunityCosmeticItemMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    designFileUrl?: SortOrder
    previewImageUrl?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedItemId?: SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityCosmeticItemMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    designFileUrl?: SortOrder
    previewImageUrl?: SortOrder
    status?: SortOrder
    rejectionReason?: SortOrder
    approvedItemId?: SortOrder
    reviewerId?: SortOrder
    reviewedAt?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityCosmeticItemSumOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type EnumCosmeticCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CosmeticCategory | EnumCosmeticCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCosmeticCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CosmeticCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCosmeticCategoryFilter<$PrismaModel>
    _max?: NestedEnumCosmeticCategoryFilter<$PrismaModel>
  }

  export type EnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type CommunityCosmeticItemRelationFilter = {
    is?: CommunityCosmeticItemWhereInput
    isNot?: CommunityCosmeticItemWhereInput
  }

  export type CosmeticItemLikeUserIdCosmeticItemIdCompoundUniqueInput = {
    userId: string
    cosmeticItemId: string
  }

  export type CosmeticItemLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cosmeticItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type CosmeticItemLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cosmeticItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type CosmeticItemLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cosmeticItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShadowRunCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    reward?: SortOrder
    completedAt?: SortOrder
    initiatingClanId?: SortOrder
    targetVenueId?: SortOrder
    outcome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShadowRunAvgOrderByAggregateInput = {
    cost?: SortOrder
    reward?: SortOrder
  }

  export type ShadowRunMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    reward?: SortOrder
    completedAt?: SortOrder
    initiatingClanId?: SortOrder
    targetVenueId?: SortOrder
    outcome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShadowRunMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    reward?: SortOrder
    completedAt?: SortOrder
    initiatingClanId?: SortOrder
    targetVenueId?: SortOrder
    outcome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShadowRunSumOrderByAggregateInput = {
    cost?: SortOrder
    reward?: SortOrder
  }

  export type DojoCheckInCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    createdAt?: SortOrder
  }

  export type DojoCheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    createdAt?: SortOrder
  }

  export type DojoCheckInMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    createdAt?: SortOrder
  }

  export type VenueSpecialCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueSpecialMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueSpecialMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemRelationFilter = {
    is?: MarketplaceItemWhereInput
    isNot?: MarketplaceItemWhereInput
  }

  export type UserInventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketplaceItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserInventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketplaceItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserInventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    marketplaceItemId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type EnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }

  export type EnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    adminNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
  }

  export type EnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type EnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }

  export type EnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type EnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type EnumContentVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentVisibility | EnumContentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumContentVisibilityFilter<$PrismaModel> | $Enums.ContentVisibility
  }

  export type ContentCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    moderationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentAvgOrderByAggregateInput = {
    likes?: SortOrder
    shares?: SortOrder
    views?: SortOrder
  }

  export type ContentMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    moderationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    shares?: SortOrder
    views?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    moderationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentSumOrderByAggregateInput = {
    likes?: SortOrder
    shares?: SortOrder
    views?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type EnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type EnumContentVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentVisibility | EnumContentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumContentVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ContentVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentVisibilityFilter<$PrismaModel>
    _max?: NestedEnumContentVisibilityFilter<$PrismaModel>
  }

  export type ContentRelationFilter = {
    is?: ContentWhereInput
    isNot?: ContentWhereInput
  }

  export type ContentLikeContentIdUserIdCompoundUniqueInput = {
    contentId: string
    userId: string
  }

  export type ContentLikeCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentLikeAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type ContentLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentLikeMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentLikeSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type ContentShareContentIdUserIdSharedWithIdCompoundUniqueInput = {
    contentId: string
    userId: string
    sharedWithId: string
  }

  export type ContentShareCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    sharedWithId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentShareMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    sharedWithId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentShareMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    userId?: SortOrder
    sharedWithId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    deviceInfo?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    deviceInfo?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    deviceInfo?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type WalletCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type UserNFTCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNFTCreateWithoutUserInput, UserNFTUncheckedCreateWithoutUserInput> | UserNFTCreateWithoutUserInput[] | UserNFTUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutUserInput | UserNFTCreateOrConnectWithoutUserInput[]
    createMany?: UserNFTCreateManyUserInputEnvelope
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type ClanMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ClanMemberCreateWithoutUserInput, ClanMemberUncheckedCreateWithoutUserInput> | ClanMemberCreateWithoutUserInput[] | ClanMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutUserInput | ClanMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClanMemberCreateManyUserInputEnvelope
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
  }

  export type TerritoryCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TerritoryCreateWithoutOwnerInput, TerritoryUncheckedCreateWithoutOwnerInput> | TerritoryCreateWithoutOwnerInput[] | TerritoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutOwnerInput | TerritoryCreateOrConnectWithoutOwnerInput[]
    createMany?: TerritoryCreateManyOwnerInputEnvelope
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
  }

  export type CheckInCreateNestedManyWithoutUserInput = {
    create?: XOR<CheckInCreateWithoutUserInput, CheckInUncheckedCreateWithoutUserInput> | CheckInCreateWithoutUserInput[] | CheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutUserInput | CheckInCreateOrConnectWithoutUserInput[]
    createMany?: CheckInCreateManyUserInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type ChallengeCreateNestedManyWithoutChallengerInput = {
    create?: XOR<ChallengeCreateWithoutChallengerInput, ChallengeUncheckedCreateWithoutChallengerInput> | ChallengeCreateWithoutChallengerInput[] | ChallengeUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengerInput | ChallengeCreateOrConnectWithoutChallengerInput[]
    createMany?: ChallengeCreateManyChallengerInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ChallengeCreateNestedManyWithoutDefenderInput = {
    create?: XOR<ChallengeCreateWithoutDefenderInput, ChallengeUncheckedCreateWithoutDefenderInput> | ChallengeCreateWithoutDefenderInput[] | ChallengeUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutDefenderInput | ChallengeCreateOrConnectWithoutDefenderInput[]
    createMany?: ChallengeCreateManyDefenderInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ClanCreateNestedManyWithoutLeaderInput = {
    create?: XOR<ClanCreateWithoutLeaderInput, ClanUncheckedCreateWithoutLeaderInput> | ClanCreateWithoutLeaderInput[] | ClanUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClanCreateOrConnectWithoutLeaderInput | ClanCreateOrConnectWithoutLeaderInput[]
    createMany?: ClanCreateManyLeaderInputEnvelope
    connect?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutPlayerAInput = {
    create?: XOR<MatchCreateWithoutPlayerAInput, MatchUncheckedCreateWithoutPlayerAInput> | MatchCreateWithoutPlayerAInput[] | MatchUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerAInput | MatchCreateOrConnectWithoutPlayerAInput[]
    createMany?: MatchCreateManyPlayerAInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutPlayerBInput = {
    create?: XOR<MatchCreateWithoutPlayerBInput, MatchUncheckedCreateWithoutPlayerBInput> | MatchCreateWithoutPlayerBInput[] | MatchUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerBInput | MatchCreateOrConnectWithoutPlayerBInput[]
    createMany?: MatchCreateManyPlayerBInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type TournamentParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamentParticipantCreateWithoutUserInput, TournamentParticipantUncheckedCreateWithoutUserInput> | TournamentParticipantCreateWithoutUserInput[] | TournamentParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutUserInput | TournamentParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TournamentParticipantCreateManyUserInputEnvelope
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type VenueCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VenueCreateWithoutOwnerInput, VenueUncheckedCreateWithoutOwnerInput> | VenueCreateWithoutOwnerInput[] | VenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOwnerInput | VenueCreateOrConnectWithoutOwnerInput[]
    createMany?: VenueCreateManyOwnerInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutRequesterInput = {
    create?: XOR<FriendshipCreateWithoutRequesterInput, FriendshipUncheckedCreateWithoutRequesterInput> | FriendshipCreateWithoutRequesterInput[] | FriendshipUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutRequesterInput | FriendshipCreateOrConnectWithoutRequesterInput[]
    createMany?: FriendshipCreateManyRequesterInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutAddresseeInput = {
    create?: XOR<FriendshipCreateWithoutAddresseeInput, FriendshipUncheckedCreateWithoutAddresseeInput> | FriendshipCreateWithoutAddresseeInput[] | FriendshipUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutAddresseeInput | FriendshipCreateOrConnectWithoutAddresseeInput[]
    createMany?: FriendshipCreateManyAddresseeInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type DirectMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type DirectMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type ActivityEventCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityEventCreateWithoutUserInput, ActivityEventUncheckedCreateWithoutUserInput> | ActivityEventCreateWithoutUserInput[] | ActivityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutUserInput | ActivityEventCreateOrConnectWithoutUserInput[]
    createMany?: ActivityEventCreateManyUserInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type GameSessionCreateNestedManyWithoutPlayerInput = {
    create?: XOR<GameSessionCreateWithoutPlayerInput, GameSessionUncheckedCreateWithoutPlayerInput> | GameSessionCreateWithoutPlayerInput[] | GameSessionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutPlayerInput | GameSessionCreateOrConnectWithoutPlayerInput[]
    createMany?: GameSessionCreateManyPlayerInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type ShadowRunCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ShadowRunCreateWithoutPlayerInput, ShadowRunUncheckedCreateWithoutPlayerInput> | ShadowRunCreateWithoutPlayerInput[] | ShadowRunUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutPlayerInput | ShadowRunCreateOrConnectWithoutPlayerInput[]
    createMany?: ShadowRunCreateManyPlayerInputEnvelope
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
  }

  export type DojoCheckInCreateNestedManyWithoutUserInput = {
    create?: XOR<DojoCheckInCreateWithoutUserInput, DojoCheckInUncheckedCreateWithoutUserInput> | DojoCheckInCreateWithoutUserInput[] | DojoCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutUserInput | DojoCheckInCreateOrConnectWithoutUserInput[]
    createMany?: DojoCheckInCreateManyUserInputEnvelope
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
  }

  export type UserInventoryItemCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutResolverInput = {
    create?: XOR<FeedbackCreateWithoutResolverInput, FeedbackUncheckedCreateWithoutResolverInput> | FeedbackCreateWithoutResolverInput[] | FeedbackUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutResolverInput | FeedbackCreateOrConnectWithoutResolverInput[]
    createMany?: FeedbackCreateManyResolverInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ContentCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentCreateWithoutUserInput, ContentUncheckedCreateWithoutUserInput> | ContentCreateWithoutUserInput[] | ContentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutUserInput | ContentCreateOrConnectWithoutUserInput[]
    createMany?: ContentCreateManyUserInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ContentCreateNestedManyWithoutModeratorInput = {
    create?: XOR<ContentCreateWithoutModeratorInput, ContentUncheckedCreateWithoutModeratorInput> | ContentCreateWithoutModeratorInput[] | ContentUncheckedCreateWithoutModeratorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutModeratorInput | ContentCreateOrConnectWithoutModeratorInput[]
    createMany?: ContentCreateManyModeratorInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ContentLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentLikeCreateWithoutUserInput, ContentLikeUncheckedCreateWithoutUserInput> | ContentLikeCreateWithoutUserInput[] | ContentLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutUserInput | ContentLikeCreateOrConnectWithoutUserInput[]
    createMany?: ContentLikeCreateManyUserInputEnvelope
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type ContentShareCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentShareCreateWithoutUserInput, ContentShareUncheckedCreateWithoutUserInput> | ContentShareCreateWithoutUserInput[] | ContentShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutUserInput | ContentShareCreateOrConnectWithoutUserInput[]
    createMany?: ContentShareCreateManyUserInputEnvelope
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
  }

  export type ContentShareCreateNestedManyWithoutSharedWithInput = {
    create?: XOR<ContentShareCreateWithoutSharedWithInput, ContentShareUncheckedCreateWithoutSharedWithInput> | ContentShareCreateWithoutSharedWithInput[] | ContentShareUncheckedCreateWithoutSharedWithInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutSharedWithInput | ContentShareCreateOrConnectWithoutSharedWithInput[]
    createMany?: ContentShareCreateManySharedWithInputEnvelope
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
  }

  export type CommunityCosmeticItemCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutCreatorInput, CommunityCosmeticItemUncheckedCreateWithoutCreatorInput> | CommunityCosmeticItemCreateWithoutCreatorInput[] | CommunityCosmeticItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutCreatorInput | CommunityCosmeticItemCreateOrConnectWithoutCreatorInput[]
    createMany?: CommunityCosmeticItemCreateManyCreatorInputEnvelope
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
  }

  export type CommunityCosmeticItemCreateNestedManyWithoutReviewerInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutReviewerInput, CommunityCosmeticItemUncheckedCreateWithoutReviewerInput> | CommunityCosmeticItemCreateWithoutReviewerInput[] | CommunityCosmeticItemUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutReviewerInput | CommunityCosmeticItemCreateOrConnectWithoutReviewerInput[]
    createMany?: CommunityCosmeticItemCreateManyReviewerInputEnvelope
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
  }

  export type CosmeticItemLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutUserInput, CosmeticItemLikeUncheckedCreateWithoutUserInput> | CosmeticItemLikeCreateWithoutUserInput[] | CosmeticItemLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutUserInput | CosmeticItemLikeCreateOrConnectWithoutUserInput[]
    createMany?: CosmeticItemLikeCreateManyUserInputEnvelope
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type WalletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type UserNFTUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNFTCreateWithoutUserInput, UserNFTUncheckedCreateWithoutUserInput> | UserNFTCreateWithoutUserInput[] | UserNFTUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutUserInput | UserNFTCreateOrConnectWithoutUserInput[]
    createMany?: UserNFTCreateManyUserInputEnvelope
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type ClanMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClanMemberCreateWithoutUserInput, ClanMemberUncheckedCreateWithoutUserInput> | ClanMemberCreateWithoutUserInput[] | ClanMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutUserInput | ClanMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClanMemberCreateManyUserInputEnvelope
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
  }

  export type TerritoryUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TerritoryCreateWithoutOwnerInput, TerritoryUncheckedCreateWithoutOwnerInput> | TerritoryCreateWithoutOwnerInput[] | TerritoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutOwnerInput | TerritoryCreateOrConnectWithoutOwnerInput[]
    createMany?: TerritoryCreateManyOwnerInputEnvelope
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
  }

  export type CheckInUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CheckInCreateWithoutUserInput, CheckInUncheckedCreateWithoutUserInput> | CheckInCreateWithoutUserInput[] | CheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutUserInput | CheckInCreateOrConnectWithoutUserInput[]
    createMany?: CheckInCreateManyUserInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutChallengerInput = {
    create?: XOR<ChallengeCreateWithoutChallengerInput, ChallengeUncheckedCreateWithoutChallengerInput> | ChallengeCreateWithoutChallengerInput[] | ChallengeUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengerInput | ChallengeCreateOrConnectWithoutChallengerInput[]
    createMany?: ChallengeCreateManyChallengerInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutDefenderInput = {
    create?: XOR<ChallengeCreateWithoutDefenderInput, ChallengeUncheckedCreateWithoutDefenderInput> | ChallengeCreateWithoutDefenderInput[] | ChallengeUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutDefenderInput | ChallengeCreateOrConnectWithoutDefenderInput[]
    createMany?: ChallengeCreateManyDefenderInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type ClanUncheckedCreateNestedManyWithoutLeaderInput = {
    create?: XOR<ClanCreateWithoutLeaderInput, ClanUncheckedCreateWithoutLeaderInput> | ClanCreateWithoutLeaderInput[] | ClanUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClanCreateOrConnectWithoutLeaderInput | ClanCreateOrConnectWithoutLeaderInput[]
    createMany?: ClanCreateManyLeaderInputEnvelope
    connect?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutPlayerAInput = {
    create?: XOR<MatchCreateWithoutPlayerAInput, MatchUncheckedCreateWithoutPlayerAInput> | MatchCreateWithoutPlayerAInput[] | MatchUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerAInput | MatchCreateOrConnectWithoutPlayerAInput[]
    createMany?: MatchCreateManyPlayerAInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutPlayerBInput = {
    create?: XOR<MatchCreateWithoutPlayerBInput, MatchUncheckedCreateWithoutPlayerBInput> | MatchCreateWithoutPlayerBInput[] | MatchUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerBInput | MatchCreateOrConnectWithoutPlayerBInput[]
    createMany?: MatchCreateManyPlayerBInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type TournamentParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamentParticipantCreateWithoutUserInput, TournamentParticipantUncheckedCreateWithoutUserInput> | TournamentParticipantCreateWithoutUserInput[] | TournamentParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutUserInput | TournamentParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TournamentParticipantCreateManyUserInputEnvelope
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VenueCreateWithoutOwnerInput, VenueUncheckedCreateWithoutOwnerInput> | VenueCreateWithoutOwnerInput[] | VenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOwnerInput | VenueCreateOrConnectWithoutOwnerInput[]
    createMany?: VenueCreateManyOwnerInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<FriendshipCreateWithoutRequesterInput, FriendshipUncheckedCreateWithoutRequesterInput> | FriendshipCreateWithoutRequesterInput[] | FriendshipUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutRequesterInput | FriendshipCreateOrConnectWithoutRequesterInput[]
    createMany?: FriendshipCreateManyRequesterInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutAddresseeInput = {
    create?: XOR<FriendshipCreateWithoutAddresseeInput, FriendshipUncheckedCreateWithoutAddresseeInput> | FriendshipCreateWithoutAddresseeInput[] | FriendshipUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutAddresseeInput | FriendshipCreateOrConnectWithoutAddresseeInput[]
    createMany?: FriendshipCreateManyAddresseeInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type ActivityEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityEventCreateWithoutUserInput, ActivityEventUncheckedCreateWithoutUserInput> | ActivityEventCreateWithoutUserInput[] | ActivityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutUserInput | ActivityEventCreateOrConnectWithoutUserInput[]
    createMany?: ActivityEventCreateManyUserInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<GameSessionCreateWithoutPlayerInput, GameSessionUncheckedCreateWithoutPlayerInput> | GameSessionCreateWithoutPlayerInput[] | GameSessionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutPlayerInput | GameSessionCreateOrConnectWithoutPlayerInput[]
    createMany?: GameSessionCreateManyPlayerInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type ShadowRunUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ShadowRunCreateWithoutPlayerInput, ShadowRunUncheckedCreateWithoutPlayerInput> | ShadowRunCreateWithoutPlayerInput[] | ShadowRunUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutPlayerInput | ShadowRunCreateOrConnectWithoutPlayerInput[]
    createMany?: ShadowRunCreateManyPlayerInputEnvelope
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
  }

  export type DojoCheckInUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DojoCheckInCreateWithoutUserInput, DojoCheckInUncheckedCreateWithoutUserInput> | DojoCheckInCreateWithoutUserInput[] | DojoCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutUserInput | DojoCheckInCreateOrConnectWithoutUserInput[]
    createMany?: DojoCheckInCreateManyUserInputEnvelope
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
  }

  export type UserInventoryItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutResolverInput = {
    create?: XOR<FeedbackCreateWithoutResolverInput, FeedbackUncheckedCreateWithoutResolverInput> | FeedbackCreateWithoutResolverInput[] | FeedbackUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutResolverInput | FeedbackCreateOrConnectWithoutResolverInput[]
    createMany?: FeedbackCreateManyResolverInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentCreateWithoutUserInput, ContentUncheckedCreateWithoutUserInput> | ContentCreateWithoutUserInput[] | ContentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutUserInput | ContentCreateOrConnectWithoutUserInput[]
    createMany?: ContentCreateManyUserInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ContentUncheckedCreateNestedManyWithoutModeratorInput = {
    create?: XOR<ContentCreateWithoutModeratorInput, ContentUncheckedCreateWithoutModeratorInput> | ContentCreateWithoutModeratorInput[] | ContentUncheckedCreateWithoutModeratorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutModeratorInput | ContentCreateOrConnectWithoutModeratorInput[]
    createMany?: ContentCreateManyModeratorInputEnvelope
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
  }

  export type ContentLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentLikeCreateWithoutUserInput, ContentLikeUncheckedCreateWithoutUserInput> | ContentLikeCreateWithoutUserInput[] | ContentLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutUserInput | ContentLikeCreateOrConnectWithoutUserInput[]
    createMany?: ContentLikeCreateManyUserInputEnvelope
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type ContentShareUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContentShareCreateWithoutUserInput, ContentShareUncheckedCreateWithoutUserInput> | ContentShareCreateWithoutUserInput[] | ContentShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutUserInput | ContentShareCreateOrConnectWithoutUserInput[]
    createMany?: ContentShareCreateManyUserInputEnvelope
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
  }

  export type ContentShareUncheckedCreateNestedManyWithoutSharedWithInput = {
    create?: XOR<ContentShareCreateWithoutSharedWithInput, ContentShareUncheckedCreateWithoutSharedWithInput> | ContentShareCreateWithoutSharedWithInput[] | ContentShareUncheckedCreateWithoutSharedWithInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutSharedWithInput | ContentShareCreateOrConnectWithoutSharedWithInput[]
    createMany?: ContentShareCreateManySharedWithInputEnvelope
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
  }

  export type CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutCreatorInput, CommunityCosmeticItemUncheckedCreateWithoutCreatorInput> | CommunityCosmeticItemCreateWithoutCreatorInput[] | CommunityCosmeticItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutCreatorInput | CommunityCosmeticItemCreateOrConnectWithoutCreatorInput[]
    createMany?: CommunityCosmeticItemCreateManyCreatorInputEnvelope
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
  }

  export type CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutReviewerInput, CommunityCosmeticItemUncheckedCreateWithoutReviewerInput> | CommunityCosmeticItemCreateWithoutReviewerInput[] | CommunityCosmeticItemUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutReviewerInput | CommunityCosmeticItemCreateOrConnectWithoutReviewerInput[]
    createMany?: CommunityCosmeticItemCreateManyReviewerInputEnvelope
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
  }

  export type CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutUserInput, CosmeticItemLikeUncheckedCreateWithoutUserInput> | CosmeticItemLikeCreateWithoutUserInput[] | CosmeticItemLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutUserInput | CosmeticItemLikeCreateOrConnectWithoutUserInput[]
    createMany?: CosmeticItemLikeCreateManyUserInputEnvelope
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutUserInput | WalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutUserInput | WalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutUserInput | WalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type UserNFTUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNFTCreateWithoutUserInput, UserNFTUncheckedCreateWithoutUserInput> | UserNFTCreateWithoutUserInput[] | UserNFTUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutUserInput | UserNFTCreateOrConnectWithoutUserInput[]
    upsert?: UserNFTUpsertWithWhereUniqueWithoutUserInput | UserNFTUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNFTCreateManyUserInputEnvelope
    set?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    disconnect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    delete?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    update?: UserNFTUpdateWithWhereUniqueWithoutUserInput | UserNFTUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNFTUpdateManyWithWhereWithoutUserInput | UserNFTUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNFTScalarWhereInput | UserNFTScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type ClanMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClanMemberCreateWithoutUserInput, ClanMemberUncheckedCreateWithoutUserInput> | ClanMemberCreateWithoutUserInput[] | ClanMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutUserInput | ClanMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClanMemberUpsertWithWhereUniqueWithoutUserInput | ClanMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClanMemberCreateManyUserInputEnvelope
    set?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    disconnect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    delete?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    update?: ClanMemberUpdateWithWhereUniqueWithoutUserInput | ClanMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClanMemberUpdateManyWithWhereWithoutUserInput | ClanMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClanMemberScalarWhereInput | ClanMemberScalarWhereInput[]
  }

  export type TerritoryUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TerritoryCreateWithoutOwnerInput, TerritoryUncheckedCreateWithoutOwnerInput> | TerritoryCreateWithoutOwnerInput[] | TerritoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutOwnerInput | TerritoryCreateOrConnectWithoutOwnerInput[]
    upsert?: TerritoryUpsertWithWhereUniqueWithoutOwnerInput | TerritoryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TerritoryCreateManyOwnerInputEnvelope
    set?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    disconnect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    delete?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    update?: TerritoryUpdateWithWhereUniqueWithoutOwnerInput | TerritoryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TerritoryUpdateManyWithWhereWithoutOwnerInput | TerritoryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
  }

  export type CheckInUpdateManyWithoutUserNestedInput = {
    create?: XOR<CheckInCreateWithoutUserInput, CheckInUncheckedCreateWithoutUserInput> | CheckInCreateWithoutUserInput[] | CheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutUserInput | CheckInCreateOrConnectWithoutUserInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutUserInput | CheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CheckInCreateManyUserInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutUserInput | CheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutUserInput | CheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type ChallengeUpdateManyWithoutChallengerNestedInput = {
    create?: XOR<ChallengeCreateWithoutChallengerInput, ChallengeUncheckedCreateWithoutChallengerInput> | ChallengeCreateWithoutChallengerInput[] | ChallengeUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengerInput | ChallengeCreateOrConnectWithoutChallengerInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutChallengerInput | ChallengeUpsertWithWhereUniqueWithoutChallengerInput[]
    createMany?: ChallengeCreateManyChallengerInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutChallengerInput | ChallengeUpdateWithWhereUniqueWithoutChallengerInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutChallengerInput | ChallengeUpdateManyWithWhereWithoutChallengerInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ChallengeUpdateManyWithoutDefenderNestedInput = {
    create?: XOR<ChallengeCreateWithoutDefenderInput, ChallengeUncheckedCreateWithoutDefenderInput> | ChallengeCreateWithoutDefenderInput[] | ChallengeUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutDefenderInput | ChallengeCreateOrConnectWithoutDefenderInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutDefenderInput | ChallengeUpsertWithWhereUniqueWithoutDefenderInput[]
    createMany?: ChallengeCreateManyDefenderInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutDefenderInput | ChallengeUpdateWithWhereUniqueWithoutDefenderInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutDefenderInput | ChallengeUpdateManyWithWhereWithoutDefenderInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ClanUpdateManyWithoutLeaderNestedInput = {
    create?: XOR<ClanCreateWithoutLeaderInput, ClanUncheckedCreateWithoutLeaderInput> | ClanCreateWithoutLeaderInput[] | ClanUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClanCreateOrConnectWithoutLeaderInput | ClanCreateOrConnectWithoutLeaderInput[]
    upsert?: ClanUpsertWithWhereUniqueWithoutLeaderInput | ClanUpsertWithWhereUniqueWithoutLeaderInput[]
    createMany?: ClanCreateManyLeaderInputEnvelope
    set?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    disconnect?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    delete?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    connect?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    update?: ClanUpdateWithWhereUniqueWithoutLeaderInput | ClanUpdateWithWhereUniqueWithoutLeaderInput[]
    updateMany?: ClanUpdateManyWithWhereWithoutLeaderInput | ClanUpdateManyWithWhereWithoutLeaderInput[]
    deleteMany?: ClanScalarWhereInput | ClanScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutPlayerANestedInput = {
    create?: XOR<MatchCreateWithoutPlayerAInput, MatchUncheckedCreateWithoutPlayerAInput> | MatchCreateWithoutPlayerAInput[] | MatchUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerAInput | MatchCreateOrConnectWithoutPlayerAInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayerAInput | MatchUpsertWithWhereUniqueWithoutPlayerAInput[]
    createMany?: MatchCreateManyPlayerAInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayerAInput | MatchUpdateWithWhereUniqueWithoutPlayerAInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayerAInput | MatchUpdateManyWithWhereWithoutPlayerAInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutPlayerBNestedInput = {
    create?: XOR<MatchCreateWithoutPlayerBInput, MatchUncheckedCreateWithoutPlayerBInput> | MatchCreateWithoutPlayerBInput[] | MatchUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerBInput | MatchCreateOrConnectWithoutPlayerBInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayerBInput | MatchUpsertWithWhereUniqueWithoutPlayerBInput[]
    createMany?: MatchCreateManyPlayerBInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayerBInput | MatchUpdateWithWhereUniqueWithoutPlayerBInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayerBInput | MatchUpdateManyWithWhereWithoutPlayerBInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type TournamentParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamentParticipantCreateWithoutUserInput, TournamentParticipantUncheckedCreateWithoutUserInput> | TournamentParticipantCreateWithoutUserInput[] | TournamentParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutUserInput | TournamentParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TournamentParticipantUpsertWithWhereUniqueWithoutUserInput | TournamentParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamentParticipantCreateManyUserInputEnvelope
    set?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    disconnect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    delete?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    update?: TournamentParticipantUpdateWithWhereUniqueWithoutUserInput | TournamentParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamentParticipantUpdateManyWithWhereWithoutUserInput | TournamentParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamentParticipantScalarWhereInput | TournamentParticipantScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type VenueUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VenueCreateWithoutOwnerInput, VenueUncheckedCreateWithoutOwnerInput> | VenueCreateWithoutOwnerInput[] | VenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOwnerInput | VenueCreateOrConnectWithoutOwnerInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutOwnerInput | VenueUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VenueCreateManyOwnerInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutOwnerInput | VenueUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutOwnerInput | VenueUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<FriendshipCreateWithoutRequesterInput, FriendshipUncheckedCreateWithoutRequesterInput> | FriendshipCreateWithoutRequesterInput[] | FriendshipUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutRequesterInput | FriendshipCreateOrConnectWithoutRequesterInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutRequesterInput | FriendshipUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: FriendshipCreateManyRequesterInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutRequesterInput | FriendshipUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutRequesterInput | FriendshipUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutAddresseeNestedInput = {
    create?: XOR<FriendshipCreateWithoutAddresseeInput, FriendshipUncheckedCreateWithoutAddresseeInput> | FriendshipCreateWithoutAddresseeInput[] | FriendshipUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutAddresseeInput | FriendshipCreateOrConnectWithoutAddresseeInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutAddresseeInput | FriendshipUpsertWithWhereUniqueWithoutAddresseeInput[]
    createMany?: FriendshipCreateManyAddresseeInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutAddresseeInput | FriendshipUpdateWithWhereUniqueWithoutAddresseeInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutAddresseeInput | FriendshipUpdateManyWithWhereWithoutAddresseeInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type DirectMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutSenderInput | DirectMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutSenderInput | DirectMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutSenderInput | DirectMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type DirectMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutReceiverInput | DirectMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutReceiverInput | DirectMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutReceiverInput | DirectMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type ActivityEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityEventCreateWithoutUserInput, ActivityEventUncheckedCreateWithoutUserInput> | ActivityEventCreateWithoutUserInput[] | ActivityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutUserInput | ActivityEventCreateOrConnectWithoutUserInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutUserInput | ActivityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityEventCreateManyUserInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutUserInput | ActivityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutUserInput | ActivityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type GameSessionUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<GameSessionCreateWithoutPlayerInput, GameSessionUncheckedCreateWithoutPlayerInput> | GameSessionCreateWithoutPlayerInput[] | GameSessionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutPlayerInput | GameSessionCreateOrConnectWithoutPlayerInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutPlayerInput | GameSessionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: GameSessionCreateManyPlayerInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutPlayerInput | GameSessionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutPlayerInput | GameSessionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type ShadowRunUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ShadowRunCreateWithoutPlayerInput, ShadowRunUncheckedCreateWithoutPlayerInput> | ShadowRunCreateWithoutPlayerInput[] | ShadowRunUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutPlayerInput | ShadowRunCreateOrConnectWithoutPlayerInput[]
    upsert?: ShadowRunUpsertWithWhereUniqueWithoutPlayerInput | ShadowRunUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ShadowRunCreateManyPlayerInputEnvelope
    set?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    disconnect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    delete?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    update?: ShadowRunUpdateWithWhereUniqueWithoutPlayerInput | ShadowRunUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ShadowRunUpdateManyWithWhereWithoutPlayerInput | ShadowRunUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
  }

  export type DojoCheckInUpdateManyWithoutUserNestedInput = {
    create?: XOR<DojoCheckInCreateWithoutUserInput, DojoCheckInUncheckedCreateWithoutUserInput> | DojoCheckInCreateWithoutUserInput[] | DojoCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutUserInput | DojoCheckInCreateOrConnectWithoutUserInput[]
    upsert?: DojoCheckInUpsertWithWhereUniqueWithoutUserInput | DojoCheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DojoCheckInCreateManyUserInputEnvelope
    set?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    disconnect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    delete?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    update?: DojoCheckInUpdateWithWhereUniqueWithoutUserInput | DojoCheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DojoCheckInUpdateManyWithWhereWithoutUserInput | DojoCheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DojoCheckInScalarWhereInput | DojoCheckInScalarWhereInput[]
  }

  export type UserInventoryItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryItemUpsertWithWhereUniqueWithoutUserInput | UserInventoryItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    set?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    disconnect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    delete?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    update?: UserInventoryItemUpdateWithWhereUniqueWithoutUserInput | UserInventoryItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryItemUpdateManyWithWhereWithoutUserInput | UserInventoryItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutResolverNestedInput = {
    create?: XOR<FeedbackCreateWithoutResolverInput, FeedbackUncheckedCreateWithoutResolverInput> | FeedbackCreateWithoutResolverInput[] | FeedbackUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutResolverInput | FeedbackCreateOrConnectWithoutResolverInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutResolverInput | FeedbackUpsertWithWhereUniqueWithoutResolverInput[]
    createMany?: FeedbackCreateManyResolverInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutResolverInput | FeedbackUpdateWithWhereUniqueWithoutResolverInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutResolverInput | FeedbackUpdateManyWithWhereWithoutResolverInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ContentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentCreateWithoutUserInput, ContentUncheckedCreateWithoutUserInput> | ContentCreateWithoutUserInput[] | ContentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutUserInput | ContentCreateOrConnectWithoutUserInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutUserInput | ContentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentCreateManyUserInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutUserInput | ContentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutUserInput | ContentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ContentUpdateManyWithoutModeratorNestedInput = {
    create?: XOR<ContentCreateWithoutModeratorInput, ContentUncheckedCreateWithoutModeratorInput> | ContentCreateWithoutModeratorInput[] | ContentUncheckedCreateWithoutModeratorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutModeratorInput | ContentCreateOrConnectWithoutModeratorInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutModeratorInput | ContentUpsertWithWhereUniqueWithoutModeratorInput[]
    createMany?: ContentCreateManyModeratorInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutModeratorInput | ContentUpdateWithWhereUniqueWithoutModeratorInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutModeratorInput | ContentUpdateManyWithWhereWithoutModeratorInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ContentLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentLikeCreateWithoutUserInput, ContentLikeUncheckedCreateWithoutUserInput> | ContentLikeCreateWithoutUserInput[] | ContentLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutUserInput | ContentLikeCreateOrConnectWithoutUserInput[]
    upsert?: ContentLikeUpsertWithWhereUniqueWithoutUserInput | ContentLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentLikeCreateManyUserInputEnvelope
    set?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    disconnect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    delete?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    update?: ContentLikeUpdateWithWhereUniqueWithoutUserInput | ContentLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentLikeUpdateManyWithWhereWithoutUserInput | ContentLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentLikeScalarWhereInput | ContentLikeScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type ContentShareUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentShareCreateWithoutUserInput, ContentShareUncheckedCreateWithoutUserInput> | ContentShareCreateWithoutUserInput[] | ContentShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutUserInput | ContentShareCreateOrConnectWithoutUserInput[]
    upsert?: ContentShareUpsertWithWhereUniqueWithoutUserInput | ContentShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentShareCreateManyUserInputEnvelope
    set?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    disconnect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    delete?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    update?: ContentShareUpdateWithWhereUniqueWithoutUserInput | ContentShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentShareUpdateManyWithWhereWithoutUserInput | ContentShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
  }

  export type ContentShareUpdateManyWithoutSharedWithNestedInput = {
    create?: XOR<ContentShareCreateWithoutSharedWithInput, ContentShareUncheckedCreateWithoutSharedWithInput> | ContentShareCreateWithoutSharedWithInput[] | ContentShareUncheckedCreateWithoutSharedWithInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutSharedWithInput | ContentShareCreateOrConnectWithoutSharedWithInput[]
    upsert?: ContentShareUpsertWithWhereUniqueWithoutSharedWithInput | ContentShareUpsertWithWhereUniqueWithoutSharedWithInput[]
    createMany?: ContentShareCreateManySharedWithInputEnvelope
    set?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    disconnect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    delete?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    update?: ContentShareUpdateWithWhereUniqueWithoutSharedWithInput | ContentShareUpdateWithWhereUniqueWithoutSharedWithInput[]
    updateMany?: ContentShareUpdateManyWithWhereWithoutSharedWithInput | ContentShareUpdateManyWithWhereWithoutSharedWithInput[]
    deleteMany?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
  }

  export type CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutCreatorInput, CommunityCosmeticItemUncheckedCreateWithoutCreatorInput> | CommunityCosmeticItemCreateWithoutCreatorInput[] | CommunityCosmeticItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutCreatorInput | CommunityCosmeticItemCreateOrConnectWithoutCreatorInput[]
    upsert?: CommunityCosmeticItemUpsertWithWhereUniqueWithoutCreatorInput | CommunityCosmeticItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CommunityCosmeticItemCreateManyCreatorInputEnvelope
    set?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    disconnect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    delete?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    update?: CommunityCosmeticItemUpdateWithWhereUniqueWithoutCreatorInput | CommunityCosmeticItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CommunityCosmeticItemUpdateManyWithWhereWithoutCreatorInput | CommunityCosmeticItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CommunityCosmeticItemScalarWhereInput | CommunityCosmeticItemScalarWhereInput[]
  }

  export type CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutReviewerInput, CommunityCosmeticItemUncheckedCreateWithoutReviewerInput> | CommunityCosmeticItemCreateWithoutReviewerInput[] | CommunityCosmeticItemUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutReviewerInput | CommunityCosmeticItemCreateOrConnectWithoutReviewerInput[]
    upsert?: CommunityCosmeticItemUpsertWithWhereUniqueWithoutReviewerInput | CommunityCosmeticItemUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: CommunityCosmeticItemCreateManyReviewerInputEnvelope
    set?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    disconnect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    delete?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    update?: CommunityCosmeticItemUpdateWithWhereUniqueWithoutReviewerInput | CommunityCosmeticItemUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: CommunityCosmeticItemUpdateManyWithWhereWithoutReviewerInput | CommunityCosmeticItemUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: CommunityCosmeticItemScalarWhereInput | CommunityCosmeticItemScalarWhereInput[]
  }

  export type CosmeticItemLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutUserInput, CosmeticItemLikeUncheckedCreateWithoutUserInput> | CosmeticItemLikeCreateWithoutUserInput[] | CosmeticItemLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutUserInput | CosmeticItemLikeCreateOrConnectWithoutUserInput[]
    upsert?: CosmeticItemLikeUpsertWithWhereUniqueWithoutUserInput | CosmeticItemLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CosmeticItemLikeCreateManyUserInputEnvelope
    set?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    disconnect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    delete?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    update?: CosmeticItemLikeUpdateWithWhereUniqueWithoutUserInput | CosmeticItemLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CosmeticItemLikeUpdateManyWithWhereWithoutUserInput | CosmeticItemLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CosmeticItemLikeScalarWhereInput | CosmeticItemLikeScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type WalletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutUserInput | WalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutUserInput | WalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutUserInput | WalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type UserNFTUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNFTCreateWithoutUserInput, UserNFTUncheckedCreateWithoutUserInput> | UserNFTCreateWithoutUserInput[] | UserNFTUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutUserInput | UserNFTCreateOrConnectWithoutUserInput[]
    upsert?: UserNFTUpsertWithWhereUniqueWithoutUserInput | UserNFTUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNFTCreateManyUserInputEnvelope
    set?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    disconnect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    delete?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    update?: UserNFTUpdateWithWhereUniqueWithoutUserInput | UserNFTUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNFTUpdateManyWithWhereWithoutUserInput | UserNFTUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNFTScalarWhereInput | UserNFTScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type ClanMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClanMemberCreateWithoutUserInput, ClanMemberUncheckedCreateWithoutUserInput> | ClanMemberCreateWithoutUserInput[] | ClanMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutUserInput | ClanMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClanMemberUpsertWithWhereUniqueWithoutUserInput | ClanMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClanMemberCreateManyUserInputEnvelope
    set?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    disconnect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    delete?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    update?: ClanMemberUpdateWithWhereUniqueWithoutUserInput | ClanMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClanMemberUpdateManyWithWhereWithoutUserInput | ClanMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClanMemberScalarWhereInput | ClanMemberScalarWhereInput[]
  }

  export type TerritoryUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TerritoryCreateWithoutOwnerInput, TerritoryUncheckedCreateWithoutOwnerInput> | TerritoryCreateWithoutOwnerInput[] | TerritoryUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutOwnerInput | TerritoryCreateOrConnectWithoutOwnerInput[]
    upsert?: TerritoryUpsertWithWhereUniqueWithoutOwnerInput | TerritoryUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TerritoryCreateManyOwnerInputEnvelope
    set?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    disconnect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    delete?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    update?: TerritoryUpdateWithWhereUniqueWithoutOwnerInput | TerritoryUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TerritoryUpdateManyWithWhereWithoutOwnerInput | TerritoryUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
  }

  export type CheckInUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CheckInCreateWithoutUserInput, CheckInUncheckedCreateWithoutUserInput> | CheckInCreateWithoutUserInput[] | CheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutUserInput | CheckInCreateOrConnectWithoutUserInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutUserInput | CheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CheckInCreateManyUserInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutUserInput | CheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutUserInput | CheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutChallengerNestedInput = {
    create?: XOR<ChallengeCreateWithoutChallengerInput, ChallengeUncheckedCreateWithoutChallengerInput> | ChallengeCreateWithoutChallengerInput[] | ChallengeUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutChallengerInput | ChallengeCreateOrConnectWithoutChallengerInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutChallengerInput | ChallengeUpsertWithWhereUniqueWithoutChallengerInput[]
    createMany?: ChallengeCreateManyChallengerInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutChallengerInput | ChallengeUpdateWithWhereUniqueWithoutChallengerInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutChallengerInput | ChallengeUpdateManyWithWhereWithoutChallengerInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutDefenderNestedInput = {
    create?: XOR<ChallengeCreateWithoutDefenderInput, ChallengeUncheckedCreateWithoutDefenderInput> | ChallengeCreateWithoutDefenderInput[] | ChallengeUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutDefenderInput | ChallengeCreateOrConnectWithoutDefenderInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutDefenderInput | ChallengeUpsertWithWhereUniqueWithoutDefenderInput[]
    createMany?: ChallengeCreateManyDefenderInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutDefenderInput | ChallengeUpdateWithWhereUniqueWithoutDefenderInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutDefenderInput | ChallengeUpdateManyWithWhereWithoutDefenderInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type ClanUncheckedUpdateManyWithoutLeaderNestedInput = {
    create?: XOR<ClanCreateWithoutLeaderInput, ClanUncheckedCreateWithoutLeaderInput> | ClanCreateWithoutLeaderInput[] | ClanUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClanCreateOrConnectWithoutLeaderInput | ClanCreateOrConnectWithoutLeaderInput[]
    upsert?: ClanUpsertWithWhereUniqueWithoutLeaderInput | ClanUpsertWithWhereUniqueWithoutLeaderInput[]
    createMany?: ClanCreateManyLeaderInputEnvelope
    set?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    disconnect?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    delete?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    connect?: ClanWhereUniqueInput | ClanWhereUniqueInput[]
    update?: ClanUpdateWithWhereUniqueWithoutLeaderInput | ClanUpdateWithWhereUniqueWithoutLeaderInput[]
    updateMany?: ClanUpdateManyWithWhereWithoutLeaderInput | ClanUpdateManyWithWhereWithoutLeaderInput[]
    deleteMany?: ClanScalarWhereInput | ClanScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutPlayerANestedInput = {
    create?: XOR<MatchCreateWithoutPlayerAInput, MatchUncheckedCreateWithoutPlayerAInput> | MatchCreateWithoutPlayerAInput[] | MatchUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerAInput | MatchCreateOrConnectWithoutPlayerAInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayerAInput | MatchUpsertWithWhereUniqueWithoutPlayerAInput[]
    createMany?: MatchCreateManyPlayerAInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayerAInput | MatchUpdateWithWhereUniqueWithoutPlayerAInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayerAInput | MatchUpdateManyWithWhereWithoutPlayerAInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutPlayerBNestedInput = {
    create?: XOR<MatchCreateWithoutPlayerBInput, MatchUncheckedCreateWithoutPlayerBInput> | MatchCreateWithoutPlayerBInput[] | MatchUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayerBInput | MatchCreateOrConnectWithoutPlayerBInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayerBInput | MatchUpsertWithWhereUniqueWithoutPlayerBInput[]
    createMany?: MatchCreateManyPlayerBInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayerBInput | MatchUpdateWithWhereUniqueWithoutPlayerBInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayerBInput | MatchUpdateManyWithWhereWithoutPlayerBInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamentParticipantCreateWithoutUserInput, TournamentParticipantUncheckedCreateWithoutUserInput> | TournamentParticipantCreateWithoutUserInput[] | TournamentParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutUserInput | TournamentParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TournamentParticipantUpsertWithWhereUniqueWithoutUserInput | TournamentParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamentParticipantCreateManyUserInputEnvelope
    set?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    disconnect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    delete?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    update?: TournamentParticipantUpdateWithWhereUniqueWithoutUserInput | TournamentParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamentParticipantUpdateManyWithWhereWithoutUserInput | TournamentParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamentParticipantScalarWhereInput | TournamentParticipantScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VenueCreateWithoutOwnerInput, VenueUncheckedCreateWithoutOwnerInput> | VenueCreateWithoutOwnerInput[] | VenueUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutOwnerInput | VenueCreateOrConnectWithoutOwnerInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutOwnerInput | VenueUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VenueCreateManyOwnerInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutOwnerInput | VenueUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutOwnerInput | VenueUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<FriendshipCreateWithoutRequesterInput, FriendshipUncheckedCreateWithoutRequesterInput> | FriendshipCreateWithoutRequesterInput[] | FriendshipUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutRequesterInput | FriendshipCreateOrConnectWithoutRequesterInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutRequesterInput | FriendshipUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: FriendshipCreateManyRequesterInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutRequesterInput | FriendshipUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutRequesterInput | FriendshipUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput = {
    create?: XOR<FriendshipCreateWithoutAddresseeInput, FriendshipUncheckedCreateWithoutAddresseeInput> | FriendshipCreateWithoutAddresseeInput[] | FriendshipUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutAddresseeInput | FriendshipCreateOrConnectWithoutAddresseeInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutAddresseeInput | FriendshipUpsertWithWhereUniqueWithoutAddresseeInput[]
    createMany?: FriendshipCreateManyAddresseeInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutAddresseeInput | FriendshipUpdateWithWhereUniqueWithoutAddresseeInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutAddresseeInput | FriendshipUpdateManyWithWhereWithoutAddresseeInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type DirectMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput> | DirectMessageCreateWithoutSenderInput[] | DirectMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutSenderInput | DirectMessageCreateOrConnectWithoutSenderInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutSenderInput | DirectMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DirectMessageCreateManySenderInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutSenderInput | DirectMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutSenderInput | DirectMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput> | DirectMessageCreateWithoutReceiverInput[] | DirectMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutReceiverInput | DirectMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutReceiverInput | DirectMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: DirectMessageCreateManyReceiverInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutReceiverInput | DirectMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutReceiverInput | DirectMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type ActivityEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityEventCreateWithoutUserInput, ActivityEventUncheckedCreateWithoutUserInput> | ActivityEventCreateWithoutUserInput[] | ActivityEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutUserInput | ActivityEventCreateOrConnectWithoutUserInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutUserInput | ActivityEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityEventCreateManyUserInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutUserInput | ActivityEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutUserInput | ActivityEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<GameSessionCreateWithoutPlayerInput, GameSessionUncheckedCreateWithoutPlayerInput> | GameSessionCreateWithoutPlayerInput[] | GameSessionUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutPlayerInput | GameSessionCreateOrConnectWithoutPlayerInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutPlayerInput | GameSessionUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: GameSessionCreateManyPlayerInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutPlayerInput | GameSessionUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutPlayerInput | GameSessionUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ShadowRunCreateWithoutPlayerInput, ShadowRunUncheckedCreateWithoutPlayerInput> | ShadowRunCreateWithoutPlayerInput[] | ShadowRunUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutPlayerInput | ShadowRunCreateOrConnectWithoutPlayerInput[]
    upsert?: ShadowRunUpsertWithWhereUniqueWithoutPlayerInput | ShadowRunUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ShadowRunCreateManyPlayerInputEnvelope
    set?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    disconnect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    delete?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    update?: ShadowRunUpdateWithWhereUniqueWithoutPlayerInput | ShadowRunUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ShadowRunUpdateManyWithWhereWithoutPlayerInput | ShadowRunUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
  }

  export type DojoCheckInUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DojoCheckInCreateWithoutUserInput, DojoCheckInUncheckedCreateWithoutUserInput> | DojoCheckInCreateWithoutUserInput[] | DojoCheckInUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutUserInput | DojoCheckInCreateOrConnectWithoutUserInput[]
    upsert?: DojoCheckInUpsertWithWhereUniqueWithoutUserInput | DojoCheckInUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DojoCheckInCreateManyUserInputEnvelope
    set?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    disconnect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    delete?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    update?: DojoCheckInUpdateWithWhereUniqueWithoutUserInput | DojoCheckInUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DojoCheckInUpdateManyWithWhereWithoutUserInput | DojoCheckInUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DojoCheckInScalarWhereInput | DojoCheckInScalarWhereInput[]
  }

  export type UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput> | UserInventoryItemCreateWithoutUserInput[] | UserInventoryItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutUserInput | UserInventoryItemCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryItemUpsertWithWhereUniqueWithoutUserInput | UserInventoryItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryItemCreateManyUserInputEnvelope
    set?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    disconnect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    delete?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    update?: UserInventoryItemUpdateWithWhereUniqueWithoutUserInput | UserInventoryItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryItemUpdateManyWithWhereWithoutUserInput | UserInventoryItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutResolverNestedInput = {
    create?: XOR<FeedbackCreateWithoutResolverInput, FeedbackUncheckedCreateWithoutResolverInput> | FeedbackCreateWithoutResolverInput[] | FeedbackUncheckedCreateWithoutResolverInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutResolverInput | FeedbackCreateOrConnectWithoutResolverInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutResolverInput | FeedbackUpsertWithWhereUniqueWithoutResolverInput[]
    createMany?: FeedbackCreateManyResolverInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutResolverInput | FeedbackUpdateWithWhereUniqueWithoutResolverInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutResolverInput | FeedbackUpdateManyWithWhereWithoutResolverInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentCreateWithoutUserInput, ContentUncheckedCreateWithoutUserInput> | ContentCreateWithoutUserInput[] | ContentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutUserInput | ContentCreateOrConnectWithoutUserInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutUserInput | ContentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentCreateManyUserInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutUserInput | ContentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutUserInput | ContentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ContentUncheckedUpdateManyWithoutModeratorNestedInput = {
    create?: XOR<ContentCreateWithoutModeratorInput, ContentUncheckedCreateWithoutModeratorInput> | ContentCreateWithoutModeratorInput[] | ContentUncheckedCreateWithoutModeratorInput[]
    connectOrCreate?: ContentCreateOrConnectWithoutModeratorInput | ContentCreateOrConnectWithoutModeratorInput[]
    upsert?: ContentUpsertWithWhereUniqueWithoutModeratorInput | ContentUpsertWithWhereUniqueWithoutModeratorInput[]
    createMany?: ContentCreateManyModeratorInputEnvelope
    set?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    disconnect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    delete?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    connect?: ContentWhereUniqueInput | ContentWhereUniqueInput[]
    update?: ContentUpdateWithWhereUniqueWithoutModeratorInput | ContentUpdateWithWhereUniqueWithoutModeratorInput[]
    updateMany?: ContentUpdateManyWithWhereWithoutModeratorInput | ContentUpdateManyWithWhereWithoutModeratorInput[]
    deleteMany?: ContentScalarWhereInput | ContentScalarWhereInput[]
  }

  export type ContentLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentLikeCreateWithoutUserInput, ContentLikeUncheckedCreateWithoutUserInput> | ContentLikeCreateWithoutUserInput[] | ContentLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutUserInput | ContentLikeCreateOrConnectWithoutUserInput[]
    upsert?: ContentLikeUpsertWithWhereUniqueWithoutUserInput | ContentLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentLikeCreateManyUserInputEnvelope
    set?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    disconnect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    delete?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    update?: ContentLikeUpdateWithWhereUniqueWithoutUserInput | ContentLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentLikeUpdateManyWithWhereWithoutUserInput | ContentLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentLikeScalarWhereInput | ContentLikeScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type ContentShareUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContentShareCreateWithoutUserInput, ContentShareUncheckedCreateWithoutUserInput> | ContentShareCreateWithoutUserInput[] | ContentShareUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutUserInput | ContentShareCreateOrConnectWithoutUserInput[]
    upsert?: ContentShareUpsertWithWhereUniqueWithoutUserInput | ContentShareUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContentShareCreateManyUserInputEnvelope
    set?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    disconnect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    delete?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    update?: ContentShareUpdateWithWhereUniqueWithoutUserInput | ContentShareUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContentShareUpdateManyWithWhereWithoutUserInput | ContentShareUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
  }

  export type ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput = {
    create?: XOR<ContentShareCreateWithoutSharedWithInput, ContentShareUncheckedCreateWithoutSharedWithInput> | ContentShareCreateWithoutSharedWithInput[] | ContentShareUncheckedCreateWithoutSharedWithInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutSharedWithInput | ContentShareCreateOrConnectWithoutSharedWithInput[]
    upsert?: ContentShareUpsertWithWhereUniqueWithoutSharedWithInput | ContentShareUpsertWithWhereUniqueWithoutSharedWithInput[]
    createMany?: ContentShareCreateManySharedWithInputEnvelope
    set?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    disconnect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    delete?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    update?: ContentShareUpdateWithWhereUniqueWithoutSharedWithInput | ContentShareUpdateWithWhereUniqueWithoutSharedWithInput[]
    updateMany?: ContentShareUpdateManyWithWhereWithoutSharedWithInput | ContentShareUpdateManyWithWhereWithoutSharedWithInput[]
    deleteMany?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
  }

  export type CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutCreatorInput, CommunityCosmeticItemUncheckedCreateWithoutCreatorInput> | CommunityCosmeticItemCreateWithoutCreatorInput[] | CommunityCosmeticItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutCreatorInput | CommunityCosmeticItemCreateOrConnectWithoutCreatorInput[]
    upsert?: CommunityCosmeticItemUpsertWithWhereUniqueWithoutCreatorInput | CommunityCosmeticItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CommunityCosmeticItemCreateManyCreatorInputEnvelope
    set?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    disconnect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    delete?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    update?: CommunityCosmeticItemUpdateWithWhereUniqueWithoutCreatorInput | CommunityCosmeticItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CommunityCosmeticItemUpdateManyWithWhereWithoutCreatorInput | CommunityCosmeticItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CommunityCosmeticItemScalarWhereInput | CommunityCosmeticItemScalarWhereInput[]
  }

  export type CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutReviewerInput, CommunityCosmeticItemUncheckedCreateWithoutReviewerInput> | CommunityCosmeticItemCreateWithoutReviewerInput[] | CommunityCosmeticItemUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutReviewerInput | CommunityCosmeticItemCreateOrConnectWithoutReviewerInput[]
    upsert?: CommunityCosmeticItemUpsertWithWhereUniqueWithoutReviewerInput | CommunityCosmeticItemUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: CommunityCosmeticItemCreateManyReviewerInputEnvelope
    set?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    disconnect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    delete?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    connect?: CommunityCosmeticItemWhereUniqueInput | CommunityCosmeticItemWhereUniqueInput[]
    update?: CommunityCosmeticItemUpdateWithWhereUniqueWithoutReviewerInput | CommunityCosmeticItemUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: CommunityCosmeticItemUpdateManyWithWhereWithoutReviewerInput | CommunityCosmeticItemUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: CommunityCosmeticItemScalarWhereInput | CommunityCosmeticItemScalarWhereInput[]
  }

  export type CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutUserInput, CosmeticItemLikeUncheckedCreateWithoutUserInput> | CosmeticItemLikeCreateWithoutUserInput[] | CosmeticItemLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutUserInput | CosmeticItemLikeCreateOrConnectWithoutUserInput[]
    upsert?: CosmeticItemLikeUpsertWithWhereUniqueWithoutUserInput | CosmeticItemLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CosmeticItemLikeCreateManyUserInputEnvelope
    set?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    disconnect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    delete?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    update?: CosmeticItemLikeUpdateWithWhereUniqueWithoutUserInput | CosmeticItemLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CosmeticItemLikeUpdateManyWithWhereWithoutUserInput | CosmeticItemLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CosmeticItemLikeScalarWhereInput | CosmeticItemLikeScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutVenuesInput = {
    create?: XOR<UserCreateWithoutVenuesInput, UserUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVenuesInput
    connect?: UserWhereUniqueInput
  }

  export type ClanCreateNestedOneWithoutControlledVenuesInput = {
    create?: XOR<ClanCreateWithoutControlledVenuesInput, ClanUncheckedCreateWithoutControlledVenuesInput>
    connectOrCreate?: ClanCreateOrConnectWithoutControlledVenuesInput
    connect?: ClanWhereUniqueInput
  }

  export type TableCreateNestedManyWithoutVenueInput = {
    create?: XOR<TableCreateWithoutVenueInput, TableUncheckedCreateWithoutVenueInput> | TableCreateWithoutVenueInput[] | TableUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TableCreateOrConnectWithoutVenueInput | TableCreateOrConnectWithoutVenueInput[]
    createMany?: TableCreateManyVenueInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TournamentCreateNestedManyWithoutVenueInput = {
    create?: XOR<TournamentCreateWithoutVenueInput, TournamentUncheckedCreateWithoutVenueInput> | TournamentCreateWithoutVenueInput[] | TournamentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutVenueInput | TournamentCreateOrConnectWithoutVenueInput[]
    createMany?: TournamentCreateManyVenueInputEnvelope
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type TerritoryCreateNestedManyWithoutVenueInput = {
    create?: XOR<TerritoryCreateWithoutVenueInput, TerritoryUncheckedCreateWithoutVenueInput> | TerritoryCreateWithoutVenueInput[] | TerritoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutVenueInput | TerritoryCreateOrConnectWithoutVenueInput[]
    createMany?: TerritoryCreateManyVenueInputEnvelope
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
  }

  export type CheckInCreateNestedManyWithoutVenueInput = {
    create?: XOR<CheckInCreateWithoutVenueInput, CheckInUncheckedCreateWithoutVenueInput> | CheckInCreateWithoutVenueInput[] | CheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutVenueInput | CheckInCreateOrConnectWithoutVenueInput[]
    createMany?: CheckInCreateManyVenueInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type ChallengeCreateNestedManyWithoutVenueInput = {
    create?: XOR<ChallengeCreateWithoutVenueInput, ChallengeUncheckedCreateWithoutVenueInput> | ChallengeCreateWithoutVenueInput[] | ChallengeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutVenueInput | ChallengeCreateOrConnectWithoutVenueInput[]
    createMany?: ChallengeCreateManyVenueInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutVenueInput = {
    create?: XOR<MatchCreateWithoutVenueInput, MatchUncheckedCreateWithoutVenueInput> | MatchCreateWithoutVenueInput[] | MatchUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutVenueInput | MatchCreateOrConnectWithoutVenueInput[]
    createMany?: MatchCreateManyVenueInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type ActivityEventCreateNestedManyWithoutVenueInput = {
    create?: XOR<ActivityEventCreateWithoutVenueInput, ActivityEventUncheckedCreateWithoutVenueInput> | ActivityEventCreateWithoutVenueInput[] | ActivityEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutVenueInput | ActivityEventCreateOrConnectWithoutVenueInput[]
    createMany?: ActivityEventCreateManyVenueInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type VenueQuestCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueQuestCreateWithoutVenueInput, VenueQuestUncheckedCreateWithoutVenueInput> | VenueQuestCreateWithoutVenueInput[] | VenueQuestUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueQuestCreateOrConnectWithoutVenueInput | VenueQuestCreateOrConnectWithoutVenueInput[]
    createMany?: VenueQuestCreateManyVenueInputEnvelope
    connect?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
  }

  export type VenueSpecialCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueSpecialCreateWithoutVenueInput, VenueSpecialUncheckedCreateWithoutVenueInput> | VenueSpecialCreateWithoutVenueInput[] | VenueSpecialUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueSpecialCreateOrConnectWithoutVenueInput | VenueSpecialCreateOrConnectWithoutVenueInput[]
    createMany?: VenueSpecialCreateManyVenueInputEnvelope
    connect?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
  }

  export type DojoCheckInCreateNestedManyWithoutVenueInput = {
    create?: XOR<DojoCheckInCreateWithoutVenueInput, DojoCheckInUncheckedCreateWithoutVenueInput> | DojoCheckInCreateWithoutVenueInput[] | DojoCheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutVenueInput | DojoCheckInCreateOrConnectWithoutVenueInput[]
    createMany?: DojoCheckInCreateManyVenueInputEnvelope
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
  }

  export type ShadowRunCreateNestedManyWithoutTargetVenueInput = {
    create?: XOR<ShadowRunCreateWithoutTargetVenueInput, ShadowRunUncheckedCreateWithoutTargetVenueInput> | ShadowRunCreateWithoutTargetVenueInput[] | ShadowRunUncheckedCreateWithoutTargetVenueInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutTargetVenueInput | ShadowRunCreateOrConnectWithoutTargetVenueInput[]
    createMany?: ShadowRunCreateManyTargetVenueInputEnvelope
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
  }

  export type GameSessionCreateNestedManyWithoutVenueInput = {
    create?: XOR<GameSessionCreateWithoutVenueInput, GameSessionUncheckedCreateWithoutVenueInput> | GameSessionCreateWithoutVenueInput[] | GameSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutVenueInput | GameSessionCreateOrConnectWithoutVenueInput[]
    createMany?: GameSessionCreateManyVenueInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<TableCreateWithoutVenueInput, TableUncheckedCreateWithoutVenueInput> | TableCreateWithoutVenueInput[] | TableUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TableCreateOrConnectWithoutVenueInput | TableCreateOrConnectWithoutVenueInput[]
    createMany?: TableCreateManyVenueInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TournamentUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<TournamentCreateWithoutVenueInput, TournamentUncheckedCreateWithoutVenueInput> | TournamentCreateWithoutVenueInput[] | TournamentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutVenueInput | TournamentCreateOrConnectWithoutVenueInput[]
    createMany?: TournamentCreateManyVenueInputEnvelope
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type TerritoryUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<TerritoryCreateWithoutVenueInput, TerritoryUncheckedCreateWithoutVenueInput> | TerritoryCreateWithoutVenueInput[] | TerritoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutVenueInput | TerritoryCreateOrConnectWithoutVenueInput[]
    createMany?: TerritoryCreateManyVenueInputEnvelope
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
  }

  export type CheckInUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<CheckInCreateWithoutVenueInput, CheckInUncheckedCreateWithoutVenueInput> | CheckInCreateWithoutVenueInput[] | CheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutVenueInput | CheckInCreateOrConnectWithoutVenueInput[]
    createMany?: CheckInCreateManyVenueInputEnvelope
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ChallengeCreateWithoutVenueInput, ChallengeUncheckedCreateWithoutVenueInput> | ChallengeCreateWithoutVenueInput[] | ChallengeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutVenueInput | ChallengeCreateOrConnectWithoutVenueInput[]
    createMany?: ChallengeCreateManyVenueInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<MatchCreateWithoutVenueInput, MatchUncheckedCreateWithoutVenueInput> | MatchCreateWithoutVenueInput[] | MatchUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutVenueInput | MatchCreateOrConnectWithoutVenueInput[]
    createMany?: MatchCreateManyVenueInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type ActivityEventUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ActivityEventCreateWithoutVenueInput, ActivityEventUncheckedCreateWithoutVenueInput> | ActivityEventCreateWithoutVenueInput[] | ActivityEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutVenueInput | ActivityEventCreateOrConnectWithoutVenueInput[]
    createMany?: ActivityEventCreateManyVenueInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type VenueQuestUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueQuestCreateWithoutVenueInput, VenueQuestUncheckedCreateWithoutVenueInput> | VenueQuestCreateWithoutVenueInput[] | VenueQuestUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueQuestCreateOrConnectWithoutVenueInput | VenueQuestCreateOrConnectWithoutVenueInput[]
    createMany?: VenueQuestCreateManyVenueInputEnvelope
    connect?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
  }

  export type VenueSpecialUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueSpecialCreateWithoutVenueInput, VenueSpecialUncheckedCreateWithoutVenueInput> | VenueSpecialCreateWithoutVenueInput[] | VenueSpecialUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueSpecialCreateOrConnectWithoutVenueInput | VenueSpecialCreateOrConnectWithoutVenueInput[]
    createMany?: VenueSpecialCreateManyVenueInputEnvelope
    connect?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
  }

  export type DojoCheckInUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<DojoCheckInCreateWithoutVenueInput, DojoCheckInUncheckedCreateWithoutVenueInput> | DojoCheckInCreateWithoutVenueInput[] | DojoCheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutVenueInput | DojoCheckInCreateOrConnectWithoutVenueInput[]
    createMany?: DojoCheckInCreateManyVenueInputEnvelope
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
  }

  export type ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput = {
    create?: XOR<ShadowRunCreateWithoutTargetVenueInput, ShadowRunUncheckedCreateWithoutTargetVenueInput> | ShadowRunCreateWithoutTargetVenueInput[] | ShadowRunUncheckedCreateWithoutTargetVenueInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutTargetVenueInput | ShadowRunCreateOrConnectWithoutTargetVenueInput[]
    createMany?: ShadowRunCreateManyTargetVenueInputEnvelope
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<GameSessionCreateWithoutVenueInput, GameSessionUncheckedCreateWithoutVenueInput> | GameSessionCreateWithoutVenueInput[] | GameSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutVenueInput | GameSessionCreateOrConnectWithoutVenueInput[]
    createMany?: GameSessionCreateManyVenueInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutVenuesNestedInput = {
    create?: XOR<UserCreateWithoutVenuesInput, UserUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVenuesInput
    upsert?: UserUpsertWithoutVenuesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVenuesInput, UserUpdateWithoutVenuesInput>, UserUncheckedUpdateWithoutVenuesInput>
  }

  export type ClanUpdateOneWithoutControlledVenuesNestedInput = {
    create?: XOR<ClanCreateWithoutControlledVenuesInput, ClanUncheckedCreateWithoutControlledVenuesInput>
    connectOrCreate?: ClanCreateOrConnectWithoutControlledVenuesInput
    upsert?: ClanUpsertWithoutControlledVenuesInput
    disconnect?: ClanWhereInput | boolean
    delete?: ClanWhereInput | boolean
    connect?: ClanWhereUniqueInput
    update?: XOR<XOR<ClanUpdateToOneWithWhereWithoutControlledVenuesInput, ClanUpdateWithoutControlledVenuesInput>, ClanUncheckedUpdateWithoutControlledVenuesInput>
  }

  export type TableUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TableCreateWithoutVenueInput, TableUncheckedCreateWithoutVenueInput> | TableCreateWithoutVenueInput[] | TableUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TableCreateOrConnectWithoutVenueInput | TableCreateOrConnectWithoutVenueInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutVenueInput | TableUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TableCreateManyVenueInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutVenueInput | TableUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TableUpdateManyWithWhereWithoutVenueInput | TableUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TournamentUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TournamentCreateWithoutVenueInput, TournamentUncheckedCreateWithoutVenueInput> | TournamentCreateWithoutVenueInput[] | TournamentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutVenueInput | TournamentCreateOrConnectWithoutVenueInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutVenueInput | TournamentUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TournamentCreateManyVenueInputEnvelope
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutVenueInput | TournamentUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutVenueInput | TournamentUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type TerritoryUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TerritoryCreateWithoutVenueInput, TerritoryUncheckedCreateWithoutVenueInput> | TerritoryCreateWithoutVenueInput[] | TerritoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutVenueInput | TerritoryCreateOrConnectWithoutVenueInput[]
    upsert?: TerritoryUpsertWithWhereUniqueWithoutVenueInput | TerritoryUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TerritoryCreateManyVenueInputEnvelope
    set?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    disconnect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    delete?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    update?: TerritoryUpdateWithWhereUniqueWithoutVenueInput | TerritoryUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TerritoryUpdateManyWithWhereWithoutVenueInput | TerritoryUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
  }

  export type CheckInUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CheckInCreateWithoutVenueInput, CheckInUncheckedCreateWithoutVenueInput> | CheckInCreateWithoutVenueInput[] | CheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutVenueInput | CheckInCreateOrConnectWithoutVenueInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutVenueInput | CheckInUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CheckInCreateManyVenueInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutVenueInput | CheckInUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutVenueInput | CheckInUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type ChallengeUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ChallengeCreateWithoutVenueInput, ChallengeUncheckedCreateWithoutVenueInput> | ChallengeCreateWithoutVenueInput[] | ChallengeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutVenueInput | ChallengeCreateOrConnectWithoutVenueInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutVenueInput | ChallengeUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ChallengeCreateManyVenueInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutVenueInput | ChallengeUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutVenueInput | ChallengeUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutVenueNestedInput = {
    create?: XOR<MatchCreateWithoutVenueInput, MatchUncheckedCreateWithoutVenueInput> | MatchCreateWithoutVenueInput[] | MatchUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutVenueInput | MatchCreateOrConnectWithoutVenueInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutVenueInput | MatchUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: MatchCreateManyVenueInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutVenueInput | MatchUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutVenueInput | MatchUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type ActivityEventUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ActivityEventCreateWithoutVenueInput, ActivityEventUncheckedCreateWithoutVenueInput> | ActivityEventCreateWithoutVenueInput[] | ActivityEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutVenueInput | ActivityEventCreateOrConnectWithoutVenueInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutVenueInput | ActivityEventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ActivityEventCreateManyVenueInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutVenueInput | ActivityEventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutVenueInput | ActivityEventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type VenueQuestUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueQuestCreateWithoutVenueInput, VenueQuestUncheckedCreateWithoutVenueInput> | VenueQuestCreateWithoutVenueInput[] | VenueQuestUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueQuestCreateOrConnectWithoutVenueInput | VenueQuestCreateOrConnectWithoutVenueInput[]
    upsert?: VenueQuestUpsertWithWhereUniqueWithoutVenueInput | VenueQuestUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueQuestCreateManyVenueInputEnvelope
    set?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    disconnect?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    delete?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    connect?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    update?: VenueQuestUpdateWithWhereUniqueWithoutVenueInput | VenueQuestUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueQuestUpdateManyWithWhereWithoutVenueInput | VenueQuestUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueQuestScalarWhereInput | VenueQuestScalarWhereInput[]
  }

  export type VenueSpecialUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueSpecialCreateWithoutVenueInput, VenueSpecialUncheckedCreateWithoutVenueInput> | VenueSpecialCreateWithoutVenueInput[] | VenueSpecialUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueSpecialCreateOrConnectWithoutVenueInput | VenueSpecialCreateOrConnectWithoutVenueInput[]
    upsert?: VenueSpecialUpsertWithWhereUniqueWithoutVenueInput | VenueSpecialUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueSpecialCreateManyVenueInputEnvelope
    set?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    disconnect?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    delete?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    connect?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    update?: VenueSpecialUpdateWithWhereUniqueWithoutVenueInput | VenueSpecialUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueSpecialUpdateManyWithWhereWithoutVenueInput | VenueSpecialUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueSpecialScalarWhereInput | VenueSpecialScalarWhereInput[]
  }

  export type DojoCheckInUpdateManyWithoutVenueNestedInput = {
    create?: XOR<DojoCheckInCreateWithoutVenueInput, DojoCheckInUncheckedCreateWithoutVenueInput> | DojoCheckInCreateWithoutVenueInput[] | DojoCheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutVenueInput | DojoCheckInCreateOrConnectWithoutVenueInput[]
    upsert?: DojoCheckInUpsertWithWhereUniqueWithoutVenueInput | DojoCheckInUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: DojoCheckInCreateManyVenueInputEnvelope
    set?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    disconnect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    delete?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    update?: DojoCheckInUpdateWithWhereUniqueWithoutVenueInput | DojoCheckInUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: DojoCheckInUpdateManyWithWhereWithoutVenueInput | DojoCheckInUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: DojoCheckInScalarWhereInput | DojoCheckInScalarWhereInput[]
  }

  export type ShadowRunUpdateManyWithoutTargetVenueNestedInput = {
    create?: XOR<ShadowRunCreateWithoutTargetVenueInput, ShadowRunUncheckedCreateWithoutTargetVenueInput> | ShadowRunCreateWithoutTargetVenueInput[] | ShadowRunUncheckedCreateWithoutTargetVenueInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutTargetVenueInput | ShadowRunCreateOrConnectWithoutTargetVenueInput[]
    upsert?: ShadowRunUpsertWithWhereUniqueWithoutTargetVenueInput | ShadowRunUpsertWithWhereUniqueWithoutTargetVenueInput[]
    createMany?: ShadowRunCreateManyTargetVenueInputEnvelope
    set?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    disconnect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    delete?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    update?: ShadowRunUpdateWithWhereUniqueWithoutTargetVenueInput | ShadowRunUpdateWithWhereUniqueWithoutTargetVenueInput[]
    updateMany?: ShadowRunUpdateManyWithWhereWithoutTargetVenueInput | ShadowRunUpdateManyWithWhereWithoutTargetVenueInput[]
    deleteMany?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
  }

  export type GameSessionUpdateManyWithoutVenueNestedInput = {
    create?: XOR<GameSessionCreateWithoutVenueInput, GameSessionUncheckedCreateWithoutVenueInput> | GameSessionCreateWithoutVenueInput[] | GameSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutVenueInput | GameSessionCreateOrConnectWithoutVenueInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutVenueInput | GameSessionUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: GameSessionCreateManyVenueInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutVenueInput | GameSessionUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutVenueInput | GameSessionUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TableCreateWithoutVenueInput, TableUncheckedCreateWithoutVenueInput> | TableCreateWithoutVenueInput[] | TableUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TableCreateOrConnectWithoutVenueInput | TableCreateOrConnectWithoutVenueInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutVenueInput | TableUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TableCreateManyVenueInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutVenueInput | TableUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TableUpdateManyWithWhereWithoutVenueInput | TableUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TournamentUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TournamentCreateWithoutVenueInput, TournamentUncheckedCreateWithoutVenueInput> | TournamentCreateWithoutVenueInput[] | TournamentUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutVenueInput | TournamentCreateOrConnectWithoutVenueInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutVenueInput | TournamentUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TournamentCreateManyVenueInputEnvelope
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutVenueInput | TournamentUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutVenueInput | TournamentUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type TerritoryUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<TerritoryCreateWithoutVenueInput, TerritoryUncheckedCreateWithoutVenueInput> | TerritoryCreateWithoutVenueInput[] | TerritoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutVenueInput | TerritoryCreateOrConnectWithoutVenueInput[]
    upsert?: TerritoryUpsertWithWhereUniqueWithoutVenueInput | TerritoryUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: TerritoryCreateManyVenueInputEnvelope
    set?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    disconnect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    delete?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    update?: TerritoryUpdateWithWhereUniqueWithoutVenueInput | TerritoryUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: TerritoryUpdateManyWithWhereWithoutVenueInput | TerritoryUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
  }

  export type CheckInUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CheckInCreateWithoutVenueInput, CheckInUncheckedCreateWithoutVenueInput> | CheckInCreateWithoutVenueInput[] | CheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInCreateOrConnectWithoutVenueInput | CheckInCreateOrConnectWithoutVenueInput[]
    upsert?: CheckInUpsertWithWhereUniqueWithoutVenueInput | CheckInUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CheckInCreateManyVenueInputEnvelope
    set?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    disconnect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    delete?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    connect?: CheckInWhereUniqueInput | CheckInWhereUniqueInput[]
    update?: CheckInUpdateWithWhereUniqueWithoutVenueInput | CheckInUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CheckInUpdateManyWithWhereWithoutVenueInput | CheckInUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ChallengeCreateWithoutVenueInput, ChallengeUncheckedCreateWithoutVenueInput> | ChallengeCreateWithoutVenueInput[] | ChallengeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutVenueInput | ChallengeCreateOrConnectWithoutVenueInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutVenueInput | ChallengeUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ChallengeCreateManyVenueInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutVenueInput | ChallengeUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutVenueInput | ChallengeUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<MatchCreateWithoutVenueInput, MatchUncheckedCreateWithoutVenueInput> | MatchCreateWithoutVenueInput[] | MatchUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutVenueInput | MatchCreateOrConnectWithoutVenueInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutVenueInput | MatchUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: MatchCreateManyVenueInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutVenueInput | MatchUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutVenueInput | MatchUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type ActivityEventUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ActivityEventCreateWithoutVenueInput, ActivityEventUncheckedCreateWithoutVenueInput> | ActivityEventCreateWithoutVenueInput[] | ActivityEventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutVenueInput | ActivityEventCreateOrConnectWithoutVenueInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutVenueInput | ActivityEventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ActivityEventCreateManyVenueInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutVenueInput | ActivityEventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutVenueInput | ActivityEventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type VenueQuestUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueQuestCreateWithoutVenueInput, VenueQuestUncheckedCreateWithoutVenueInput> | VenueQuestCreateWithoutVenueInput[] | VenueQuestUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueQuestCreateOrConnectWithoutVenueInput | VenueQuestCreateOrConnectWithoutVenueInput[]
    upsert?: VenueQuestUpsertWithWhereUniqueWithoutVenueInput | VenueQuestUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueQuestCreateManyVenueInputEnvelope
    set?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    disconnect?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    delete?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    connect?: VenueQuestWhereUniqueInput | VenueQuestWhereUniqueInput[]
    update?: VenueQuestUpdateWithWhereUniqueWithoutVenueInput | VenueQuestUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueQuestUpdateManyWithWhereWithoutVenueInput | VenueQuestUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueQuestScalarWhereInput | VenueQuestScalarWhereInput[]
  }

  export type VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueSpecialCreateWithoutVenueInput, VenueSpecialUncheckedCreateWithoutVenueInput> | VenueSpecialCreateWithoutVenueInput[] | VenueSpecialUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueSpecialCreateOrConnectWithoutVenueInput | VenueSpecialCreateOrConnectWithoutVenueInput[]
    upsert?: VenueSpecialUpsertWithWhereUniqueWithoutVenueInput | VenueSpecialUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueSpecialCreateManyVenueInputEnvelope
    set?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    disconnect?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    delete?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    connect?: VenueSpecialWhereUniqueInput | VenueSpecialWhereUniqueInput[]
    update?: VenueSpecialUpdateWithWhereUniqueWithoutVenueInput | VenueSpecialUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueSpecialUpdateManyWithWhereWithoutVenueInput | VenueSpecialUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueSpecialScalarWhereInput | VenueSpecialScalarWhereInput[]
  }

  export type DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<DojoCheckInCreateWithoutVenueInput, DojoCheckInUncheckedCreateWithoutVenueInput> | DojoCheckInCreateWithoutVenueInput[] | DojoCheckInUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: DojoCheckInCreateOrConnectWithoutVenueInput | DojoCheckInCreateOrConnectWithoutVenueInput[]
    upsert?: DojoCheckInUpsertWithWhereUniqueWithoutVenueInput | DojoCheckInUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: DojoCheckInCreateManyVenueInputEnvelope
    set?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    disconnect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    delete?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    connect?: DojoCheckInWhereUniqueInput | DojoCheckInWhereUniqueInput[]
    update?: DojoCheckInUpdateWithWhereUniqueWithoutVenueInput | DojoCheckInUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: DojoCheckInUpdateManyWithWhereWithoutVenueInput | DojoCheckInUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: DojoCheckInScalarWhereInput | DojoCheckInScalarWhereInput[]
  }

  export type ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput = {
    create?: XOR<ShadowRunCreateWithoutTargetVenueInput, ShadowRunUncheckedCreateWithoutTargetVenueInput> | ShadowRunCreateWithoutTargetVenueInput[] | ShadowRunUncheckedCreateWithoutTargetVenueInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutTargetVenueInput | ShadowRunCreateOrConnectWithoutTargetVenueInput[]
    upsert?: ShadowRunUpsertWithWhereUniqueWithoutTargetVenueInput | ShadowRunUpsertWithWhereUniqueWithoutTargetVenueInput[]
    createMany?: ShadowRunCreateManyTargetVenueInputEnvelope
    set?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    disconnect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    delete?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    update?: ShadowRunUpdateWithWhereUniqueWithoutTargetVenueInput | ShadowRunUpdateWithWhereUniqueWithoutTargetVenueInput[]
    updateMany?: ShadowRunUpdateManyWithWhereWithoutTargetVenueInput | ShadowRunUpdateManyWithWhereWithoutTargetVenueInput[]
    deleteMany?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<GameSessionCreateWithoutVenueInput, GameSessionUncheckedCreateWithoutVenueInput> | GameSessionCreateWithoutVenueInput[] | GameSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutVenueInput | GameSessionCreateOrConnectWithoutVenueInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutVenueInput | GameSessionUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: GameSessionCreateManyVenueInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutVenueInput | GameSessionUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutVenueInput | GameSessionUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type VenueCreateNestedOneWithoutTablesListInput = {
    create?: XOR<VenueCreateWithoutTablesListInput, VenueUncheckedCreateWithoutTablesListInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTablesListInput
    connect?: VenueWhereUniqueInput
  }

  export type MatchCreateNestedManyWithoutTableInput = {
    create?: XOR<MatchCreateWithoutTableInput, MatchUncheckedCreateWithoutTableInput> | MatchCreateWithoutTableInput[] | MatchUncheckedCreateWithoutTableInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTableInput | MatchCreateOrConnectWithoutTableInput[]
    createMany?: MatchCreateManyTableInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<MatchCreateWithoutTableInput, MatchUncheckedCreateWithoutTableInput> | MatchCreateWithoutTableInput[] | MatchUncheckedCreateWithoutTableInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTableInput | MatchCreateOrConnectWithoutTableInput[]
    createMany?: MatchCreateManyTableInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type EnumTableStatusFieldUpdateOperationsInput = {
    set?: $Enums.TableStatus
  }

  export type VenueUpdateOneRequiredWithoutTablesListNestedInput = {
    create?: XOR<VenueCreateWithoutTablesListInput, VenueUncheckedCreateWithoutTablesListInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTablesListInput
    upsert?: VenueUpsertWithoutTablesListInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutTablesListInput, VenueUpdateWithoutTablesListInput>, VenueUncheckedUpdateWithoutTablesListInput>
  }

  export type MatchUpdateManyWithoutTableNestedInput = {
    create?: XOR<MatchCreateWithoutTableInput, MatchUncheckedCreateWithoutTableInput> | MatchCreateWithoutTableInput[] | MatchUncheckedCreateWithoutTableInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTableInput | MatchCreateOrConnectWithoutTableInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTableInput | MatchUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: MatchCreateManyTableInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTableInput | MatchUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTableInput | MatchUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<MatchCreateWithoutTableInput, MatchUncheckedCreateWithoutTableInput> | MatchCreateWithoutTableInput[] | MatchUncheckedCreateWithoutTableInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTableInput | MatchCreateOrConnectWithoutTableInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTableInput | MatchUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: MatchCreateManyTableInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTableInput | MatchUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTableInput | MatchUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckInsInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<VenueCreateWithoutCheckInsInput, VenueUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutCheckInsInput
    connect?: VenueWhereUniqueInput
  }

  export type EnumCheckInMethodFieldUpdateOperationsInput = {
    set?: $Enums.CheckInMethod
  }

  export type UserUpdateOneRequiredWithoutCheckInsNestedInput = {
    create?: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckInsInput
    upsert?: UserUpsertWithoutCheckInsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCheckInsInput, UserUpdateWithoutCheckInsInput>, UserUncheckedUpdateWithoutCheckInsInput>
  }

  export type VenueUpdateOneRequiredWithoutCheckInsNestedInput = {
    create?: XOR<VenueCreateWithoutCheckInsInput, VenueUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutCheckInsInput
    upsert?: VenueUpsertWithoutCheckInsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutCheckInsInput, VenueUpdateWithoutCheckInsInput>, VenueUncheckedUpdateWithoutCheckInsInput>
  }

  export type UserCreateNestedOneWithoutLedClansInput = {
    create?: XOR<UserCreateWithoutLedClansInput, UserUncheckedCreateWithoutLedClansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLedClansInput
    connect?: UserWhereUniqueInput
  }

  export type ClanMemberCreateNestedManyWithoutClanInput = {
    create?: XOR<ClanMemberCreateWithoutClanInput, ClanMemberUncheckedCreateWithoutClanInput> | ClanMemberCreateWithoutClanInput[] | ClanMemberUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutClanInput | ClanMemberCreateOrConnectWithoutClanInput[]
    createMany?: ClanMemberCreateManyClanInputEnvelope
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
  }

  export type TerritoryCreateNestedManyWithoutClanInput = {
    create?: XOR<TerritoryCreateWithoutClanInput, TerritoryUncheckedCreateWithoutClanInput> | TerritoryCreateWithoutClanInput[] | TerritoryUncheckedCreateWithoutClanInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutClanInput | TerritoryCreateOrConnectWithoutClanInput[]
    createMany?: TerritoryCreateManyClanInputEnvelope
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
  }

  export type VenueCreateNestedManyWithoutControllingClanInput = {
    create?: XOR<VenueCreateWithoutControllingClanInput, VenueUncheckedCreateWithoutControllingClanInput> | VenueCreateWithoutControllingClanInput[] | VenueUncheckedCreateWithoutControllingClanInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutControllingClanInput | VenueCreateOrConnectWithoutControllingClanInput[]
    createMany?: VenueCreateManyControllingClanInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type ActivityEventCreateNestedManyWithoutClanInput = {
    create?: XOR<ActivityEventCreateWithoutClanInput, ActivityEventUncheckedCreateWithoutClanInput> | ActivityEventCreateWithoutClanInput[] | ActivityEventUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutClanInput | ActivityEventCreateOrConnectWithoutClanInput[]
    createMany?: ActivityEventCreateManyClanInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type ShadowRunCreateNestedManyWithoutInitiatingClanInput = {
    create?: XOR<ShadowRunCreateWithoutInitiatingClanInput, ShadowRunUncheckedCreateWithoutInitiatingClanInput> | ShadowRunCreateWithoutInitiatingClanInput[] | ShadowRunUncheckedCreateWithoutInitiatingClanInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutInitiatingClanInput | ShadowRunCreateOrConnectWithoutInitiatingClanInput[]
    createMany?: ShadowRunCreateManyInitiatingClanInputEnvelope
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
  }

  export type ClanMemberUncheckedCreateNestedManyWithoutClanInput = {
    create?: XOR<ClanMemberCreateWithoutClanInput, ClanMemberUncheckedCreateWithoutClanInput> | ClanMemberCreateWithoutClanInput[] | ClanMemberUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutClanInput | ClanMemberCreateOrConnectWithoutClanInput[]
    createMany?: ClanMemberCreateManyClanInputEnvelope
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
  }

  export type TerritoryUncheckedCreateNestedManyWithoutClanInput = {
    create?: XOR<TerritoryCreateWithoutClanInput, TerritoryUncheckedCreateWithoutClanInput> | TerritoryCreateWithoutClanInput[] | TerritoryUncheckedCreateWithoutClanInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutClanInput | TerritoryCreateOrConnectWithoutClanInput[]
    createMany?: TerritoryCreateManyClanInputEnvelope
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutControllingClanInput = {
    create?: XOR<VenueCreateWithoutControllingClanInput, VenueUncheckedCreateWithoutControllingClanInput> | VenueCreateWithoutControllingClanInput[] | VenueUncheckedCreateWithoutControllingClanInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutControllingClanInput | VenueCreateOrConnectWithoutControllingClanInput[]
    createMany?: VenueCreateManyControllingClanInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type ActivityEventUncheckedCreateNestedManyWithoutClanInput = {
    create?: XOR<ActivityEventCreateWithoutClanInput, ActivityEventUncheckedCreateWithoutClanInput> | ActivityEventCreateWithoutClanInput[] | ActivityEventUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutClanInput | ActivityEventCreateOrConnectWithoutClanInput[]
    createMany?: ActivityEventCreateManyClanInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type ShadowRunUncheckedCreateNestedManyWithoutInitiatingClanInput = {
    create?: XOR<ShadowRunCreateWithoutInitiatingClanInput, ShadowRunUncheckedCreateWithoutInitiatingClanInput> | ShadowRunCreateWithoutInitiatingClanInput[] | ShadowRunUncheckedCreateWithoutInitiatingClanInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutInitiatingClanInput | ShadowRunCreateOrConnectWithoutInitiatingClanInput[]
    createMany?: ShadowRunCreateManyInitiatingClanInputEnvelope
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLedClansNestedInput = {
    create?: XOR<UserCreateWithoutLedClansInput, UserUncheckedCreateWithoutLedClansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLedClansInput
    upsert?: UserUpsertWithoutLedClansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLedClansInput, UserUpdateWithoutLedClansInput>, UserUncheckedUpdateWithoutLedClansInput>
  }

  export type ClanMemberUpdateManyWithoutClanNestedInput = {
    create?: XOR<ClanMemberCreateWithoutClanInput, ClanMemberUncheckedCreateWithoutClanInput> | ClanMemberCreateWithoutClanInput[] | ClanMemberUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutClanInput | ClanMemberCreateOrConnectWithoutClanInput[]
    upsert?: ClanMemberUpsertWithWhereUniqueWithoutClanInput | ClanMemberUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: ClanMemberCreateManyClanInputEnvelope
    set?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    disconnect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    delete?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    update?: ClanMemberUpdateWithWhereUniqueWithoutClanInput | ClanMemberUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: ClanMemberUpdateManyWithWhereWithoutClanInput | ClanMemberUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: ClanMemberScalarWhereInput | ClanMemberScalarWhereInput[]
  }

  export type TerritoryUpdateManyWithoutClanNestedInput = {
    create?: XOR<TerritoryCreateWithoutClanInput, TerritoryUncheckedCreateWithoutClanInput> | TerritoryCreateWithoutClanInput[] | TerritoryUncheckedCreateWithoutClanInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutClanInput | TerritoryCreateOrConnectWithoutClanInput[]
    upsert?: TerritoryUpsertWithWhereUniqueWithoutClanInput | TerritoryUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: TerritoryCreateManyClanInputEnvelope
    set?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    disconnect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    delete?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    update?: TerritoryUpdateWithWhereUniqueWithoutClanInput | TerritoryUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: TerritoryUpdateManyWithWhereWithoutClanInput | TerritoryUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
  }

  export type VenueUpdateManyWithoutControllingClanNestedInput = {
    create?: XOR<VenueCreateWithoutControllingClanInput, VenueUncheckedCreateWithoutControllingClanInput> | VenueCreateWithoutControllingClanInput[] | VenueUncheckedCreateWithoutControllingClanInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutControllingClanInput | VenueCreateOrConnectWithoutControllingClanInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutControllingClanInput | VenueUpsertWithWhereUniqueWithoutControllingClanInput[]
    createMany?: VenueCreateManyControllingClanInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutControllingClanInput | VenueUpdateWithWhereUniqueWithoutControllingClanInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutControllingClanInput | VenueUpdateManyWithWhereWithoutControllingClanInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type ActivityEventUpdateManyWithoutClanNestedInput = {
    create?: XOR<ActivityEventCreateWithoutClanInput, ActivityEventUncheckedCreateWithoutClanInput> | ActivityEventCreateWithoutClanInput[] | ActivityEventUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutClanInput | ActivityEventCreateOrConnectWithoutClanInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutClanInput | ActivityEventUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: ActivityEventCreateManyClanInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutClanInput | ActivityEventUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutClanInput | ActivityEventUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type ShadowRunUpdateManyWithoutInitiatingClanNestedInput = {
    create?: XOR<ShadowRunCreateWithoutInitiatingClanInput, ShadowRunUncheckedCreateWithoutInitiatingClanInput> | ShadowRunCreateWithoutInitiatingClanInput[] | ShadowRunUncheckedCreateWithoutInitiatingClanInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutInitiatingClanInput | ShadowRunCreateOrConnectWithoutInitiatingClanInput[]
    upsert?: ShadowRunUpsertWithWhereUniqueWithoutInitiatingClanInput | ShadowRunUpsertWithWhereUniqueWithoutInitiatingClanInput[]
    createMany?: ShadowRunCreateManyInitiatingClanInputEnvelope
    set?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    disconnect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    delete?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    update?: ShadowRunUpdateWithWhereUniqueWithoutInitiatingClanInput | ShadowRunUpdateWithWhereUniqueWithoutInitiatingClanInput[]
    updateMany?: ShadowRunUpdateManyWithWhereWithoutInitiatingClanInput | ShadowRunUpdateManyWithWhereWithoutInitiatingClanInput[]
    deleteMany?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
  }

  export type ClanMemberUncheckedUpdateManyWithoutClanNestedInput = {
    create?: XOR<ClanMemberCreateWithoutClanInput, ClanMemberUncheckedCreateWithoutClanInput> | ClanMemberCreateWithoutClanInput[] | ClanMemberUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ClanMemberCreateOrConnectWithoutClanInput | ClanMemberCreateOrConnectWithoutClanInput[]
    upsert?: ClanMemberUpsertWithWhereUniqueWithoutClanInput | ClanMemberUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: ClanMemberCreateManyClanInputEnvelope
    set?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    disconnect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    delete?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    connect?: ClanMemberWhereUniqueInput | ClanMemberWhereUniqueInput[]
    update?: ClanMemberUpdateWithWhereUniqueWithoutClanInput | ClanMemberUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: ClanMemberUpdateManyWithWhereWithoutClanInput | ClanMemberUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: ClanMemberScalarWhereInput | ClanMemberScalarWhereInput[]
  }

  export type TerritoryUncheckedUpdateManyWithoutClanNestedInput = {
    create?: XOR<TerritoryCreateWithoutClanInput, TerritoryUncheckedCreateWithoutClanInput> | TerritoryCreateWithoutClanInput[] | TerritoryUncheckedCreateWithoutClanInput[]
    connectOrCreate?: TerritoryCreateOrConnectWithoutClanInput | TerritoryCreateOrConnectWithoutClanInput[]
    upsert?: TerritoryUpsertWithWhereUniqueWithoutClanInput | TerritoryUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: TerritoryCreateManyClanInputEnvelope
    set?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    disconnect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    delete?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    connect?: TerritoryWhereUniqueInput | TerritoryWhereUniqueInput[]
    update?: TerritoryUpdateWithWhereUniqueWithoutClanInput | TerritoryUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: TerritoryUpdateManyWithWhereWithoutClanInput | TerritoryUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutControllingClanNestedInput = {
    create?: XOR<VenueCreateWithoutControllingClanInput, VenueUncheckedCreateWithoutControllingClanInput> | VenueCreateWithoutControllingClanInput[] | VenueUncheckedCreateWithoutControllingClanInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutControllingClanInput | VenueCreateOrConnectWithoutControllingClanInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutControllingClanInput | VenueUpsertWithWhereUniqueWithoutControllingClanInput[]
    createMany?: VenueCreateManyControllingClanInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutControllingClanInput | VenueUpdateWithWhereUniqueWithoutControllingClanInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutControllingClanInput | VenueUpdateManyWithWhereWithoutControllingClanInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type ActivityEventUncheckedUpdateManyWithoutClanNestedInput = {
    create?: XOR<ActivityEventCreateWithoutClanInput, ActivityEventUncheckedCreateWithoutClanInput> | ActivityEventCreateWithoutClanInput[] | ActivityEventUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutClanInput | ActivityEventCreateOrConnectWithoutClanInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutClanInput | ActivityEventUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: ActivityEventCreateManyClanInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutClanInput | ActivityEventUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutClanInput | ActivityEventUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type ShadowRunUncheckedUpdateManyWithoutInitiatingClanNestedInput = {
    create?: XOR<ShadowRunCreateWithoutInitiatingClanInput, ShadowRunUncheckedCreateWithoutInitiatingClanInput> | ShadowRunCreateWithoutInitiatingClanInput[] | ShadowRunUncheckedCreateWithoutInitiatingClanInput[]
    connectOrCreate?: ShadowRunCreateOrConnectWithoutInitiatingClanInput | ShadowRunCreateOrConnectWithoutInitiatingClanInput[]
    upsert?: ShadowRunUpsertWithWhereUniqueWithoutInitiatingClanInput | ShadowRunUpsertWithWhereUniqueWithoutInitiatingClanInput[]
    createMany?: ShadowRunCreateManyInitiatingClanInputEnvelope
    set?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    disconnect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    delete?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    connect?: ShadowRunWhereUniqueInput | ShadowRunWhereUniqueInput[]
    update?: ShadowRunUpdateWithWhereUniqueWithoutInitiatingClanInput | ShadowRunUpdateWithWhereUniqueWithoutInitiatingClanInput[]
    updateMany?: ShadowRunUpdateManyWithWhereWithoutInitiatingClanInput | ShadowRunUpdateManyWithWhereWithoutInitiatingClanInput[]
    deleteMany?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
  }

  export type ClanCreateNestedOneWithoutMembersInput = {
    create?: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClanCreateOrConnectWithoutMembersInput
    connect?: ClanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumClanRoleFieldUpdateOperationsInput = {
    set?: $Enums.ClanRole
  }

  export type ClanUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClanCreateOrConnectWithoutMembersInput
    upsert?: ClanUpsertWithoutMembersInput
    connect?: ClanWhereUniqueInput
    update?: XOR<XOR<ClanUpdateToOneWithWhereWithoutMembersInput, ClanUpdateWithoutMembersInput>, ClanUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type VenueCreateNestedOneWithoutTerritoriesInput = {
    create?: XOR<VenueCreateWithoutTerritoriesInput, VenueUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTerritoriesInput
    connect?: VenueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTerritoriesInput = {
    create?: XOR<UserCreateWithoutTerritoriesInput, UserUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTerritoriesInput
    connect?: UserWhereUniqueInput
  }

  export type ClanCreateNestedOneWithoutTerritoriesInput = {
    create?: XOR<ClanCreateWithoutTerritoriesInput, ClanUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: ClanCreateOrConnectWithoutTerritoriesInput
    connect?: ClanWhereUniqueInput
  }

  export type TerritoryEventCreateNestedManyWithoutTerritoryInput = {
    create?: XOR<TerritoryEventCreateWithoutTerritoryInput, TerritoryEventUncheckedCreateWithoutTerritoryInput> | TerritoryEventCreateWithoutTerritoryInput[] | TerritoryEventUncheckedCreateWithoutTerritoryInput[]
    connectOrCreate?: TerritoryEventCreateOrConnectWithoutTerritoryInput | TerritoryEventCreateOrConnectWithoutTerritoryInput[]
    createMany?: TerritoryEventCreateManyTerritoryInputEnvelope
    connect?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
  }

  export type TerritoryEventUncheckedCreateNestedManyWithoutTerritoryInput = {
    create?: XOR<TerritoryEventCreateWithoutTerritoryInput, TerritoryEventUncheckedCreateWithoutTerritoryInput> | TerritoryEventCreateWithoutTerritoryInput[] | TerritoryEventUncheckedCreateWithoutTerritoryInput[]
    connectOrCreate?: TerritoryEventCreateOrConnectWithoutTerritoryInput | TerritoryEventCreateOrConnectWithoutTerritoryInput[]
    createMany?: TerritoryEventCreateManyTerritoryInputEnvelope
    connect?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
  }

  export type VenueUpdateOneRequiredWithoutTerritoriesNestedInput = {
    create?: XOR<VenueCreateWithoutTerritoriesInput, VenueUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTerritoriesInput
    upsert?: VenueUpsertWithoutTerritoriesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutTerritoriesInput, VenueUpdateWithoutTerritoriesInput>, VenueUncheckedUpdateWithoutTerritoriesInput>
  }

  export type UserUpdateOneWithoutTerritoriesNestedInput = {
    create?: XOR<UserCreateWithoutTerritoriesInput, UserUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTerritoriesInput
    upsert?: UserUpsertWithoutTerritoriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTerritoriesInput, UserUpdateWithoutTerritoriesInput>, UserUncheckedUpdateWithoutTerritoriesInput>
  }

  export type ClanUpdateOneWithoutTerritoriesNestedInput = {
    create?: XOR<ClanCreateWithoutTerritoriesInput, ClanUncheckedCreateWithoutTerritoriesInput>
    connectOrCreate?: ClanCreateOrConnectWithoutTerritoriesInput
    upsert?: ClanUpsertWithoutTerritoriesInput
    disconnect?: ClanWhereInput | boolean
    delete?: ClanWhereInput | boolean
    connect?: ClanWhereUniqueInput
    update?: XOR<XOR<ClanUpdateToOneWithWhereWithoutTerritoriesInput, ClanUpdateWithoutTerritoriesInput>, ClanUncheckedUpdateWithoutTerritoriesInput>
  }

  export type TerritoryEventUpdateManyWithoutTerritoryNestedInput = {
    create?: XOR<TerritoryEventCreateWithoutTerritoryInput, TerritoryEventUncheckedCreateWithoutTerritoryInput> | TerritoryEventCreateWithoutTerritoryInput[] | TerritoryEventUncheckedCreateWithoutTerritoryInput[]
    connectOrCreate?: TerritoryEventCreateOrConnectWithoutTerritoryInput | TerritoryEventCreateOrConnectWithoutTerritoryInput[]
    upsert?: TerritoryEventUpsertWithWhereUniqueWithoutTerritoryInput | TerritoryEventUpsertWithWhereUniqueWithoutTerritoryInput[]
    createMany?: TerritoryEventCreateManyTerritoryInputEnvelope
    set?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    disconnect?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    delete?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    connect?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    update?: TerritoryEventUpdateWithWhereUniqueWithoutTerritoryInput | TerritoryEventUpdateWithWhereUniqueWithoutTerritoryInput[]
    updateMany?: TerritoryEventUpdateManyWithWhereWithoutTerritoryInput | TerritoryEventUpdateManyWithWhereWithoutTerritoryInput[]
    deleteMany?: TerritoryEventScalarWhereInput | TerritoryEventScalarWhereInput[]
  }

  export type TerritoryEventUncheckedUpdateManyWithoutTerritoryNestedInput = {
    create?: XOR<TerritoryEventCreateWithoutTerritoryInput, TerritoryEventUncheckedCreateWithoutTerritoryInput> | TerritoryEventCreateWithoutTerritoryInput[] | TerritoryEventUncheckedCreateWithoutTerritoryInput[]
    connectOrCreate?: TerritoryEventCreateOrConnectWithoutTerritoryInput | TerritoryEventCreateOrConnectWithoutTerritoryInput[]
    upsert?: TerritoryEventUpsertWithWhereUniqueWithoutTerritoryInput | TerritoryEventUpsertWithWhereUniqueWithoutTerritoryInput[]
    createMany?: TerritoryEventCreateManyTerritoryInputEnvelope
    set?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    disconnect?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    delete?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    connect?: TerritoryEventWhereUniqueInput | TerritoryEventWhereUniqueInput[]
    update?: TerritoryEventUpdateWithWhereUniqueWithoutTerritoryInput | TerritoryEventUpdateWithWhereUniqueWithoutTerritoryInput[]
    updateMany?: TerritoryEventUpdateManyWithWhereWithoutTerritoryInput | TerritoryEventUpdateManyWithWhereWithoutTerritoryInput[]
    deleteMany?: TerritoryEventScalarWhereInput | TerritoryEventScalarWhereInput[]
  }

  export type TerritoryCreateNestedOneWithoutEventsInput = {
    create?: XOR<TerritoryCreateWithoutEventsInput, TerritoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: TerritoryCreateOrConnectWithoutEventsInput
    connect?: TerritoryWhereUniqueInput
  }

  export type EnumTerritoryEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.TerritoryEventType
  }

  export type TerritoryUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<TerritoryCreateWithoutEventsInput, TerritoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: TerritoryCreateOrConnectWithoutEventsInput
    upsert?: TerritoryUpsertWithoutEventsInput
    connect?: TerritoryWhereUniqueInput
    update?: XOR<XOR<TerritoryUpdateToOneWithWhereWithoutEventsInput, TerritoryUpdateWithoutEventsInput>, TerritoryUncheckedUpdateWithoutEventsInput>
  }

  export type VenueCreateNestedOneWithoutTournamentsInput = {
    create?: XOR<VenueCreateWithoutTournamentsInput, VenueUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTournamentsInput
    connect?: VenueWhereUniqueInput
  }

  export type TournamentParticipantCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentParticipantCreateWithoutTournamentInput, TournamentParticipantUncheckedCreateWithoutTournamentInput> | TournamentParticipantCreateWithoutTournamentInput[] | TournamentParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutTournamentInput | TournamentParticipantCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentParticipantCreateManyTournamentInputEnvelope
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutTournamentInput = {
    create?: XOR<MatchCreateWithoutTournamentInput, MatchUncheckedCreateWithoutTournamentInput> | MatchCreateWithoutTournamentInput[] | MatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTournamentInput | MatchCreateOrConnectWithoutTournamentInput[]
    createMany?: MatchCreateManyTournamentInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type ActivityEventCreateNestedManyWithoutTournamentInput = {
    create?: XOR<ActivityEventCreateWithoutTournamentInput, ActivityEventUncheckedCreateWithoutTournamentInput> | ActivityEventCreateWithoutTournamentInput[] | ActivityEventUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutTournamentInput | ActivityEventCreateOrConnectWithoutTournamentInput[]
    createMany?: ActivityEventCreateManyTournamentInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type TournamentParticipantUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentParticipantCreateWithoutTournamentInput, TournamentParticipantUncheckedCreateWithoutTournamentInput> | TournamentParticipantCreateWithoutTournamentInput[] | TournamentParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutTournamentInput | TournamentParticipantCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentParticipantCreateManyTournamentInputEnvelope
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<MatchCreateWithoutTournamentInput, MatchUncheckedCreateWithoutTournamentInput> | MatchCreateWithoutTournamentInput[] | MatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTournamentInput | MatchCreateOrConnectWithoutTournamentInput[]
    createMany?: MatchCreateManyTournamentInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type ActivityEventUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<ActivityEventCreateWithoutTournamentInput, ActivityEventUncheckedCreateWithoutTournamentInput> | ActivityEventCreateWithoutTournamentInput[] | ActivityEventUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutTournamentInput | ActivityEventCreateOrConnectWithoutTournamentInput[]
    createMany?: ActivityEventCreateManyTournamentInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type EnumTournamentStatusFieldUpdateOperationsInput = {
    set?: $Enums.TournamentStatus
  }

  export type VenueUpdateOneWithoutTournamentsNestedInput = {
    create?: XOR<VenueCreateWithoutTournamentsInput, VenueUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutTournamentsInput
    upsert?: VenueUpsertWithoutTournamentsInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutTournamentsInput, VenueUpdateWithoutTournamentsInput>, VenueUncheckedUpdateWithoutTournamentsInput>
  }

  export type TournamentParticipantUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentParticipantCreateWithoutTournamentInput, TournamentParticipantUncheckedCreateWithoutTournamentInput> | TournamentParticipantCreateWithoutTournamentInput[] | TournamentParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutTournamentInput | TournamentParticipantCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentParticipantUpsertWithWhereUniqueWithoutTournamentInput | TournamentParticipantUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentParticipantCreateManyTournamentInputEnvelope
    set?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    disconnect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    delete?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    update?: TournamentParticipantUpdateWithWhereUniqueWithoutTournamentInput | TournamentParticipantUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentParticipantUpdateManyWithWhereWithoutTournamentInput | TournamentParticipantUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentParticipantScalarWhereInput | TournamentParticipantScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<MatchCreateWithoutTournamentInput, MatchUncheckedCreateWithoutTournamentInput> | MatchCreateWithoutTournamentInput[] | MatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTournamentInput | MatchCreateOrConnectWithoutTournamentInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTournamentInput | MatchUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: MatchCreateManyTournamentInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTournamentInput | MatchUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTournamentInput | MatchUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type ActivityEventUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<ActivityEventCreateWithoutTournamentInput, ActivityEventUncheckedCreateWithoutTournamentInput> | ActivityEventCreateWithoutTournamentInput[] | ActivityEventUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutTournamentInput | ActivityEventCreateOrConnectWithoutTournamentInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutTournamentInput | ActivityEventUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: ActivityEventCreateManyTournamentInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutTournamentInput | ActivityEventUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutTournamentInput | ActivityEventUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type TournamentParticipantUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentParticipantCreateWithoutTournamentInput, TournamentParticipantUncheckedCreateWithoutTournamentInput> | TournamentParticipantCreateWithoutTournamentInput[] | TournamentParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentParticipantCreateOrConnectWithoutTournamentInput | TournamentParticipantCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentParticipantUpsertWithWhereUniqueWithoutTournamentInput | TournamentParticipantUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentParticipantCreateManyTournamentInputEnvelope
    set?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    disconnect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    delete?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    connect?: TournamentParticipantWhereUniqueInput | TournamentParticipantWhereUniqueInput[]
    update?: TournamentParticipantUpdateWithWhereUniqueWithoutTournamentInput | TournamentParticipantUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentParticipantUpdateManyWithWhereWithoutTournamentInput | TournamentParticipantUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentParticipantScalarWhereInput | TournamentParticipantScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<MatchCreateWithoutTournamentInput, MatchUncheckedCreateWithoutTournamentInput> | MatchCreateWithoutTournamentInput[] | MatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutTournamentInput | MatchCreateOrConnectWithoutTournamentInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutTournamentInput | MatchUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: MatchCreateManyTournamentInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutTournamentInput | MatchUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutTournamentInput | MatchUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type ActivityEventUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<ActivityEventCreateWithoutTournamentInput, ActivityEventUncheckedCreateWithoutTournamentInput> | ActivityEventCreateWithoutTournamentInput[] | ActivityEventUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutTournamentInput | ActivityEventCreateOrConnectWithoutTournamentInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutTournamentInput | ActivityEventUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: ActivityEventCreateManyTournamentInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutTournamentInput | ActivityEventUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutTournamentInput | ActivityEventUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type TournamentCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TournamentCreateWithoutParticipantsInput, TournamentUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutParticipantsInput
    connect?: TournamentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTournamentsInput = {
    create?: XOR<UserCreateWithoutTournamentsInput, UserUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamentsInput
    connect?: UserWhereUniqueInput
  }

  export type TournamentUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TournamentCreateWithoutParticipantsInput, TournamentUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutParticipantsInput
    upsert?: TournamentUpsertWithoutParticipantsInput
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutParticipantsInput, TournamentUpdateWithoutParticipantsInput>, TournamentUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutTournamentsNestedInput = {
    create?: XOR<UserCreateWithoutTournamentsInput, UserUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamentsInput
    upsert?: UserUpsertWithoutTournamentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTournamentsInput, UserUpdateWithoutTournamentsInput>, UserUncheckedUpdateWithoutTournamentsInput>
  }

  export type TournamentCreateNestedOneWithoutMatchesInput = {
    create?: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutMatchesInput
    connect?: TournamentWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutMatchesInput = {
    create?: XOR<VenueCreateWithoutMatchesInput, VenueUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutMatchesInput
    connect?: VenueWhereUniqueInput
  }

  export type TableCreateNestedOneWithoutMatchesInput = {
    create?: XOR<TableCreateWithoutMatchesInput, TableUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TableCreateOrConnectWithoutMatchesInput
    connect?: TableWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchesAsPlayerAInput = {
    create?: XOR<UserCreateWithoutMatchesAsPlayerAInput, UserUncheckedCreateWithoutMatchesAsPlayerAInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayerAInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchesAsPlayerBInput = {
    create?: XOR<UserCreateWithoutMatchesAsPlayerBInput, UserUncheckedCreateWithoutMatchesAsPlayerBInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayerBInput
    connect?: UserWhereUniqueInput
  }

  export type MatchEventCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchEventCreateWithoutMatchInput, MatchEventUncheckedCreateWithoutMatchInput> | MatchEventCreateWithoutMatchInput[] | MatchEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchEventCreateOrConnectWithoutMatchInput | MatchEventCreateOrConnectWithoutMatchInput[]
    createMany?: MatchEventCreateManyMatchInputEnvelope
    connect?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
  }

  export type ActivityEventCreateNestedManyWithoutMatchInput = {
    create?: XOR<ActivityEventCreateWithoutMatchInput, ActivityEventUncheckedCreateWithoutMatchInput> | ActivityEventCreateWithoutMatchInput[] | ActivityEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutMatchInput | ActivityEventCreateOrConnectWithoutMatchInput[]
    createMany?: ActivityEventCreateManyMatchInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type MatchEventUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchEventCreateWithoutMatchInput, MatchEventUncheckedCreateWithoutMatchInput> | MatchEventCreateWithoutMatchInput[] | MatchEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchEventCreateOrConnectWithoutMatchInput | MatchEventCreateOrConnectWithoutMatchInput[]
    createMany?: MatchEventCreateManyMatchInputEnvelope
    connect?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
  }

  export type ActivityEventUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<ActivityEventCreateWithoutMatchInput, ActivityEventUncheckedCreateWithoutMatchInput> | ActivityEventCreateWithoutMatchInput[] | ActivityEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutMatchInput | ActivityEventCreateOrConnectWithoutMatchInput[]
    createMany?: ActivityEventCreateManyMatchInputEnvelope
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type TournamentUpdateOneWithoutMatchesNestedInput = {
    create?: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutMatchesInput
    upsert?: TournamentUpsertWithoutMatchesInput
    disconnect?: TournamentWhereInput | boolean
    delete?: TournamentWhereInput | boolean
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutMatchesInput, TournamentUpdateWithoutMatchesInput>, TournamentUncheckedUpdateWithoutMatchesInput>
  }

  export type VenueUpdateOneWithoutMatchesNestedInput = {
    create?: XOR<VenueCreateWithoutMatchesInput, VenueUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutMatchesInput
    upsert?: VenueUpsertWithoutMatchesInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutMatchesInput, VenueUpdateWithoutMatchesInput>, VenueUncheckedUpdateWithoutMatchesInput>
  }

  export type TableUpdateOneWithoutMatchesNestedInput = {
    create?: XOR<TableCreateWithoutMatchesInput, TableUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TableCreateOrConnectWithoutMatchesInput
    upsert?: TableUpsertWithoutMatchesInput
    disconnect?: TableWhereInput | boolean
    delete?: TableWhereInput | boolean
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutMatchesInput, TableUpdateWithoutMatchesInput>, TableUncheckedUpdateWithoutMatchesInput>
  }

  export type UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput = {
    create?: XOR<UserCreateWithoutMatchesAsPlayerAInput, UserUncheckedCreateWithoutMatchesAsPlayerAInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayerAInput
    upsert?: UserUpsertWithoutMatchesAsPlayerAInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesAsPlayerAInput, UserUpdateWithoutMatchesAsPlayerAInput>, UserUncheckedUpdateWithoutMatchesAsPlayerAInput>
  }

  export type UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput = {
    create?: XOR<UserCreateWithoutMatchesAsPlayerBInput, UserUncheckedCreateWithoutMatchesAsPlayerBInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayerBInput
    upsert?: UserUpsertWithoutMatchesAsPlayerBInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesAsPlayerBInput, UserUpdateWithoutMatchesAsPlayerBInput>, UserUncheckedUpdateWithoutMatchesAsPlayerBInput>
  }

  export type MatchEventUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchEventCreateWithoutMatchInput, MatchEventUncheckedCreateWithoutMatchInput> | MatchEventCreateWithoutMatchInput[] | MatchEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchEventCreateOrConnectWithoutMatchInput | MatchEventCreateOrConnectWithoutMatchInput[]
    upsert?: MatchEventUpsertWithWhereUniqueWithoutMatchInput | MatchEventUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchEventCreateManyMatchInputEnvelope
    set?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    disconnect?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    delete?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    connect?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    update?: MatchEventUpdateWithWhereUniqueWithoutMatchInput | MatchEventUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchEventUpdateManyWithWhereWithoutMatchInput | MatchEventUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchEventScalarWhereInput | MatchEventScalarWhereInput[]
  }

  export type ActivityEventUpdateManyWithoutMatchNestedInput = {
    create?: XOR<ActivityEventCreateWithoutMatchInput, ActivityEventUncheckedCreateWithoutMatchInput> | ActivityEventCreateWithoutMatchInput[] | ActivityEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutMatchInput | ActivityEventCreateOrConnectWithoutMatchInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutMatchInput | ActivityEventUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: ActivityEventCreateManyMatchInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutMatchInput | ActivityEventUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutMatchInput | ActivityEventUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type MatchEventUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchEventCreateWithoutMatchInput, MatchEventUncheckedCreateWithoutMatchInput> | MatchEventCreateWithoutMatchInput[] | MatchEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchEventCreateOrConnectWithoutMatchInput | MatchEventCreateOrConnectWithoutMatchInput[]
    upsert?: MatchEventUpsertWithWhereUniqueWithoutMatchInput | MatchEventUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchEventCreateManyMatchInputEnvelope
    set?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    disconnect?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    delete?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    connect?: MatchEventWhereUniqueInput | MatchEventWhereUniqueInput[]
    update?: MatchEventUpdateWithWhereUniqueWithoutMatchInput | MatchEventUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchEventUpdateManyWithWhereWithoutMatchInput | MatchEventUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchEventScalarWhereInput | MatchEventScalarWhereInput[]
  }

  export type ActivityEventUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<ActivityEventCreateWithoutMatchInput, ActivityEventUncheckedCreateWithoutMatchInput> | ActivityEventCreateWithoutMatchInput[] | ActivityEventUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ActivityEventCreateOrConnectWithoutMatchInput | ActivityEventCreateOrConnectWithoutMatchInput[]
    upsert?: ActivityEventUpsertWithWhereUniqueWithoutMatchInput | ActivityEventUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: ActivityEventCreateManyMatchInputEnvelope
    set?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    disconnect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    delete?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    connect?: ActivityEventWhereUniqueInput | ActivityEventWhereUniqueInput[]
    update?: ActivityEventUpdateWithWhereUniqueWithoutMatchInput | ActivityEventUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: ActivityEventUpdateManyWithWhereWithoutMatchInput | ActivityEventUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
  }

  export type MatchCreateNestedOneWithoutEventsInput = {
    create?: XOR<MatchCreateWithoutEventsInput, MatchUncheckedCreateWithoutEventsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutEventsInput
    connect?: MatchWhereUniqueInput
  }

  export type EnumMatchEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.MatchEventType
  }

  export type MatchUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<MatchCreateWithoutEventsInput, MatchUncheckedCreateWithoutEventsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutEventsInput
    upsert?: MatchUpsertWithoutEventsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutEventsInput, MatchUpdateWithoutEventsInput>, MatchUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedOneWithoutChallengesAsChallengerInput = {
    create?: XOR<UserCreateWithoutChallengesAsChallengerInput, UserUncheckedCreateWithoutChallengesAsChallengerInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesAsChallengerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChallengesAsDefenderInput = {
    create?: XOR<UserCreateWithoutChallengesAsDefenderInput, UserUncheckedCreateWithoutChallengesAsDefenderInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesAsDefenderInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutChallengesInput = {
    create?: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutChallengesInput
    connect?: VenueWhereUniqueInput
  }

  export type EnumChallengeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeStatus
  }

  export type UserUpdateOneRequiredWithoutChallengesAsChallengerNestedInput = {
    create?: XOR<UserCreateWithoutChallengesAsChallengerInput, UserUncheckedCreateWithoutChallengesAsChallengerInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesAsChallengerInput
    upsert?: UserUpsertWithoutChallengesAsChallengerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengesAsChallengerInput, UserUpdateWithoutChallengesAsChallengerInput>, UserUncheckedUpdateWithoutChallengesAsChallengerInput>
  }

  export type UserUpdateOneRequiredWithoutChallengesAsDefenderNestedInput = {
    create?: XOR<UserCreateWithoutChallengesAsDefenderInput, UserUncheckedCreateWithoutChallengesAsDefenderInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesAsDefenderInput
    upsert?: UserUpsertWithoutChallengesAsDefenderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengesAsDefenderInput, UserUpdateWithoutChallengesAsDefenderInput>, UserUncheckedUpdateWithoutChallengesAsDefenderInput>
  }

  export type VenueUpdateOneWithoutChallengesNestedInput = {
    create?: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutChallengesInput
    upsert?: VenueUpsertWithoutChallengesInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutChallengesInput, VenueUpdateWithoutChallengesInput>, VenueUncheckedUpdateWithoutChallengesInput>
  }

  export type UserCreateNestedOneWithoutWalletsInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWalletsNestedInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    upsert?: UserUpsertWithoutWalletsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletsInput, UserUpdateWithoutWalletsInput>, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTxTypeFieldUpdateOperationsInput = {
    set?: $Enums.TxType
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserNFTCreateNestedManyWithoutNftInput = {
    create?: XOR<UserNFTCreateWithoutNftInput, UserNFTUncheckedCreateWithoutNftInput> | UserNFTCreateWithoutNftInput[] | UserNFTUncheckedCreateWithoutNftInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutNftInput | UserNFTCreateOrConnectWithoutNftInput[]
    createMany?: UserNFTCreateManyNftInputEnvelope
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
  }

  export type UserNFTUncheckedCreateNestedManyWithoutNftInput = {
    create?: XOR<UserNFTCreateWithoutNftInput, UserNFTUncheckedCreateWithoutNftInput> | UserNFTCreateWithoutNftInput[] | UserNFTUncheckedCreateWithoutNftInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutNftInput | UserNFTCreateOrConnectWithoutNftInput[]
    createMany?: UserNFTCreateManyNftInputEnvelope
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
  }

  export type UserNFTUpdateManyWithoutNftNestedInput = {
    create?: XOR<UserNFTCreateWithoutNftInput, UserNFTUncheckedCreateWithoutNftInput> | UserNFTCreateWithoutNftInput[] | UserNFTUncheckedCreateWithoutNftInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutNftInput | UserNFTCreateOrConnectWithoutNftInput[]
    upsert?: UserNFTUpsertWithWhereUniqueWithoutNftInput | UserNFTUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: UserNFTCreateManyNftInputEnvelope
    set?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    disconnect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    delete?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    update?: UserNFTUpdateWithWhereUniqueWithoutNftInput | UserNFTUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: UserNFTUpdateManyWithWhereWithoutNftInput | UserNFTUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: UserNFTScalarWhereInput | UserNFTScalarWhereInput[]
  }

  export type UserNFTUncheckedUpdateManyWithoutNftNestedInput = {
    create?: XOR<UserNFTCreateWithoutNftInput, UserNFTUncheckedCreateWithoutNftInput> | UserNFTCreateWithoutNftInput[] | UserNFTUncheckedCreateWithoutNftInput[]
    connectOrCreate?: UserNFTCreateOrConnectWithoutNftInput | UserNFTCreateOrConnectWithoutNftInput[]
    upsert?: UserNFTUpsertWithWhereUniqueWithoutNftInput | UserNFTUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: UserNFTCreateManyNftInputEnvelope
    set?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    disconnect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    delete?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    connect?: UserNFTWhereUniqueInput | UserNFTWhereUniqueInput[]
    update?: UserNFTUpdateWithWhereUniqueWithoutNftInput | UserNFTUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: UserNFTUpdateManyWithWhereWithoutNftInput | UserNFTUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: UserNFTScalarWhereInput | UserNFTScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNftsInput = {
    create?: XOR<UserCreateWithoutNftsInput, UserUncheckedCreateWithoutNftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftsInput
    connect?: UserWhereUniqueInput
  }

  export type NFTCreateNestedOneWithoutUsersInput = {
    create?: XOR<NFTCreateWithoutUsersInput, NFTUncheckedCreateWithoutUsersInput>
    connectOrCreate?: NFTCreateOrConnectWithoutUsersInput
    connect?: NFTWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNftsNestedInput = {
    create?: XOR<UserCreateWithoutNftsInput, UserUncheckedCreateWithoutNftsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftsInput
    upsert?: UserUpsertWithoutNftsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNftsInput, UserUpdateWithoutNftsInput>, UserUncheckedUpdateWithoutNftsInput>
  }

  export type NFTUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<NFTCreateWithoutUsersInput, NFTUncheckedCreateWithoutUsersInput>
    connectOrCreate?: NFTCreateOrConnectWithoutUsersInput
    upsert?: NFTUpsertWithoutUsersInput
    connect?: NFTWhereUniqueInput
    update?: XOR<XOR<NFTUpdateToOneWithWhereWithoutUsersInput, NFTUpdateWithoutUsersInput>, NFTUncheckedUpdateWithoutUsersInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUsersInput = {
    create?: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUsersInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUsersInput
    upsert?: AchievementUpsertWithoutUsersInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUsersInput, AchievementUpdateWithoutUsersInput>, AchievementUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutFriendshipsAsRequesterInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsRequesterInput, UserUncheckedCreateWithoutFriendshipsAsRequesterInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsRequesterInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriendshipsAsAddresseeInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsAddresseeInput, UserUncheckedCreateWithoutFriendshipsAsAddresseeInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsAddresseeInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFriendshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendshipStatus
  }

  export type UserUpdateOneRequiredWithoutFriendshipsAsRequesterNestedInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsRequesterInput, UserUncheckedCreateWithoutFriendshipsAsRequesterInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsRequesterInput
    upsert?: UserUpsertWithoutFriendshipsAsRequesterInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendshipsAsRequesterInput, UserUpdateWithoutFriendshipsAsRequesterInput>, UserUncheckedUpdateWithoutFriendshipsAsRequesterInput>
  }

  export type UserUpdateOneRequiredWithoutFriendshipsAsAddresseeNestedInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsAddresseeInput, UserUncheckedCreateWithoutFriendshipsAsAddresseeInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsAddresseeInput
    upsert?: UserUpsertWithoutFriendshipsAsAddresseeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendshipsAsAddresseeInput, UserUpdateWithoutFriendshipsAsAddresseeInput>, UserUncheckedUpdateWithoutFriendshipsAsAddresseeInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserCreateNestedOneWithoutActivityEventsInput = {
    create?: XOR<UserCreateWithoutActivityEventsInput, UserUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityEventsInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutActivityEventsInput = {
    create?: XOR<VenueCreateWithoutActivityEventsInput, VenueUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutActivityEventsInput
    connect?: VenueWhereUniqueInput
  }

  export type MatchCreateNestedOneWithoutActivityEventsInput = {
    create?: XOR<MatchCreateWithoutActivityEventsInput, MatchUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutActivityEventsInput
    connect?: MatchWhereUniqueInput
  }

  export type TournamentCreateNestedOneWithoutActivityEventsInput = {
    create?: XOR<TournamentCreateWithoutActivityEventsInput, TournamentUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutActivityEventsInput
    connect?: TournamentWhereUniqueInput
  }

  export type ClanCreateNestedOneWithoutActivityEventsInput = {
    create?: XOR<ClanCreateWithoutActivityEventsInput, ClanUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: ClanCreateOrConnectWithoutActivityEventsInput
    connect?: ClanWhereUniqueInput
  }

  export type UserUpdateOneWithoutActivityEventsNestedInput = {
    create?: XOR<UserCreateWithoutActivityEventsInput, UserUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityEventsInput
    upsert?: UserUpsertWithoutActivityEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityEventsInput, UserUpdateWithoutActivityEventsInput>, UserUncheckedUpdateWithoutActivityEventsInput>
  }

  export type VenueUpdateOneWithoutActivityEventsNestedInput = {
    create?: XOR<VenueCreateWithoutActivityEventsInput, VenueUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutActivityEventsInput
    upsert?: VenueUpsertWithoutActivityEventsInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutActivityEventsInput, VenueUpdateWithoutActivityEventsInput>, VenueUncheckedUpdateWithoutActivityEventsInput>
  }

  export type MatchUpdateOneWithoutActivityEventsNestedInput = {
    create?: XOR<MatchCreateWithoutActivityEventsInput, MatchUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutActivityEventsInput
    upsert?: MatchUpsertWithoutActivityEventsInput
    disconnect?: MatchWhereInput | boolean
    delete?: MatchWhereInput | boolean
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutActivityEventsInput, MatchUpdateWithoutActivityEventsInput>, MatchUncheckedUpdateWithoutActivityEventsInput>
  }

  export type TournamentUpdateOneWithoutActivityEventsNestedInput = {
    create?: XOR<TournamentCreateWithoutActivityEventsInput, TournamentUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutActivityEventsInput
    upsert?: TournamentUpsertWithoutActivityEventsInput
    disconnect?: TournamentWhereInput | boolean
    delete?: TournamentWhereInput | boolean
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutActivityEventsInput, TournamentUpdateWithoutActivityEventsInput>, TournamentUncheckedUpdateWithoutActivityEventsInput>
  }

  export type ClanUpdateOneWithoutActivityEventsNestedInput = {
    create?: XOR<ClanCreateWithoutActivityEventsInput, ClanUncheckedCreateWithoutActivityEventsInput>
    connectOrCreate?: ClanCreateOrConnectWithoutActivityEventsInput
    upsert?: ClanUpsertWithoutActivityEventsInput
    disconnect?: ClanWhereInput | boolean
    delete?: ClanWhereInput | boolean
    connect?: ClanWhereUniqueInput
    update?: XOR<XOR<ClanUpdateToOneWithWhereWithoutActivityEventsInput, ClanUpdateWithoutActivityEventsInput>, ClanUncheckedUpdateWithoutActivityEventsInput>
  }

  export type VenueCreateNestedOneWithoutQuestsInput = {
    create?: XOR<VenueCreateWithoutQuestsInput, VenueUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutQuestsInput
    connect?: VenueWhereUniqueInput
  }

  export type VenueUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<VenueCreateWithoutQuestsInput, VenueUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutQuestsInput
    upsert?: VenueUpsertWithoutQuestsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutQuestsInput, VenueUpdateWithoutQuestsInput>, VenueUncheckedUpdateWithoutQuestsInput>
  }

  export type UserCreateNestedOneWithoutGameSessionsInput = {
    create?: XOR<UserCreateWithoutGameSessionsInput, UserUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutGameSessionsInput = {
    create?: XOR<VenueCreateWithoutGameSessionsInput, VenueUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutGameSessionsInput
    connect?: VenueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGameSessionsNestedInput = {
    create?: XOR<UserCreateWithoutGameSessionsInput, UserUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGameSessionsInput
    upsert?: UserUpsertWithoutGameSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGameSessionsInput, UserUpdateWithoutGameSessionsInput>, UserUncheckedUpdateWithoutGameSessionsInput>
  }

  export type VenueUpdateOneWithoutGameSessionsNestedInput = {
    create?: XOR<VenueCreateWithoutGameSessionsInput, VenueUncheckedCreateWithoutGameSessionsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutGameSessionsInput
    upsert?: VenueUpsertWithoutGameSessionsInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutGameSessionsInput, VenueUpdateWithoutGameSessionsInput>, VenueUncheckedUpdateWithoutGameSessionsInput>
  }

  export type UserInventoryItemCreateNestedManyWithoutMarketplaceItemInput = {
    create?: XOR<UserInventoryItemCreateWithoutMarketplaceItemInput, UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput> | UserInventoryItemCreateWithoutMarketplaceItemInput[] | UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput | UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput[]
    createMany?: UserInventoryItemCreateManyMarketplaceItemInputEnvelope
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
  }

  export type CommunityCosmeticItemCreateNestedOneWithoutApprovedItemInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedCreateWithoutApprovedItemInput>
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutApprovedItemInput
    connect?: CommunityCosmeticItemWhereUniqueInput
  }

  export type UserInventoryItemUncheckedCreateNestedManyWithoutMarketplaceItemInput = {
    create?: XOR<UserInventoryItemCreateWithoutMarketplaceItemInput, UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput> | UserInventoryItemCreateWithoutMarketplaceItemInput[] | UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput | UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput[]
    createMany?: UserInventoryItemCreateManyMarketplaceItemInputEnvelope
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
  }

  export type CommunityCosmeticItemUncheckedCreateNestedOneWithoutApprovedItemInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedCreateWithoutApprovedItemInput>
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutApprovedItemInput
    connect?: CommunityCosmeticItemWhereUniqueInput
  }

  export type UserInventoryItemUpdateManyWithoutMarketplaceItemNestedInput = {
    create?: XOR<UserInventoryItemCreateWithoutMarketplaceItemInput, UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput> | UserInventoryItemCreateWithoutMarketplaceItemInput[] | UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput | UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput[]
    upsert?: UserInventoryItemUpsertWithWhereUniqueWithoutMarketplaceItemInput | UserInventoryItemUpsertWithWhereUniqueWithoutMarketplaceItemInput[]
    createMany?: UserInventoryItemCreateManyMarketplaceItemInputEnvelope
    set?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    disconnect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    delete?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    update?: UserInventoryItemUpdateWithWhereUniqueWithoutMarketplaceItemInput | UserInventoryItemUpdateWithWhereUniqueWithoutMarketplaceItemInput[]
    updateMany?: UserInventoryItemUpdateManyWithWhereWithoutMarketplaceItemInput | UserInventoryItemUpdateManyWithWhereWithoutMarketplaceItemInput[]
    deleteMany?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
  }

  export type CommunityCosmeticItemUpdateOneWithoutApprovedItemNestedInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedCreateWithoutApprovedItemInput>
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutApprovedItemInput
    upsert?: CommunityCosmeticItemUpsertWithoutApprovedItemInput
    disconnect?: CommunityCosmeticItemWhereInput | boolean
    delete?: CommunityCosmeticItemWhereInput | boolean
    connect?: CommunityCosmeticItemWhereUniqueInput
    update?: XOR<XOR<CommunityCosmeticItemUpdateToOneWithWhereWithoutApprovedItemInput, CommunityCosmeticItemUpdateWithoutApprovedItemInput>, CommunityCosmeticItemUncheckedUpdateWithoutApprovedItemInput>
  }

  export type UserInventoryItemUncheckedUpdateManyWithoutMarketplaceItemNestedInput = {
    create?: XOR<UserInventoryItemCreateWithoutMarketplaceItemInput, UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput> | UserInventoryItemCreateWithoutMarketplaceItemInput[] | UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput | UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput[]
    upsert?: UserInventoryItemUpsertWithWhereUniqueWithoutMarketplaceItemInput | UserInventoryItemUpsertWithWhereUniqueWithoutMarketplaceItemInput[]
    createMany?: UserInventoryItemCreateManyMarketplaceItemInputEnvelope
    set?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    disconnect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    delete?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    connect?: UserInventoryItemWhereUniqueInput | UserInventoryItemWhereUniqueInput[]
    update?: UserInventoryItemUpdateWithWhereUniqueWithoutMarketplaceItemInput | UserInventoryItemUpdateWithWhereUniqueWithoutMarketplaceItemInput[]
    updateMany?: UserInventoryItemUpdateManyWithWhereWithoutMarketplaceItemInput | UserInventoryItemUpdateManyWithWhereWithoutMarketplaceItemInput[]
    deleteMany?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
  }

  export type CommunityCosmeticItemUncheckedUpdateOneWithoutApprovedItemNestedInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedCreateWithoutApprovedItemInput>
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutApprovedItemInput
    upsert?: CommunityCosmeticItemUpsertWithoutApprovedItemInput
    disconnect?: CommunityCosmeticItemWhereInput | boolean
    delete?: CommunityCosmeticItemWhereInput | boolean
    connect?: CommunityCosmeticItemWhereUniqueInput
    update?: XOR<XOR<CommunityCosmeticItemUpdateToOneWithWhereWithoutApprovedItemInput, CommunityCosmeticItemUpdateWithoutApprovedItemInput>, CommunityCosmeticItemUncheckedUpdateWithoutApprovedItemInput>
  }

  export type UserCreateNestedOneWithoutCommunityItemsInput = {
    create?: XOR<UserCreateWithoutCommunityItemsInput, UserUncheckedCreateWithoutCommunityItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityItemsInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceItemCreateNestedOneWithoutCommunityItemInput = {
    create?: XOR<MarketplaceItemCreateWithoutCommunityItemInput, MarketplaceItemUncheckedCreateWithoutCommunityItemInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutCommunityItemInput
    connect?: MarketplaceItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewedItemsInput = {
    create?: XOR<UserCreateWithoutReviewedItemsInput, UserUncheckedCreateWithoutReviewedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedItemsInput
    connect?: UserWhereUniqueInput
  }

  export type CosmeticItemLikeCreateNestedManyWithoutCosmeticItemInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput> | CosmeticItemLikeCreateWithoutCosmeticItemInput[] | CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput | CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput[]
    createMany?: CosmeticItemLikeCreateManyCosmeticItemInputEnvelope
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
  }

  export type CosmeticItemLikeUncheckedCreateNestedManyWithoutCosmeticItemInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput> | CosmeticItemLikeCreateWithoutCosmeticItemInput[] | CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput | CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput[]
    createMany?: CosmeticItemLikeCreateManyCosmeticItemInputEnvelope
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
  }

  export type EnumCosmeticCategoryFieldUpdateOperationsInput = {
    set?: $Enums.CosmeticCategory
  }

  export type EnumSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionStatus
  }

  export type UserUpdateOneRequiredWithoutCommunityItemsNestedInput = {
    create?: XOR<UserCreateWithoutCommunityItemsInput, UserUncheckedCreateWithoutCommunityItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunityItemsInput
    upsert?: UserUpsertWithoutCommunityItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunityItemsInput, UserUpdateWithoutCommunityItemsInput>, UserUncheckedUpdateWithoutCommunityItemsInput>
  }

  export type MarketplaceItemUpdateOneWithoutCommunityItemNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutCommunityItemInput, MarketplaceItemUncheckedCreateWithoutCommunityItemInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutCommunityItemInput
    upsert?: MarketplaceItemUpsertWithoutCommunityItemInput
    disconnect?: MarketplaceItemWhereInput | boolean
    delete?: MarketplaceItemWhereInput | boolean
    connect?: MarketplaceItemWhereUniqueInput
    update?: XOR<XOR<MarketplaceItemUpdateToOneWithWhereWithoutCommunityItemInput, MarketplaceItemUpdateWithoutCommunityItemInput>, MarketplaceItemUncheckedUpdateWithoutCommunityItemInput>
  }

  export type UserUpdateOneWithoutReviewedItemsNestedInput = {
    create?: XOR<UserCreateWithoutReviewedItemsInput, UserUncheckedCreateWithoutReviewedItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewedItemsInput
    upsert?: UserUpsertWithoutReviewedItemsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewedItemsInput, UserUpdateWithoutReviewedItemsInput>, UserUncheckedUpdateWithoutReviewedItemsInput>
  }

  export type CosmeticItemLikeUpdateManyWithoutCosmeticItemNestedInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput> | CosmeticItemLikeCreateWithoutCosmeticItemInput[] | CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput | CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput[]
    upsert?: CosmeticItemLikeUpsertWithWhereUniqueWithoutCosmeticItemInput | CosmeticItemLikeUpsertWithWhereUniqueWithoutCosmeticItemInput[]
    createMany?: CosmeticItemLikeCreateManyCosmeticItemInputEnvelope
    set?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    disconnect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    delete?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    update?: CosmeticItemLikeUpdateWithWhereUniqueWithoutCosmeticItemInput | CosmeticItemLikeUpdateWithWhereUniqueWithoutCosmeticItemInput[]
    updateMany?: CosmeticItemLikeUpdateManyWithWhereWithoutCosmeticItemInput | CosmeticItemLikeUpdateManyWithWhereWithoutCosmeticItemInput[]
    deleteMany?: CosmeticItemLikeScalarWhereInput | CosmeticItemLikeScalarWhereInput[]
  }

  export type CosmeticItemLikeUncheckedUpdateManyWithoutCosmeticItemNestedInput = {
    create?: XOR<CosmeticItemLikeCreateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput> | CosmeticItemLikeCreateWithoutCosmeticItemInput[] | CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput[]
    connectOrCreate?: CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput | CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput[]
    upsert?: CosmeticItemLikeUpsertWithWhereUniqueWithoutCosmeticItemInput | CosmeticItemLikeUpsertWithWhereUniqueWithoutCosmeticItemInput[]
    createMany?: CosmeticItemLikeCreateManyCosmeticItemInputEnvelope
    set?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    disconnect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    delete?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    connect?: CosmeticItemLikeWhereUniqueInput | CosmeticItemLikeWhereUniqueInput[]
    update?: CosmeticItemLikeUpdateWithWhereUniqueWithoutCosmeticItemInput | CosmeticItemLikeUpdateWithWhereUniqueWithoutCosmeticItemInput[]
    updateMany?: CosmeticItemLikeUpdateManyWithWhereWithoutCosmeticItemInput | CosmeticItemLikeUpdateManyWithWhereWithoutCosmeticItemInput[]
    deleteMany?: CosmeticItemLikeScalarWhereInput | CosmeticItemLikeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCosmeticLikesInput = {
    create?: XOR<UserCreateWithoutCosmeticLikesInput, UserUncheckedCreateWithoutCosmeticLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCosmeticLikesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCosmeticItemCreateNestedOneWithoutLikedByInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutLikedByInput, CommunityCosmeticItemUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutLikedByInput
    connect?: CommunityCosmeticItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCosmeticLikesNestedInput = {
    create?: XOR<UserCreateWithoutCosmeticLikesInput, UserUncheckedCreateWithoutCosmeticLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCosmeticLikesInput
    upsert?: UserUpsertWithoutCosmeticLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCosmeticLikesInput, UserUpdateWithoutCosmeticLikesInput>, UserUncheckedUpdateWithoutCosmeticLikesInput>
  }

  export type CommunityCosmeticItemUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<CommunityCosmeticItemCreateWithoutLikedByInput, CommunityCosmeticItemUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CommunityCosmeticItemCreateOrConnectWithoutLikedByInput
    upsert?: CommunityCosmeticItemUpsertWithoutLikedByInput
    connect?: CommunityCosmeticItemWhereUniqueInput
    update?: XOR<XOR<CommunityCosmeticItemUpdateToOneWithWhereWithoutLikedByInput, CommunityCosmeticItemUpdateWithoutLikedByInput>, CommunityCosmeticItemUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutShadowRunsInput = {
    create?: XOR<UserCreateWithoutShadowRunsInput, UserUncheckedCreateWithoutShadowRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShadowRunsInput
    connect?: UserWhereUniqueInput
  }

  export type ClanCreateNestedOneWithoutShadowRunsInput = {
    create?: XOR<ClanCreateWithoutShadowRunsInput, ClanUncheckedCreateWithoutShadowRunsInput>
    connectOrCreate?: ClanCreateOrConnectWithoutShadowRunsInput
    connect?: ClanWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutShadowRunsInput = {
    create?: XOR<VenueCreateWithoutShadowRunsInput, VenueUncheckedCreateWithoutShadowRunsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutShadowRunsInput
    connect?: VenueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutShadowRunsNestedInput = {
    create?: XOR<UserCreateWithoutShadowRunsInput, UserUncheckedCreateWithoutShadowRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShadowRunsInput
    upsert?: UserUpsertWithoutShadowRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShadowRunsInput, UserUpdateWithoutShadowRunsInput>, UserUncheckedUpdateWithoutShadowRunsInput>
  }

  export type ClanUpdateOneWithoutShadowRunsNestedInput = {
    create?: XOR<ClanCreateWithoutShadowRunsInput, ClanUncheckedCreateWithoutShadowRunsInput>
    connectOrCreate?: ClanCreateOrConnectWithoutShadowRunsInput
    upsert?: ClanUpsertWithoutShadowRunsInput
    disconnect?: ClanWhereInput | boolean
    delete?: ClanWhereInput | boolean
    connect?: ClanWhereUniqueInput
    update?: XOR<XOR<ClanUpdateToOneWithWhereWithoutShadowRunsInput, ClanUpdateWithoutShadowRunsInput>, ClanUncheckedUpdateWithoutShadowRunsInput>
  }

  export type VenueUpdateOneWithoutShadowRunsNestedInput = {
    create?: XOR<VenueCreateWithoutShadowRunsInput, VenueUncheckedCreateWithoutShadowRunsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutShadowRunsInput
    upsert?: VenueUpsertWithoutShadowRunsInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutShadowRunsInput, VenueUpdateWithoutShadowRunsInput>, VenueUncheckedUpdateWithoutShadowRunsInput>
  }

  export type UserCreateNestedOneWithoutDojoCheckInsInput = {
    create?: XOR<UserCreateWithoutDojoCheckInsInput, UserUncheckedCreateWithoutDojoCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDojoCheckInsInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutDojoCheckInsInput = {
    create?: XOR<VenueCreateWithoutDojoCheckInsInput, VenueUncheckedCreateWithoutDojoCheckInsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutDojoCheckInsInput
    connect?: VenueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDojoCheckInsNestedInput = {
    create?: XOR<UserCreateWithoutDojoCheckInsInput, UserUncheckedCreateWithoutDojoCheckInsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDojoCheckInsInput
    upsert?: UserUpsertWithoutDojoCheckInsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDojoCheckInsInput, UserUpdateWithoutDojoCheckInsInput>, UserUncheckedUpdateWithoutDojoCheckInsInput>
  }

  export type VenueUpdateOneRequiredWithoutDojoCheckInsNestedInput = {
    create?: XOR<VenueCreateWithoutDojoCheckInsInput, VenueUncheckedCreateWithoutDojoCheckInsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutDojoCheckInsInput
    upsert?: VenueUpsertWithoutDojoCheckInsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutDojoCheckInsInput, VenueUpdateWithoutDojoCheckInsInput>, VenueUncheckedUpdateWithoutDojoCheckInsInput>
  }

  export type VenueCreateNestedOneWithoutSpecialsInput = {
    create?: XOR<VenueCreateWithoutSpecialsInput, VenueUncheckedCreateWithoutSpecialsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutSpecialsInput
    connect?: VenueWhereUniqueInput
  }

  export type VenueUpdateOneRequiredWithoutSpecialsNestedInput = {
    create?: XOR<VenueCreateWithoutSpecialsInput, VenueUncheckedCreateWithoutSpecialsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutSpecialsInput
    upsert?: VenueUpsertWithoutSpecialsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutSpecialsInput, VenueUpdateWithoutSpecialsInput>, VenueUncheckedUpdateWithoutSpecialsInput>
  }

  export type UserCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<UserCreateWithoutInventoryItemsInput, UserUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryItemsInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceItemCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<MarketplaceItemCreateWithoutInventoryItemsInput, MarketplaceItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutInventoryItemsInput
    connect?: MarketplaceItemWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryItemsInput, UserUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryItemsInput
    upsert?: UserUpsertWithoutInventoryItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryItemsInput, UserUpdateWithoutInventoryItemsInput>, UserUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type MarketplaceItemUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutInventoryItemsInput, MarketplaceItemUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutInventoryItemsInput
    upsert?: MarketplaceItemUpsertWithoutInventoryItemsInput
    connect?: MarketplaceItemWhereUniqueInput
    update?: XOR<XOR<MarketplaceItemUpdateToOneWithWhereWithoutInventoryItemsInput, MarketplaceItemUpdateWithoutInventoryItemsInput>, MarketplaceItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type UserCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResolvedFeedbackInput = {
    create?: XOR<UserCreateWithoutResolvedFeedbackInput, UserUncheckedCreateWithoutResolvedFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeedbackCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackCategory
  }

  export type EnumFeedbackStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackStatus
  }

  export type EnumFeedbackPriorityFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackPriority
  }

  export type UserUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    upsert?: UserUpsertWithoutFeedbackInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackInput, UserUpdateWithoutFeedbackInput>, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateOneWithoutResolvedFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutResolvedFeedbackInput, UserUncheckedCreateWithoutResolvedFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedFeedbackInput
    upsert?: UserUpsertWithoutResolvedFeedbackInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResolvedFeedbackInput, UserUpdateWithoutResolvedFeedbackInput>, UserUncheckedUpdateWithoutResolvedFeedbackInput>
  }

  export type UserCreateNestedOneWithoutContentInput = {
    create?: XOR<UserCreateWithoutContentInput, UserUncheckedCreateWithoutContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutModeratedContentInput = {
    create?: XOR<UserCreateWithoutModeratedContentInput, UserUncheckedCreateWithoutModeratedContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratedContentInput
    connect?: UserWhereUniqueInput
  }

  export type ContentLikeCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentLikeCreateWithoutContentInput, ContentLikeUncheckedCreateWithoutContentInput> | ContentLikeCreateWithoutContentInput[] | ContentLikeUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutContentInput | ContentLikeCreateOrConnectWithoutContentInput[]
    createMany?: ContentLikeCreateManyContentInputEnvelope
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
  }

  export type ContentShareCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentShareCreateWithoutContentInput, ContentShareUncheckedCreateWithoutContentInput> | ContentShareCreateWithoutContentInput[] | ContentShareUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutContentInput | ContentShareCreateOrConnectWithoutContentInput[]
    createMany?: ContentShareCreateManyContentInputEnvelope
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
  }

  export type ContentLikeUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentLikeCreateWithoutContentInput, ContentLikeUncheckedCreateWithoutContentInput> | ContentLikeCreateWithoutContentInput[] | ContentLikeUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutContentInput | ContentLikeCreateOrConnectWithoutContentInput[]
    createMany?: ContentLikeCreateManyContentInputEnvelope
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
  }

  export type ContentShareUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentShareCreateWithoutContentInput, ContentShareUncheckedCreateWithoutContentInput> | ContentShareCreateWithoutContentInput[] | ContentShareUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutContentInput | ContentShareCreateOrConnectWithoutContentInput[]
    createMany?: ContentShareCreateManyContentInputEnvelope
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContentStatus
  }

  export type EnumContentVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.ContentVisibility
  }

  export type UserUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<UserCreateWithoutContentInput, UserUncheckedCreateWithoutContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentInput
    upsert?: UserUpsertWithoutContentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContentInput, UserUpdateWithoutContentInput>, UserUncheckedUpdateWithoutContentInput>
  }

  export type UserUpdateOneWithoutModeratedContentNestedInput = {
    create?: XOR<UserCreateWithoutModeratedContentInput, UserUncheckedCreateWithoutModeratedContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratedContentInput
    upsert?: UserUpsertWithoutModeratedContentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModeratedContentInput, UserUpdateWithoutModeratedContentInput>, UserUncheckedUpdateWithoutModeratedContentInput>
  }

  export type ContentLikeUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentLikeCreateWithoutContentInput, ContentLikeUncheckedCreateWithoutContentInput> | ContentLikeCreateWithoutContentInput[] | ContentLikeUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutContentInput | ContentLikeCreateOrConnectWithoutContentInput[]
    upsert?: ContentLikeUpsertWithWhereUniqueWithoutContentInput | ContentLikeUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentLikeCreateManyContentInputEnvelope
    set?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    disconnect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    delete?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    update?: ContentLikeUpdateWithWhereUniqueWithoutContentInput | ContentLikeUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentLikeUpdateManyWithWhereWithoutContentInput | ContentLikeUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentLikeScalarWhereInput | ContentLikeScalarWhereInput[]
  }

  export type ContentShareUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentShareCreateWithoutContentInput, ContentShareUncheckedCreateWithoutContentInput> | ContentShareCreateWithoutContentInput[] | ContentShareUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutContentInput | ContentShareCreateOrConnectWithoutContentInput[]
    upsert?: ContentShareUpsertWithWhereUniqueWithoutContentInput | ContentShareUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentShareCreateManyContentInputEnvelope
    set?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    disconnect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    delete?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    update?: ContentShareUpdateWithWhereUniqueWithoutContentInput | ContentShareUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentShareUpdateManyWithWhereWithoutContentInput | ContentShareUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
  }

  export type ContentLikeUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentLikeCreateWithoutContentInput, ContentLikeUncheckedCreateWithoutContentInput> | ContentLikeCreateWithoutContentInput[] | ContentLikeUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentLikeCreateOrConnectWithoutContentInput | ContentLikeCreateOrConnectWithoutContentInput[]
    upsert?: ContentLikeUpsertWithWhereUniqueWithoutContentInput | ContentLikeUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentLikeCreateManyContentInputEnvelope
    set?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    disconnect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    delete?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    connect?: ContentLikeWhereUniqueInput | ContentLikeWhereUniqueInput[]
    update?: ContentLikeUpdateWithWhereUniqueWithoutContentInput | ContentLikeUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentLikeUpdateManyWithWhereWithoutContentInput | ContentLikeUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentLikeScalarWhereInput | ContentLikeScalarWhereInput[]
  }

  export type ContentShareUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentShareCreateWithoutContentInput, ContentShareUncheckedCreateWithoutContentInput> | ContentShareCreateWithoutContentInput[] | ContentShareUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentShareCreateOrConnectWithoutContentInput | ContentShareCreateOrConnectWithoutContentInput[]
    upsert?: ContentShareUpsertWithWhereUniqueWithoutContentInput | ContentShareUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentShareCreateManyContentInputEnvelope
    set?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    disconnect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    delete?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    connect?: ContentShareWhereUniqueInput | ContentShareWhereUniqueInput[]
    update?: ContentShareUpdateWithWhereUniqueWithoutContentInput | ContentShareUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentShareUpdateManyWithWhereWithoutContentInput | ContentShareUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutLikedByInput = {
    create?: XOR<ContentCreateWithoutLikedByInput, ContentUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: ContentCreateOrConnectWithoutLikedByInput
    connect?: ContentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContentLikesInput = {
    create?: XOR<UserCreateWithoutContentLikesInput, UserUncheckedCreateWithoutContentLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentLikesInput
    connect?: UserWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<ContentCreateWithoutLikedByInput, ContentUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: ContentCreateOrConnectWithoutLikedByInput
    upsert?: ContentUpsertWithoutLikedByInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutLikedByInput, ContentUpdateWithoutLikedByInput>, ContentUncheckedUpdateWithoutLikedByInput>
  }

  export type UserUpdateOneRequiredWithoutContentLikesNestedInput = {
    create?: XOR<UserCreateWithoutContentLikesInput, UserUncheckedCreateWithoutContentLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContentLikesInput
    upsert?: UserUpsertWithoutContentLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContentLikesInput, UserUpdateWithoutContentLikesInput>, UserUncheckedUpdateWithoutContentLikesInput>
  }

  export type ContentCreateNestedOneWithoutSharedEntriesInput = {
    create?: XOR<ContentCreateWithoutSharedEntriesInput, ContentUncheckedCreateWithoutSharedEntriesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutSharedEntriesInput
    connect?: ContentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedContentInput = {
    create?: XOR<UserCreateWithoutSharedContentInput, UserUncheckedCreateWithoutSharedContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedContentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedSharesInput = {
    create?: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedSharesInput
    connect?: UserWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutSharedEntriesNestedInput = {
    create?: XOR<ContentCreateWithoutSharedEntriesInput, ContentUncheckedCreateWithoutSharedEntriesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutSharedEntriesInput
    upsert?: ContentUpsertWithoutSharedEntriesInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutSharedEntriesInput, ContentUpdateWithoutSharedEntriesInput>, ContentUncheckedUpdateWithoutSharedEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutSharedContentNestedInput = {
    create?: XOR<UserCreateWithoutSharedContentInput, UserUncheckedCreateWithoutSharedContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedContentInput
    upsert?: UserUpsertWithoutSharedContentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedContentInput, UserUpdateWithoutSharedContentInput>, UserUncheckedUpdateWithoutSharedContentInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedSharesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedSharesInput
    upsert?: UserUpsertWithoutReceivedSharesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedSharesInput, UserUpdateWithoutReceivedSharesInput>, UserUncheckedUpdateWithoutReceivedSharesInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumTableStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TableStatus | EnumTableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTableStatusFilter<$PrismaModel> | $Enums.TableStatus
  }

  export type NestedEnumTableStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TableStatus | EnumTableStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TableStatus[] | ListEnumTableStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTableStatusWithAggregatesFilter<$PrismaModel> | $Enums.TableStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTableStatusFilter<$PrismaModel>
    _max?: NestedEnumTableStatusFilter<$PrismaModel>
  }

  export type NestedEnumCheckInMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckInMethod | EnumCheckInMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckInMethodFilter<$PrismaModel> | $Enums.CheckInMethod
  }

  export type NestedEnumCheckInMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CheckInMethod | EnumCheckInMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CheckInMethod[] | ListEnumCheckInMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCheckInMethodWithAggregatesFilter<$PrismaModel> | $Enums.CheckInMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCheckInMethodFilter<$PrismaModel>
    _max?: NestedEnumCheckInMethodFilter<$PrismaModel>
  }

  export type NestedEnumClanRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ClanRole | EnumClanRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClanRoleFilter<$PrismaModel> | $Enums.ClanRole
  }

  export type NestedEnumClanRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClanRole | EnumClanRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClanRole[] | ListEnumClanRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClanRoleWithAggregatesFilter<$PrismaModel> | $Enums.ClanRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClanRoleFilter<$PrismaModel>
    _max?: NestedEnumClanRoleFilter<$PrismaModel>
  }

  export type NestedEnumTerritoryEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TerritoryEventType | EnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerritoryEventTypeFilter<$PrismaModel> | $Enums.TerritoryEventType
  }

  export type NestedEnumTerritoryEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TerritoryEventType | EnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TerritoryEventType[] | ListEnumTerritoryEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTerritoryEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TerritoryEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTerritoryEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTerritoryEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchEventType | EnumMatchEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchEventTypeFilter<$PrismaModel> | $Enums.MatchEventType
  }

  export type NestedEnumMatchEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchEventType | EnumMatchEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchEventType[] | ListEnumMatchEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchEventTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type NestedEnumTxTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeFilter<$PrismaModel> | $Enums.TxType
  }

  export type NestedEnumTxTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TxType | EnumTxTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TxType[] | ListEnumTxTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTxTypeWithAggregatesFilter<$PrismaModel> | $Enums.TxType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTxTypeFilter<$PrismaModel>
    _max?: NestedEnumTxTypeFilter<$PrismaModel>
  }

  export type NestedEnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCosmeticCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CosmeticCategory | EnumCosmeticCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCosmeticCategoryFilter<$PrismaModel> | $Enums.CosmeticCategory
  }

  export type NestedEnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type NestedEnumCosmeticCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CosmeticCategory | EnumCosmeticCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CosmeticCategory[] | ListEnumCosmeticCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCosmeticCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CosmeticCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCosmeticCategoryFilter<$PrismaModel>
    _max?: NestedEnumCosmeticCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type NestedEnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }

  export type NestedEnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type NestedEnumContentVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentVisibility | EnumContentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumContentVisibilityFilter<$PrismaModel> | $Enums.ContentVisibility
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type NestedEnumContentVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentVisibility | EnumContentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentVisibility[] | ListEnumContentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumContentVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ContentVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentVisibilityFilter<$PrismaModel>
    _max?: NestedEnumContentVisibilityFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    avatarUrl?: string | null
    location?: string | null
    skillRating?: number
    clanTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName?: string | null
    bio?: string | null
    avatarUrl?: string | null
    location?: string | null
    skillRating?: number
    clanTitle?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: string
    timezone?: string
    privacySettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    emailNotifications?: boolean
    pushNotifications?: boolean
    darkMode?: boolean
    language?: string
    timezone?: string
    privacySettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    chain: string
    address: string
    createdAt?: Date | string
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    chain: string
    address: string
    createdAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletCreateManyUserInputEnvelope = {
    data: WalletCreateManyUserInput | WalletCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserNFTCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    nft: NFTCreateNestedOneWithoutUsersInput
  }

  export type UserNFTUncheckedCreateWithoutUserInput = {
    id?: string
    nftId: string
    createdAt?: Date | string
  }

  export type UserNFTCreateOrConnectWithoutUserInput = {
    where: UserNFTWhereUniqueInput
    create: XOR<UserNFTCreateWithoutUserInput, UserNFTUncheckedCreateWithoutUserInput>
  }

  export type UserNFTCreateManyUserInputEnvelope = {
    data: UserNFTCreateManyUserInput | UserNFTCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    earnedAt?: Date | string
    achievement: AchievementCreateNestedOneWithoutUsersInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    earnedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClanMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
    clan: ClanCreateNestedOneWithoutMembersInput
  }

  export type ClanMemberUncheckedCreateWithoutUserInput = {
    id?: string
    clanId: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
  }

  export type ClanMemberCreateOrConnectWithoutUserInput = {
    where: ClanMemberWhereUniqueInput
    create: XOR<ClanMemberCreateWithoutUserInput, ClanMemberUncheckedCreateWithoutUserInput>
  }

  export type ClanMemberCreateManyUserInputEnvelope = {
    data: ClanMemberCreateManyUserInput | ClanMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TerritoryCreateWithoutOwnerInput = {
    id?: string
    name?: string
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutTerritoriesInput
    clan?: ClanCreateNestedOneWithoutTerritoriesInput
    events?: TerritoryEventCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryUncheckedCreateWithoutOwnerInput = {
    id?: string
    venueId: string
    name?: string
    clanId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TerritoryEventUncheckedCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryCreateOrConnectWithoutOwnerInput = {
    where: TerritoryWhereUniqueInput
    create: XOR<TerritoryCreateWithoutOwnerInput, TerritoryUncheckedCreateWithoutOwnerInput>
  }

  export type TerritoryCreateManyOwnerInputEnvelope = {
    data: TerritoryCreateManyOwnerInput | TerritoryCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type CheckInCreateWithoutUserInput = {
    id?: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
    venue: VenueCreateNestedOneWithoutCheckInsInput
  }

  export type CheckInUncheckedCreateWithoutUserInput = {
    id?: string
    venueId: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
  }

  export type CheckInCreateOrConnectWithoutUserInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutUserInput, CheckInUncheckedCreateWithoutUserInput>
  }

  export type CheckInCreateManyUserInputEnvelope = {
    data: CheckInCreateManyUserInput | CheckInCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeCreateWithoutChallengerInput = {
    id?: string
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defender: UserCreateNestedOneWithoutChallengesAsDefenderInput
    venue?: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutChallengerInput = {
    id?: string
    defenderId: string
    venueId?: string | null
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeCreateOrConnectWithoutChallengerInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutChallengerInput, ChallengeUncheckedCreateWithoutChallengerInput>
  }

  export type ChallengeCreateManyChallengerInputEnvelope = {
    data: ChallengeCreateManyChallengerInput | ChallengeCreateManyChallengerInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeCreateWithoutDefenderInput = {
    id?: string
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    challenger: UserCreateNestedOneWithoutChallengesAsChallengerInput
    venue?: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeUncheckedCreateWithoutDefenderInput = {
    id?: string
    challengerId: string
    venueId?: string | null
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeCreateOrConnectWithoutDefenderInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutDefenderInput, ChallengeUncheckedCreateWithoutDefenderInput>
  }

  export type ChallengeCreateManyDefenderInputEnvelope = {
    data: ChallengeCreateManyDefenderInput | ChallengeCreateManyDefenderInput[]
    skipDuplicates?: boolean
  }

  export type ClanCreateWithoutLeaderInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClanMemberCreateNestedManyWithoutClanInput
    territories?: TerritoryCreateNestedManyWithoutClanInput
    controlledVenues?: VenueCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanUncheckedCreateWithoutLeaderInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClanMemberUncheckedCreateNestedManyWithoutClanInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutClanInput
    controlledVenues?: VenueUncheckedCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanCreateOrConnectWithoutLeaderInput = {
    where: ClanWhereUniqueInput
    create: XOR<ClanCreateWithoutLeaderInput, ClanUncheckedCreateWithoutLeaderInput>
  }

  export type ClanCreateManyLeaderInputEnvelope = {
    data: ClanCreateManyLeaderInput | ClanCreateManyLeaderInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutPlayerAInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament?: TournamentCreateNestedOneWithoutMatchesInput
    venue?: VenueCreateNestedOneWithoutMatchesInput
    table?: TableCreateNestedOneWithoutMatchesInput
    playerB: UserCreateNestedOneWithoutMatchesAsPlayerBInput
    events?: MatchEventCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutPlayerAInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: MatchEventUncheckedCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutPlayerAInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutPlayerAInput, MatchUncheckedCreateWithoutPlayerAInput>
  }

  export type MatchCreateManyPlayerAInputEnvelope = {
    data: MatchCreateManyPlayerAInput | MatchCreateManyPlayerAInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutPlayerBInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament?: TournamentCreateNestedOneWithoutMatchesInput
    venue?: VenueCreateNestedOneWithoutMatchesInput
    table?: TableCreateNestedOneWithoutMatchesInput
    playerA: UserCreateNestedOneWithoutMatchesAsPlayerAInput
    events?: MatchEventCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutPlayerBInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: MatchEventUncheckedCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutPlayerBInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutPlayerBInput, MatchUncheckedCreateWithoutPlayerBInput>
  }

  export type MatchCreateManyPlayerBInputEnvelope = {
    data: MatchCreateManyPlayerBInput | MatchCreateManyPlayerBInput[]
    skipDuplicates?: boolean
  }

  export type TournamentParticipantCreateWithoutUserInput = {
    id?: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
    tournament: TournamentCreateNestedOneWithoutParticipantsInput
  }

  export type TournamentParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    tournamentId: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
  }

  export type TournamentParticipantCreateOrConnectWithoutUserInput = {
    where: TournamentParticipantWhereUniqueInput
    create: XOR<TournamentParticipantCreateWithoutUserInput, TournamentParticipantUncheckedCreateWithoutUserInput>
  }

  export type TournamentParticipantCreateManyUserInputEnvelope = {
    data: TournamentParticipantCreateManyUserInput | TournamentParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    type: $Enums.TxType
    metadata: string
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    type: $Enums.TxType
    metadata: string
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message?: string | null
    payload: string
    read?: boolean
    isRead?: boolean
    recipientId?: string | null
    title?: string | null
    priority?: string
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message?: string | null
    payload: string
    read?: boolean
    isRead?: boolean
    recipientId?: string | null
    title?: string | null
    priority?: string
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    target?: string | null
    metadata: string
    ts?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    action: string
    target?: string | null
    metadata: string
    ts?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type VenueCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutOwnerInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutOwnerInput, VenueUncheckedCreateWithoutOwnerInput>
  }

  export type VenueCreateManyOwnerInputEnvelope = {
    data: VenueCreateManyOwnerInput | VenueCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutRequesterInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    addressee: UserCreateNestedOneWithoutFriendshipsAsAddresseeInput
  }

  export type FriendshipUncheckedCreateWithoutRequesterInput = {
    id?: string
    addresseeId: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutRequesterInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutRequesterInput, FriendshipUncheckedCreateWithoutRequesterInput>
  }

  export type FriendshipCreateManyRequesterInputEnvelope = {
    data: FriendshipCreateManyRequesterInput | FriendshipCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutAddresseeInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    requester: UserCreateNestedOneWithoutFriendshipsAsRequesterInput
  }

  export type FriendshipUncheckedCreateWithoutAddresseeInput = {
    id?: string
    requesterId: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutAddresseeInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutAddresseeInput, FriendshipUncheckedCreateWithoutAddresseeInput>
  }

  export type FriendshipCreateManyAddresseeInputEnvelope = {
    data: FriendshipCreateManyAddresseeInput | FriendshipCreateManyAddresseeInput[]
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutSenderInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput>
  }

  export type DirectMessageCreateManySenderInputEnvelope = {
    data: DirectMessageCreateManySenderInput | DirectMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutReceiverInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput>
  }

  export type DirectMessageCreateManyReceiverInputEnvelope = {
    data: DirectMessageCreateManyReceiverInput | DirectMessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ActivityEventCreateWithoutUserInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutActivityEventsInput
    match?: MatchCreateNestedOneWithoutActivityEventsInput
    tournament?: TournamentCreateNestedOneWithoutActivityEventsInput
    clan?: ClanCreateNestedOneWithoutActivityEventsInput
  }

  export type ActivityEventUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateOrConnectWithoutUserInput = {
    where: ActivityEventWhereUniqueInput
    create: XOR<ActivityEventCreateWithoutUserInput, ActivityEventUncheckedCreateWithoutUserInput>
  }

  export type ActivityEventCreateManyUserInputEnvelope = {
    data: ActivityEventCreateManyUserInput | ActivityEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionCreateWithoutPlayerInput = {
    id?: string
    gameId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutGameSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutPlayerInput = {
    id?: string
    gameId?: string | null
    venueId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameSessionCreateOrConnectWithoutPlayerInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutPlayerInput, GameSessionUncheckedCreateWithoutPlayerInput>
  }

  export type GameSessionCreateManyPlayerInputEnvelope = {
    data: GameSessionCreateManyPlayerInput | GameSessionCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type ShadowRunCreateWithoutPlayerInput = {
    id?: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    initiatingClan?: ClanCreateNestedOneWithoutShadowRunsInput
    targetVenue?: VenueCreateNestedOneWithoutShadowRunsInput
  }

  export type ShadowRunUncheckedCreateWithoutPlayerInput = {
    id?: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    initiatingClanId?: string | null
    targetVenueId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShadowRunCreateOrConnectWithoutPlayerInput = {
    where: ShadowRunWhereUniqueInput
    create: XOR<ShadowRunCreateWithoutPlayerInput, ShadowRunUncheckedCreateWithoutPlayerInput>
  }

  export type ShadowRunCreateManyPlayerInputEnvelope = {
    data: ShadowRunCreateManyPlayerInput | ShadowRunCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type DojoCheckInCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    venue: VenueCreateNestedOneWithoutDojoCheckInsInput
  }

  export type DojoCheckInUncheckedCreateWithoutUserInput = {
    id?: string
    venueId: string
    createdAt?: Date | string
  }

  export type DojoCheckInCreateOrConnectWithoutUserInput = {
    where: DojoCheckInWhereUniqueInput
    create: XOR<DojoCheckInCreateWithoutUserInput, DojoCheckInUncheckedCreateWithoutUserInput>
  }

  export type DojoCheckInCreateManyUserInputEnvelope = {
    data: DojoCheckInCreateManyUserInput | DojoCheckInCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInventoryItemCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    marketplaceItem: MarketplaceItemCreateNestedOneWithoutInventoryItemsInput
  }

  export type UserInventoryItemUncheckedCreateWithoutUserInput = {
    id?: string
    marketplaceItemId: string
    createdAt?: Date | string
  }

  export type UserInventoryItemCreateOrConnectWithoutUserInput = {
    where: UserInventoryItemWhereUniqueInput
    create: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryItemCreateManyUserInputEnvelope = {
    data: UserInventoryItemCreateManyUserInput | UserInventoryItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutUserInput = {
    id?: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    resolver?: UserCreateNestedOneWithoutResolvedFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateManyUserInputEnvelope = {
    data: FeedbackCreateManyUserInput | FeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutResolverInput = {
    id?: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutResolverInput = {
    id?: string
    userId: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type FeedbackCreateOrConnectWithoutResolverInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutResolverInput, FeedbackUncheckedCreateWithoutResolverInput>
  }

  export type FeedbackCreateManyResolverInputEnvelope = {
    data: FeedbackCreateManyResolverInput | FeedbackCreateManyResolverInput[]
    skipDuplicates?: boolean
  }

  export type ContentCreateWithoutUserInput = {
    id?: string
    contentId?: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    moderator?: UserCreateNestedOneWithoutModeratedContentInput
    likedBy?: ContentLikeCreateNestedManyWithoutContentInput
    sharedEntries?: ContentShareCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutUserInput = {
    id?: string
    contentId?: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: ContentLikeUncheckedCreateNestedManyWithoutContentInput
    sharedEntries?: ContentShareUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutUserInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutUserInput, ContentUncheckedCreateWithoutUserInput>
  }

  export type ContentCreateManyUserInputEnvelope = {
    data: ContentCreateManyUserInput | ContentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContentCreateWithoutModeratorInput = {
    id?: string
    contentId?: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContentInput
    likedBy?: ContentLikeCreateNestedManyWithoutContentInput
    sharedEntries?: ContentShareCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutModeratorInput = {
    id?: string
    contentId?: string
    userId: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: ContentLikeUncheckedCreateNestedManyWithoutContentInput
    sharedEntries?: ContentShareUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutModeratorInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutModeratorInput, ContentUncheckedCreateWithoutModeratorInput>
  }

  export type ContentCreateManyModeratorInputEnvelope = {
    data: ContentCreateManyModeratorInput | ContentCreateManyModeratorInput[]
    skipDuplicates?: boolean
  }

  export type ContentLikeCreateWithoutUserInput = {
    id?: string
    likes?: number
    createdAt?: Date | string
    content: ContentCreateNestedOneWithoutLikedByInput
  }

  export type ContentLikeUncheckedCreateWithoutUserInput = {
    id?: string
    contentId: string
    likes?: number
    createdAt?: Date | string
  }

  export type ContentLikeCreateOrConnectWithoutUserInput = {
    where: ContentLikeWhereUniqueInput
    create: XOR<ContentLikeCreateWithoutUserInput, ContentLikeUncheckedCreateWithoutUserInput>
  }

  export type ContentLikeCreateManyUserInputEnvelope = {
    data: ContentLikeCreateManyUserInput | ContentLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    deviceId?: string | null
    deviceInfo?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    deviceId?: string | null
    deviceInfo?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContentShareCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: ContentCreateNestedOneWithoutSharedEntriesInput
    sharedWith: UserCreateNestedOneWithoutReceivedSharesInput
  }

  export type ContentShareUncheckedCreateWithoutUserInput = {
    id?: string
    contentId: string
    sharedWithId: string
    createdAt?: Date | string
  }

  export type ContentShareCreateOrConnectWithoutUserInput = {
    where: ContentShareWhereUniqueInput
    create: XOR<ContentShareCreateWithoutUserInput, ContentShareUncheckedCreateWithoutUserInput>
  }

  export type ContentShareCreateManyUserInputEnvelope = {
    data: ContentShareCreateManyUserInput | ContentShareCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContentShareCreateWithoutSharedWithInput = {
    id?: string
    createdAt?: Date | string
    content: ContentCreateNestedOneWithoutSharedEntriesInput
    user: UserCreateNestedOneWithoutSharedContentInput
  }

  export type ContentShareUncheckedCreateWithoutSharedWithInput = {
    id?: string
    contentId: string
    userId: string
    createdAt?: Date | string
  }

  export type ContentShareCreateOrConnectWithoutSharedWithInput = {
    where: ContentShareWhereUniqueInput
    create: XOR<ContentShareCreateWithoutSharedWithInput, ContentShareUncheckedCreateWithoutSharedWithInput>
  }

  export type ContentShareCreateManySharedWithInputEnvelope = {
    data: ContentShareCreateManySharedWithInput | ContentShareCreateManySharedWithInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCosmeticItemCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedItem?: MarketplaceItemCreateNestedOneWithoutCommunityItemInput
    reviewer?: UserCreateNestedOneWithoutReviewedItemsInput
    likedBy?: CosmeticItemLikeCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    approvedItemId?: string | null
    reviewerId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: CosmeticItemLikeUncheckedCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemCreateOrConnectWithoutCreatorInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    create: XOR<CommunityCosmeticItemCreateWithoutCreatorInput, CommunityCosmeticItemUncheckedCreateWithoutCreatorInput>
  }

  export type CommunityCosmeticItemCreateManyCreatorInputEnvelope = {
    data: CommunityCosmeticItemCreateManyCreatorInput | CommunityCosmeticItemCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCosmeticItemCreateWithoutReviewerInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCommunityItemsInput
    approvedItem?: MarketplaceItemCreateNestedOneWithoutCommunityItemInput
    likedBy?: CosmeticItemLikeCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemUncheckedCreateWithoutReviewerInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    approvedItemId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: CosmeticItemLikeUncheckedCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemCreateOrConnectWithoutReviewerInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    create: XOR<CommunityCosmeticItemCreateWithoutReviewerInput, CommunityCosmeticItemUncheckedCreateWithoutReviewerInput>
  }

  export type CommunityCosmeticItemCreateManyReviewerInputEnvelope = {
    data: CommunityCosmeticItemCreateManyReviewerInput | CommunityCosmeticItemCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type CosmeticItemLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    cosmeticItem: CommunityCosmeticItemCreateNestedOneWithoutLikedByInput
  }

  export type CosmeticItemLikeUncheckedCreateWithoutUserInput = {
    id?: string
    cosmeticItemId: string
    createdAt?: Date | string
  }

  export type CosmeticItemLikeCreateOrConnectWithoutUserInput = {
    where: CosmeticItemLikeWhereUniqueInput
    create: XOR<CosmeticItemLikeCreateWithoutUserInput, CosmeticItemLikeUncheckedCreateWithoutUserInput>
  }

  export type CosmeticItemLikeCreateManyUserInputEnvelope = {
    data: CosmeticItemLikeCreateManyUserInput | CosmeticItemLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    skillRating?: IntFieldUpdateOperationsInput | number
    clanTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    skillRating?: IntFieldUpdateOperationsInput | number
    clanTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    privacySettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    privacySettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpsertWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateManyWithWhereWithoutUserInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutUserInput>
  }

  export type WalletScalarWhereInput = {
    AND?: WalletScalarWhereInput | WalletScalarWhereInput[]
    OR?: WalletScalarWhereInput[]
    NOT?: WalletScalarWhereInput | WalletScalarWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    chain?: StringFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
  }

  export type UserNFTUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNFTWhereUniqueInput
    update: XOR<UserNFTUpdateWithoutUserInput, UserNFTUncheckedUpdateWithoutUserInput>
    create: XOR<UserNFTCreateWithoutUserInput, UserNFTUncheckedCreateWithoutUserInput>
  }

  export type UserNFTUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNFTWhereUniqueInput
    data: XOR<UserNFTUpdateWithoutUserInput, UserNFTUncheckedUpdateWithoutUserInput>
  }

  export type UserNFTUpdateManyWithWhereWithoutUserInput = {
    where: UserNFTScalarWhereInput
    data: XOR<UserNFTUpdateManyMutationInput, UserNFTUncheckedUpdateManyWithoutUserInput>
  }

  export type UserNFTScalarWhereInput = {
    AND?: UserNFTScalarWhereInput | UserNFTScalarWhereInput[]
    OR?: UserNFTScalarWhereInput[]
    NOT?: UserNFTScalarWhereInput | UserNFTScalarWhereInput[]
    id?: StringFilter<"UserNFT"> | string
    userId?: StringFilter<"UserNFT"> | string
    nftId?: StringFilter<"UserNFT"> | string
    createdAt?: DateTimeFilter<"UserNFT"> | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
  }

  export type ClanMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ClanMemberWhereUniqueInput
    update: XOR<ClanMemberUpdateWithoutUserInput, ClanMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ClanMemberCreateWithoutUserInput, ClanMemberUncheckedCreateWithoutUserInput>
  }

  export type ClanMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ClanMemberWhereUniqueInput
    data: XOR<ClanMemberUpdateWithoutUserInput, ClanMemberUncheckedUpdateWithoutUserInput>
  }

  export type ClanMemberUpdateManyWithWhereWithoutUserInput = {
    where: ClanMemberScalarWhereInput
    data: XOR<ClanMemberUpdateManyMutationInput, ClanMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ClanMemberScalarWhereInput = {
    AND?: ClanMemberScalarWhereInput | ClanMemberScalarWhereInput[]
    OR?: ClanMemberScalarWhereInput[]
    NOT?: ClanMemberScalarWhereInput | ClanMemberScalarWhereInput[]
    id?: StringFilter<"ClanMember"> | string
    clanId?: StringFilter<"ClanMember"> | string
    userId?: StringFilter<"ClanMember"> | string
    role?: EnumClanRoleFilter<"ClanMember"> | $Enums.ClanRole
    joinedAt?: DateTimeFilter<"ClanMember"> | Date | string
  }

  export type TerritoryUpsertWithWhereUniqueWithoutOwnerInput = {
    where: TerritoryWhereUniqueInput
    update: XOR<TerritoryUpdateWithoutOwnerInput, TerritoryUncheckedUpdateWithoutOwnerInput>
    create: XOR<TerritoryCreateWithoutOwnerInput, TerritoryUncheckedCreateWithoutOwnerInput>
  }

  export type TerritoryUpdateWithWhereUniqueWithoutOwnerInput = {
    where: TerritoryWhereUniqueInput
    data: XOR<TerritoryUpdateWithoutOwnerInput, TerritoryUncheckedUpdateWithoutOwnerInput>
  }

  export type TerritoryUpdateManyWithWhereWithoutOwnerInput = {
    where: TerritoryScalarWhereInput
    data: XOR<TerritoryUpdateManyMutationInput, TerritoryUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TerritoryScalarWhereInput = {
    AND?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
    OR?: TerritoryScalarWhereInput[]
    NOT?: TerritoryScalarWhereInput | TerritoryScalarWhereInput[]
    id?: StringFilter<"Territory"> | string
    venueId?: StringFilter<"Territory"> | string
    name?: StringFilter<"Territory"> | string
    ownerId?: StringNullableFilter<"Territory"> | string | null
    clanId?: StringNullableFilter<"Territory"> | string | null
    level?: IntFilter<"Territory"> | number
    defenseScore?: IntFilter<"Territory"> | number
    resources?: StringFilter<"Territory"> | string
    strategicValue?: IntFilter<"Territory"> | number
    resourceRate?: StringFilter<"Territory"> | string
    lastTickAt?: DateTimeNullableFilter<"Territory"> | Date | string | null
    createdAt?: DateTimeFilter<"Territory"> | Date | string
    updatedAt?: DateTimeFilter<"Territory"> | Date | string
  }

  export type CheckInUpsertWithWhereUniqueWithoutUserInput = {
    where: CheckInWhereUniqueInput
    update: XOR<CheckInUpdateWithoutUserInput, CheckInUncheckedUpdateWithoutUserInput>
    create: XOR<CheckInCreateWithoutUserInput, CheckInUncheckedCreateWithoutUserInput>
  }

  export type CheckInUpdateWithWhereUniqueWithoutUserInput = {
    where: CheckInWhereUniqueInput
    data: XOR<CheckInUpdateWithoutUserInput, CheckInUncheckedUpdateWithoutUserInput>
  }

  export type CheckInUpdateManyWithWhereWithoutUserInput = {
    where: CheckInScalarWhereInput
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyWithoutUserInput>
  }

  export type CheckInScalarWhereInput = {
    AND?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
    OR?: CheckInScalarWhereInput[]
    NOT?: CheckInScalarWhereInput | CheckInScalarWhereInput[]
    id?: StringFilter<"CheckIn"> | string
    userId?: StringFilter<"CheckIn"> | string
    venueId?: StringFilter<"CheckIn"> | string
    via?: EnumCheckInMethodFilter<"CheckIn"> | $Enums.CheckInMethod
    createdAt?: DateTimeFilter<"CheckIn"> | Date | string
  }

  export type ChallengeUpsertWithWhereUniqueWithoutChallengerInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutChallengerInput, ChallengeUncheckedUpdateWithoutChallengerInput>
    create: XOR<ChallengeCreateWithoutChallengerInput, ChallengeUncheckedCreateWithoutChallengerInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutChallengerInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutChallengerInput, ChallengeUncheckedUpdateWithoutChallengerInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutChallengerInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutChallengerInput>
  }

  export type ChallengeScalarWhereInput = {
    AND?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    OR?: ChallengeScalarWhereInput[]
    NOT?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    id?: StringFilter<"Challenge"> | string
    challengerId?: StringFilter<"Challenge"> | string
    defenderId?: StringFilter<"Challenge"> | string
    venueId?: StringNullableFilter<"Challenge"> | string | null
    status?: EnumChallengeStatusFilter<"Challenge"> | $Enums.ChallengeStatus
    stakeCoins?: IntFilter<"Challenge"> | number
    expiresAt?: DateTimeNullableFilter<"Challenge"> | Date | string | null
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
  }

  export type ChallengeUpsertWithWhereUniqueWithoutDefenderInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutDefenderInput, ChallengeUncheckedUpdateWithoutDefenderInput>
    create: XOR<ChallengeCreateWithoutDefenderInput, ChallengeUncheckedCreateWithoutDefenderInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutDefenderInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutDefenderInput, ChallengeUncheckedUpdateWithoutDefenderInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutDefenderInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutDefenderInput>
  }

  export type ClanUpsertWithWhereUniqueWithoutLeaderInput = {
    where: ClanWhereUniqueInput
    update: XOR<ClanUpdateWithoutLeaderInput, ClanUncheckedUpdateWithoutLeaderInput>
    create: XOR<ClanCreateWithoutLeaderInput, ClanUncheckedCreateWithoutLeaderInput>
  }

  export type ClanUpdateWithWhereUniqueWithoutLeaderInput = {
    where: ClanWhereUniqueInput
    data: XOR<ClanUpdateWithoutLeaderInput, ClanUncheckedUpdateWithoutLeaderInput>
  }

  export type ClanUpdateManyWithWhereWithoutLeaderInput = {
    where: ClanScalarWhereInput
    data: XOR<ClanUpdateManyMutationInput, ClanUncheckedUpdateManyWithoutLeaderInput>
  }

  export type ClanScalarWhereInput = {
    AND?: ClanScalarWhereInput | ClanScalarWhereInput[]
    OR?: ClanScalarWhereInput[]
    NOT?: ClanScalarWhereInput | ClanScalarWhereInput[]
    id?: StringFilter<"Clan"> | string
    name?: StringFilter<"Clan"> | string
    description?: StringNullableFilter<"Clan"> | string | null
    tag?: StringFilter<"Clan"> | string
    leaderId?: StringFilter<"Clan"> | string
    maxMembers?: IntFilter<"Clan"> | number
    dojoCoinBalance?: IntFilter<"Clan"> | number
    seasonalPoints?: IntFilter<"Clan"> | number
    bannerUrl?: StringNullableFilter<"Clan"> | string | null
    color?: StringFilter<"Clan"> | string
    level?: IntFilter<"Clan"> | number
    experience?: IntFilter<"Clan"> | number
    reputation?: IntFilter<"Clan"> | number
    isActive?: BoolFilter<"Clan"> | boolean
    createdAt?: DateTimeFilter<"Clan"> | Date | string
    updatedAt?: DateTimeFilter<"Clan"> | Date | string
  }

  export type MatchUpsertWithWhereUniqueWithoutPlayerAInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutPlayerAInput, MatchUncheckedUpdateWithoutPlayerAInput>
    create: XOR<MatchCreateWithoutPlayerAInput, MatchUncheckedCreateWithoutPlayerAInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutPlayerAInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutPlayerAInput, MatchUncheckedUpdateWithoutPlayerAInput>
  }

  export type MatchUpdateManyWithWhereWithoutPlayerAInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutPlayerAInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: StringFilter<"Match"> | string
    tournamentId?: StringNullableFilter<"Match"> | string | null
    venueId?: StringNullableFilter<"Match"> | string | null
    tableId?: StringNullableFilter<"Match"> | string | null
    playerAId?: StringFilter<"Match"> | string
    playerBId?: StringFilter<"Match"> | string
    winnerId?: StringNullableFilter<"Match"> | string | null
    loserId?: StringNullableFilter<"Match"> | string | null
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    scoreA?: IntFilter<"Match"> | number
    scoreB?: IntFilter<"Match"> | number
    round?: IntNullableFilter<"Match"> | number | null
    wager?: IntFilter<"Match"> | number
    aiAnalysisJson?: StringNullableFilter<"Match"> | string | null
    startedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type MatchUpsertWithWhereUniqueWithoutPlayerBInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutPlayerBInput, MatchUncheckedUpdateWithoutPlayerBInput>
    create: XOR<MatchCreateWithoutPlayerBInput, MatchUncheckedCreateWithoutPlayerBInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutPlayerBInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutPlayerBInput, MatchUncheckedUpdateWithoutPlayerBInput>
  }

  export type MatchUpdateManyWithWhereWithoutPlayerBInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutPlayerBInput>
  }

  export type TournamentParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: TournamentParticipantWhereUniqueInput
    update: XOR<TournamentParticipantUpdateWithoutUserInput, TournamentParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<TournamentParticipantCreateWithoutUserInput, TournamentParticipantUncheckedCreateWithoutUserInput>
  }

  export type TournamentParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: TournamentParticipantWhereUniqueInput
    data: XOR<TournamentParticipantUpdateWithoutUserInput, TournamentParticipantUncheckedUpdateWithoutUserInput>
  }

  export type TournamentParticipantUpdateManyWithWhereWithoutUserInput = {
    where: TournamentParticipantScalarWhereInput
    data: XOR<TournamentParticipantUpdateManyMutationInput, TournamentParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type TournamentParticipantScalarWhereInput = {
    AND?: TournamentParticipantScalarWhereInput | TournamentParticipantScalarWhereInput[]
    OR?: TournamentParticipantScalarWhereInput[]
    NOT?: TournamentParticipantScalarWhereInput | TournamentParticipantScalarWhereInput[]
    id?: StringFilter<"TournamentParticipant"> | string
    tournamentId?: StringFilter<"TournamentParticipant"> | string
    userId?: StringFilter<"TournamentParticipant"> | string
    seed?: IntNullableFilter<"TournamentParticipant"> | number | null
    finalRank?: IntNullableFilter<"TournamentParticipant"> | number | null
    createdAt?: DateTimeFilter<"TournamentParticipant"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    type?: EnumTxTypeFilter<"Transaction"> | $Enums.TxType
    metadata?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    payload?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    isRead?: BoolFilter<"Notification"> | boolean
    recipientId?: StringNullableFilter<"Notification"> | string | null
    title?: StringNullableFilter<"Notification"> | string | null
    priority?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    target?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: StringFilter<"AuditLog"> | string
    ts?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type VenueUpsertWithWhereUniqueWithoutOwnerInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutOwnerInput, VenueUncheckedUpdateWithoutOwnerInput>
    create: XOR<VenueCreateWithoutOwnerInput, VenueUncheckedCreateWithoutOwnerInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutOwnerInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutOwnerInput, VenueUncheckedUpdateWithoutOwnerInput>
  }

  export type VenueUpdateManyWithWhereWithoutOwnerInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutOwnerInput>
  }

  export type VenueScalarWhereInput = {
    AND?: VenueScalarWhereInput | VenueScalarWhereInput[]
    OR?: VenueScalarWhereInput[]
    NOT?: VenueScalarWhereInput | VenueScalarWhereInput[]
    id?: StringFilter<"Venue"> | string
    name?: StringFilter<"Venue"> | string
    description?: StringNullableFilter<"Venue"> | string | null
    lat?: FloatFilter<"Venue"> | number
    lng?: FloatFilter<"Venue"> | number
    address?: StringNullableFilter<"Venue"> | string | null
    ownerId?: StringNullableFilter<"Venue"> | string | null
    controllingClanId?: StringNullableFilter<"Venue"> | string | null
    incomeModifier?: FloatFilter<"Venue"> | number
    defenseLevel?: IntFilter<"Venue"> | number
    status?: StringFilter<"Venue"> | string
    photos?: StringFilter<"Venue"> | string
    rating?: FloatFilter<"Venue"> | number
    features?: StringFilter<"Venue"> | string
    tables?: IntFilter<"Venue"> | number
    reviews?: StringFilter<"Venue"> | string
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutRequesterInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutRequesterInput, FriendshipUncheckedUpdateWithoutRequesterInput>
    create: XOR<FriendshipCreateWithoutRequesterInput, FriendshipUncheckedCreateWithoutRequesterInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutRequesterInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutRequesterInput, FriendshipUncheckedUpdateWithoutRequesterInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutRequesterInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutRequesterInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: StringFilter<"Friendship"> | string
    requesterId?: StringFilter<"Friendship"> | string
    addresseeId?: StringFilter<"Friendship"> | string
    status?: EnumFriendshipStatusFilter<"Friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    updatedAt?: DateTimeFilter<"Friendship"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutAddresseeInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutAddresseeInput, FriendshipUncheckedUpdateWithoutAddresseeInput>
    create: XOR<FriendshipCreateWithoutAddresseeInput, FriendshipUncheckedCreateWithoutAddresseeInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutAddresseeInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutAddresseeInput, FriendshipUncheckedUpdateWithoutAddresseeInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutAddresseeInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutAddresseeInput>
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutSenderInput, DirectMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<DirectMessageCreateWithoutSenderInput, DirectMessageUncheckedCreateWithoutSenderInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutSenderInput, DirectMessageUncheckedUpdateWithoutSenderInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutSenderInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type DirectMessageScalarWhereInput = {
    AND?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
    OR?: DirectMessageScalarWhereInput[]
    NOT?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
    id?: StringFilter<"DirectMessage"> | string
    senderId?: StringFilter<"DirectMessage"> | string
    receiverId?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    read?: BoolFilter<"DirectMessage"> | boolean
    timestamp?: DateTimeFilter<"DirectMessage"> | Date | string
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutReceiverInput, DirectMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<DirectMessageCreateWithoutReceiverInput, DirectMessageUncheckedCreateWithoutReceiverInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutReceiverInput, DirectMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ActivityEventUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityEventWhereUniqueInput
    update: XOR<ActivityEventUpdateWithoutUserInput, ActivityEventUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityEventCreateWithoutUserInput, ActivityEventUncheckedCreateWithoutUserInput>
  }

  export type ActivityEventUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityEventWhereUniqueInput
    data: XOR<ActivityEventUpdateWithoutUserInput, ActivityEventUncheckedUpdateWithoutUserInput>
  }

  export type ActivityEventUpdateManyWithWhereWithoutUserInput = {
    where: ActivityEventScalarWhereInput
    data: XOR<ActivityEventUpdateManyMutationInput, ActivityEventUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityEventScalarWhereInput = {
    AND?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
    OR?: ActivityEventScalarWhereInput[]
    NOT?: ActivityEventScalarWhereInput | ActivityEventScalarWhereInput[]
    id?: StringFilter<"ActivityEvent"> | string
    userId?: StringFilter<"ActivityEvent"> | string
    type?: StringFilter<"ActivityEvent"> | string
    message?: StringNullableFilter<"ActivityEvent"> | string | null
    data?: StringFilter<"ActivityEvent"> | string
    venueId?: StringNullableFilter<"ActivityEvent"> | string | null
    matchId?: StringNullableFilter<"ActivityEvent"> | string | null
    tournamentId?: StringNullableFilter<"ActivityEvent"> | string | null
    clanId?: StringNullableFilter<"ActivityEvent"> | string | null
    metadata?: StringNullableFilter<"ActivityEvent"> | string | null
    isPublic?: BoolFilter<"ActivityEvent"> | boolean
    createdAt?: DateTimeFilter<"ActivityEvent"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityEvent"> | Date | string
  }

  export type GameSessionUpsertWithWhereUniqueWithoutPlayerInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutPlayerInput, GameSessionUncheckedUpdateWithoutPlayerInput>
    create: XOR<GameSessionCreateWithoutPlayerInput, GameSessionUncheckedCreateWithoutPlayerInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutPlayerInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutPlayerInput, GameSessionUncheckedUpdateWithoutPlayerInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutPlayerInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutPlayerInput>
  }

  export type GameSessionScalarWhereInput = {
    AND?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    OR?: GameSessionScalarWhereInput[]
    NOT?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    id?: StringFilter<"GameSession"> | string
    playerId?: StringFilter<"GameSession"> | string
    gameId?: StringNullableFilter<"GameSession"> | string | null
    venueId?: StringNullableFilter<"GameSession"> | string | null
    status?: StringFilter<"GameSession"> | string
    gameType?: StringNullableFilter<"GameSession"> | string | null
    rules?: StringFilter<"GameSession"> | string
    startTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    endTime?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    duration?: IntNullableFilter<"GameSession"> | number | null
    playerIds?: StringFilter<"GameSession"> | string
    currentPlayerId?: StringNullableFilter<"GameSession"> | string | null
    ballStates?: StringFilter<"GameSession"> | string
    fouls?: StringFilter<"GameSession"> | string
    score?: StringFilter<"GameSession"> | string
    events?: StringFilter<"GameSession"> | string
    totalShots?: IntFilter<"GameSession"> | number
    totalFouls?: IntFilter<"GameSession"> | number
    totalFrames?: IntFilter<"GameSession"> | number
    lastUpdated?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    winnerId?: StringNullableFilter<"GameSession"> | string | null
    data?: JsonFilter<"GameSession">
    frameCount?: IntFilter<"GameSession"> | number
    shotCount?: IntFilter<"GameSession"> | number
    foulCount?: IntFilter<"GameSession"> | number
    shots?: StringFilter<"GameSession"> | string
    statistics?: StringFilter<"GameSession"> | string
    aiCommentary?: StringFilter<"GameSession"> | string
    matchId?: StringNullableFilter<"GameSession"> | string | null
    createdAt?: DateTimeFilter<"GameSession"> | Date | string
    updatedAt?: DateTimeFilter<"GameSession"> | Date | string
  }

  export type ShadowRunUpsertWithWhereUniqueWithoutPlayerInput = {
    where: ShadowRunWhereUniqueInput
    update: XOR<ShadowRunUpdateWithoutPlayerInput, ShadowRunUncheckedUpdateWithoutPlayerInput>
    create: XOR<ShadowRunCreateWithoutPlayerInput, ShadowRunUncheckedCreateWithoutPlayerInput>
  }

  export type ShadowRunUpdateWithWhereUniqueWithoutPlayerInput = {
    where: ShadowRunWhereUniqueInput
    data: XOR<ShadowRunUpdateWithoutPlayerInput, ShadowRunUncheckedUpdateWithoutPlayerInput>
  }

  export type ShadowRunUpdateManyWithWhereWithoutPlayerInput = {
    where: ShadowRunScalarWhereInput
    data: XOR<ShadowRunUpdateManyMutationInput, ShadowRunUncheckedUpdateManyWithoutPlayerInput>
  }

  export type ShadowRunScalarWhereInput = {
    AND?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
    OR?: ShadowRunScalarWhereInput[]
    NOT?: ShadowRunScalarWhereInput | ShadowRunScalarWhereInput[]
    id?: StringFilter<"ShadowRun"> | string
    playerId?: StringFilter<"ShadowRun"> | string
    type?: StringFilter<"ShadowRun"> | string
    status?: StringFilter<"ShadowRun"> | string
    cost?: IntFilter<"ShadowRun"> | number
    reward?: IntNullableFilter<"ShadowRun"> | number | null
    completedAt?: DateTimeNullableFilter<"ShadowRun"> | Date | string | null
    initiatingClanId?: StringNullableFilter<"ShadowRun"> | string | null
    targetVenueId?: StringNullableFilter<"ShadowRun"> | string | null
    outcome?: StringNullableFilter<"ShadowRun"> | string | null
    createdAt?: DateTimeFilter<"ShadowRun"> | Date | string
    updatedAt?: DateTimeFilter<"ShadowRun"> | Date | string
  }

  export type DojoCheckInUpsertWithWhereUniqueWithoutUserInput = {
    where: DojoCheckInWhereUniqueInput
    update: XOR<DojoCheckInUpdateWithoutUserInput, DojoCheckInUncheckedUpdateWithoutUserInput>
    create: XOR<DojoCheckInCreateWithoutUserInput, DojoCheckInUncheckedCreateWithoutUserInput>
  }

  export type DojoCheckInUpdateWithWhereUniqueWithoutUserInput = {
    where: DojoCheckInWhereUniqueInput
    data: XOR<DojoCheckInUpdateWithoutUserInput, DojoCheckInUncheckedUpdateWithoutUserInput>
  }

  export type DojoCheckInUpdateManyWithWhereWithoutUserInput = {
    where: DojoCheckInScalarWhereInput
    data: XOR<DojoCheckInUpdateManyMutationInput, DojoCheckInUncheckedUpdateManyWithoutUserInput>
  }

  export type DojoCheckInScalarWhereInput = {
    AND?: DojoCheckInScalarWhereInput | DojoCheckInScalarWhereInput[]
    OR?: DojoCheckInScalarWhereInput[]
    NOT?: DojoCheckInScalarWhereInput | DojoCheckInScalarWhereInput[]
    id?: StringFilter<"DojoCheckIn"> | string
    userId?: StringFilter<"DojoCheckIn"> | string
    venueId?: StringFilter<"DojoCheckIn"> | string
    createdAt?: DateTimeFilter<"DojoCheckIn"> | Date | string
  }

  export type UserInventoryItemUpsertWithWhereUniqueWithoutUserInput = {
    where: UserInventoryItemWhereUniqueInput
    update: XOR<UserInventoryItemUpdateWithoutUserInput, UserInventoryItemUncheckedUpdateWithoutUserInput>
    create: XOR<UserInventoryItemCreateWithoutUserInput, UserInventoryItemUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryItemUpdateWithWhereUniqueWithoutUserInput = {
    where: UserInventoryItemWhereUniqueInput
    data: XOR<UserInventoryItemUpdateWithoutUserInput, UserInventoryItemUncheckedUpdateWithoutUserInput>
  }

  export type UserInventoryItemUpdateManyWithWhereWithoutUserInput = {
    where: UserInventoryItemScalarWhereInput
    data: XOR<UserInventoryItemUpdateManyMutationInput, UserInventoryItemUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInventoryItemScalarWhereInput = {
    AND?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
    OR?: UserInventoryItemScalarWhereInput[]
    NOT?: UserInventoryItemScalarWhereInput | UserInventoryItemScalarWhereInput[]
    id?: StringFilter<"UserInventoryItem"> | string
    userId?: StringFilter<"UserInventoryItem"> | string
    marketplaceItemId?: StringFilter<"UserInventoryItem"> | string
    createdAt?: DateTimeFilter<"UserInventoryItem"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter<"Feedback"> | string
    userId?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
    category?: EnumFeedbackCategoryFilter<"Feedback"> | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFilter<"Feedback"> | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFilter<"Feedback"> | $Enums.FeedbackPriority
    adminNotes?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Feedback"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Feedback"> | string | null
  }

  export type FeedbackUpsertWithWhereUniqueWithoutResolverInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutResolverInput, FeedbackUncheckedUpdateWithoutResolverInput>
    create: XOR<FeedbackCreateWithoutResolverInput, FeedbackUncheckedCreateWithoutResolverInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutResolverInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutResolverInput, FeedbackUncheckedUpdateWithoutResolverInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutResolverInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutResolverInput>
  }

  export type ContentUpsertWithWhereUniqueWithoutUserInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutUserInput, ContentUncheckedUpdateWithoutUserInput>
    create: XOR<ContentCreateWithoutUserInput, ContentUncheckedCreateWithoutUserInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutUserInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutUserInput, ContentUncheckedUpdateWithoutUserInput>
  }

  export type ContentUpdateManyWithWhereWithoutUserInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutUserInput>
  }

  export type ContentScalarWhereInput = {
    AND?: ContentScalarWhereInput | ContentScalarWhereInput[]
    OR?: ContentScalarWhereInput[]
    NOT?: ContentScalarWhereInput | ContentScalarWhereInput[]
    id?: StringFilter<"Content"> | string
    contentId?: StringFilter<"Content"> | string
    userId?: StringFilter<"Content"> | string
    title?: StringFilter<"Content"> | string
    description?: StringNullableFilter<"Content"> | string | null
    contentType?: EnumContentTypeFilter<"Content"> | $Enums.ContentType
    fileUrl?: StringNullableFilter<"Content"> | string | null
    thumbnailUrl?: StringNullableFilter<"Content"> | string | null
    status?: EnumContentStatusFilter<"Content"> | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFilter<"Content"> | $Enums.ContentVisibility
    metadata?: StringFilter<"Content"> | string
    tags?: StringFilter<"Content"> | string
    likes?: IntFilter<"Content"> | number
    shares?: IntFilter<"Content"> | number
    views?: IntFilter<"Content"> | number
    moderatedBy?: StringNullableFilter<"Content"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Content"> | Date | string | null
    moderationNotes?: StringNullableFilter<"Content"> | string | null
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
  }

  export type ContentUpsertWithWhereUniqueWithoutModeratorInput = {
    where: ContentWhereUniqueInput
    update: XOR<ContentUpdateWithoutModeratorInput, ContentUncheckedUpdateWithoutModeratorInput>
    create: XOR<ContentCreateWithoutModeratorInput, ContentUncheckedCreateWithoutModeratorInput>
  }

  export type ContentUpdateWithWhereUniqueWithoutModeratorInput = {
    where: ContentWhereUniqueInput
    data: XOR<ContentUpdateWithoutModeratorInput, ContentUncheckedUpdateWithoutModeratorInput>
  }

  export type ContentUpdateManyWithWhereWithoutModeratorInput = {
    where: ContentScalarWhereInput
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyWithoutModeratorInput>
  }

  export type ContentLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: ContentLikeWhereUniqueInput
    update: XOR<ContentLikeUpdateWithoutUserInput, ContentLikeUncheckedUpdateWithoutUserInput>
    create: XOR<ContentLikeCreateWithoutUserInput, ContentLikeUncheckedCreateWithoutUserInput>
  }

  export type ContentLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: ContentLikeWhereUniqueInput
    data: XOR<ContentLikeUpdateWithoutUserInput, ContentLikeUncheckedUpdateWithoutUserInput>
  }

  export type ContentLikeUpdateManyWithWhereWithoutUserInput = {
    where: ContentLikeScalarWhereInput
    data: XOR<ContentLikeUpdateManyMutationInput, ContentLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type ContentLikeScalarWhereInput = {
    AND?: ContentLikeScalarWhereInput | ContentLikeScalarWhereInput[]
    OR?: ContentLikeScalarWhereInput[]
    NOT?: ContentLikeScalarWhereInput | ContentLikeScalarWhereInput[]
    id?: StringFilter<"ContentLike"> | string
    contentId?: StringFilter<"ContentLike"> | string
    userId?: StringFilter<"ContentLike"> | string
    likes?: IntFilter<"ContentLike"> | number
    createdAt?: DateTimeFilter<"ContentLike"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    deviceId?: StringNullableFilter<"RefreshToken"> | string | null
    deviceInfo?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type ContentShareUpsertWithWhereUniqueWithoutUserInput = {
    where: ContentShareWhereUniqueInput
    update: XOR<ContentShareUpdateWithoutUserInput, ContentShareUncheckedUpdateWithoutUserInput>
    create: XOR<ContentShareCreateWithoutUserInput, ContentShareUncheckedCreateWithoutUserInput>
  }

  export type ContentShareUpdateWithWhereUniqueWithoutUserInput = {
    where: ContentShareWhereUniqueInput
    data: XOR<ContentShareUpdateWithoutUserInput, ContentShareUncheckedUpdateWithoutUserInput>
  }

  export type ContentShareUpdateManyWithWhereWithoutUserInput = {
    where: ContentShareScalarWhereInput
    data: XOR<ContentShareUpdateManyMutationInput, ContentShareUncheckedUpdateManyWithoutUserInput>
  }

  export type ContentShareScalarWhereInput = {
    AND?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
    OR?: ContentShareScalarWhereInput[]
    NOT?: ContentShareScalarWhereInput | ContentShareScalarWhereInput[]
    id?: StringFilter<"ContentShare"> | string
    contentId?: StringFilter<"ContentShare"> | string
    userId?: StringFilter<"ContentShare"> | string
    sharedWithId?: StringFilter<"ContentShare"> | string
    createdAt?: DateTimeFilter<"ContentShare"> | Date | string
  }

  export type ContentShareUpsertWithWhereUniqueWithoutSharedWithInput = {
    where: ContentShareWhereUniqueInput
    update: XOR<ContentShareUpdateWithoutSharedWithInput, ContentShareUncheckedUpdateWithoutSharedWithInput>
    create: XOR<ContentShareCreateWithoutSharedWithInput, ContentShareUncheckedCreateWithoutSharedWithInput>
  }

  export type ContentShareUpdateWithWhereUniqueWithoutSharedWithInput = {
    where: ContentShareWhereUniqueInput
    data: XOR<ContentShareUpdateWithoutSharedWithInput, ContentShareUncheckedUpdateWithoutSharedWithInput>
  }

  export type ContentShareUpdateManyWithWhereWithoutSharedWithInput = {
    where: ContentShareScalarWhereInput
    data: XOR<ContentShareUpdateManyMutationInput, ContentShareUncheckedUpdateManyWithoutSharedWithInput>
  }

  export type CommunityCosmeticItemUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    update: XOR<CommunityCosmeticItemUpdateWithoutCreatorInput, CommunityCosmeticItemUncheckedUpdateWithoutCreatorInput>
    create: XOR<CommunityCosmeticItemCreateWithoutCreatorInput, CommunityCosmeticItemUncheckedCreateWithoutCreatorInput>
  }

  export type CommunityCosmeticItemUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    data: XOR<CommunityCosmeticItemUpdateWithoutCreatorInput, CommunityCosmeticItemUncheckedUpdateWithoutCreatorInput>
  }

  export type CommunityCosmeticItemUpdateManyWithWhereWithoutCreatorInput = {
    where: CommunityCosmeticItemScalarWhereInput
    data: XOR<CommunityCosmeticItemUpdateManyMutationInput, CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CommunityCosmeticItemScalarWhereInput = {
    AND?: CommunityCosmeticItemScalarWhereInput | CommunityCosmeticItemScalarWhereInput[]
    OR?: CommunityCosmeticItemScalarWhereInput[]
    NOT?: CommunityCosmeticItemScalarWhereInput | CommunityCosmeticItemScalarWhereInput[]
    id?: StringFilter<"CommunityCosmeticItem"> | string
    creatorId?: StringFilter<"CommunityCosmeticItem"> | string
    title?: StringFilter<"CommunityCosmeticItem"> | string
    description?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    category?: EnumCosmeticCategoryFilter<"CommunityCosmeticItem"> | $Enums.CosmeticCategory
    designFileUrl?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    previewImageUrl?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    status?: EnumSubmissionStatusFilter<"CommunityCosmeticItem"> | $Enums.SubmissionStatus
    rejectionReason?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    approvedItemId?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    reviewerId?: StringNullableFilter<"CommunityCosmeticItem"> | string | null
    reviewedAt?: DateTimeNullableFilter<"CommunityCosmeticItem"> | Date | string | null
    metadata?: StringFilter<"CommunityCosmeticItem"> | string
    tags?: StringFilter<"CommunityCosmeticItem"> | string
    likes?: IntFilter<"CommunityCosmeticItem"> | number
    views?: IntFilter<"CommunityCosmeticItem"> | number
    createdAt?: DateTimeFilter<"CommunityCosmeticItem"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityCosmeticItem"> | Date | string
  }

  export type CommunityCosmeticItemUpsertWithWhereUniqueWithoutReviewerInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    update: XOR<CommunityCosmeticItemUpdateWithoutReviewerInput, CommunityCosmeticItemUncheckedUpdateWithoutReviewerInput>
    create: XOR<CommunityCosmeticItemCreateWithoutReviewerInput, CommunityCosmeticItemUncheckedCreateWithoutReviewerInput>
  }

  export type CommunityCosmeticItemUpdateWithWhereUniqueWithoutReviewerInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    data: XOR<CommunityCosmeticItemUpdateWithoutReviewerInput, CommunityCosmeticItemUncheckedUpdateWithoutReviewerInput>
  }

  export type CommunityCosmeticItemUpdateManyWithWhereWithoutReviewerInput = {
    where: CommunityCosmeticItemScalarWhereInput
    data: XOR<CommunityCosmeticItemUpdateManyMutationInput, CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerInput>
  }

  export type CosmeticItemLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: CosmeticItemLikeWhereUniqueInput
    update: XOR<CosmeticItemLikeUpdateWithoutUserInput, CosmeticItemLikeUncheckedUpdateWithoutUserInput>
    create: XOR<CosmeticItemLikeCreateWithoutUserInput, CosmeticItemLikeUncheckedCreateWithoutUserInput>
  }

  export type CosmeticItemLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: CosmeticItemLikeWhereUniqueInput
    data: XOR<CosmeticItemLikeUpdateWithoutUserInput, CosmeticItemLikeUncheckedUpdateWithoutUserInput>
  }

  export type CosmeticItemLikeUpdateManyWithWhereWithoutUserInput = {
    where: CosmeticItemLikeScalarWhereInput
    data: XOR<CosmeticItemLikeUpdateManyMutationInput, CosmeticItemLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type CosmeticItemLikeScalarWhereInput = {
    AND?: CosmeticItemLikeScalarWhereInput | CosmeticItemLikeScalarWhereInput[]
    OR?: CosmeticItemLikeScalarWhereInput[]
    NOT?: CosmeticItemLikeScalarWhereInput | CosmeticItemLikeScalarWhereInput[]
    id?: StringFilter<"CosmeticItemLike"> | string
    userId?: StringFilter<"CosmeticItemLike"> | string
    cosmeticItemId?: StringFilter<"CosmeticItemLike"> | string
    createdAt?: DateTimeFilter<"CosmeticItemLike"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVenuesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVenuesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVenuesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVenuesInput, UserUncheckedCreateWithoutVenuesInput>
  }

  export type ClanCreateWithoutControlledVenuesInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutLedClansInput
    members?: ClanMemberCreateNestedManyWithoutClanInput
    territories?: TerritoryCreateNestedManyWithoutClanInput
    activityEvents?: ActivityEventCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanUncheckedCreateWithoutControlledVenuesInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    leaderId: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClanMemberUncheckedCreateNestedManyWithoutClanInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutClanInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanCreateOrConnectWithoutControlledVenuesInput = {
    where: ClanWhereUniqueInput
    create: XOR<ClanCreateWithoutControlledVenuesInput, ClanUncheckedCreateWithoutControlledVenuesInput>
  }

  export type TableCreateWithoutVenueInput = {
    id?: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutVenueInput = {
    id?: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutVenueInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutVenueInput, TableUncheckedCreateWithoutVenueInput>
  }

  export type TableCreateManyVenueInputEnvelope = {
    data: TableCreateManyVenueInput | TableCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type TournamentCreateWithoutVenueInput = {
    id?: string
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TournamentParticipantCreateNestedManyWithoutTournamentInput
    matches?: MatchCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutVenueInput = {
    id?: string
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TournamentParticipantUncheckedCreateNestedManyWithoutTournamentInput
    matches?: MatchUncheckedCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutVenueInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutVenueInput, TournamentUncheckedCreateWithoutVenueInput>
  }

  export type TournamentCreateManyVenueInputEnvelope = {
    data: TournamentCreateManyVenueInput | TournamentCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type TerritoryCreateWithoutVenueInput = {
    id?: string
    name?: string
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutTerritoriesInput
    clan?: ClanCreateNestedOneWithoutTerritoriesInput
    events?: TerritoryEventCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryUncheckedCreateWithoutVenueInput = {
    id?: string
    name?: string
    ownerId?: string | null
    clanId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TerritoryEventUncheckedCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryCreateOrConnectWithoutVenueInput = {
    where: TerritoryWhereUniqueInput
    create: XOR<TerritoryCreateWithoutVenueInput, TerritoryUncheckedCreateWithoutVenueInput>
  }

  export type TerritoryCreateManyVenueInputEnvelope = {
    data: TerritoryCreateManyVenueInput | TerritoryCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type CheckInCreateWithoutVenueInput = {
    id?: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCheckInsInput
  }

  export type CheckInUncheckedCreateWithoutVenueInput = {
    id?: string
    userId: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
  }

  export type CheckInCreateOrConnectWithoutVenueInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutVenueInput, CheckInUncheckedCreateWithoutVenueInput>
  }

  export type CheckInCreateManyVenueInputEnvelope = {
    data: CheckInCreateManyVenueInput | CheckInCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeCreateWithoutVenueInput = {
    id?: string
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    challenger: UserCreateNestedOneWithoutChallengesAsChallengerInput
    defender: UserCreateNestedOneWithoutChallengesAsDefenderInput
  }

  export type ChallengeUncheckedCreateWithoutVenueInput = {
    id?: string
    challengerId: string
    defenderId: string
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeCreateOrConnectWithoutVenueInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutVenueInput, ChallengeUncheckedCreateWithoutVenueInput>
  }

  export type ChallengeCreateManyVenueInputEnvelope = {
    data: ChallengeCreateManyVenueInput | ChallengeCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutVenueInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament?: TournamentCreateNestedOneWithoutMatchesInput
    table?: TableCreateNestedOneWithoutMatchesInput
    playerA: UserCreateNestedOneWithoutMatchesAsPlayerAInput
    playerB: UserCreateNestedOneWithoutMatchesAsPlayerBInput
    events?: MatchEventCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutVenueInput = {
    id?: string
    tournamentId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: MatchEventUncheckedCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutVenueInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutVenueInput, MatchUncheckedCreateWithoutVenueInput>
  }

  export type MatchCreateManyVenueInputEnvelope = {
    data: MatchCreateManyVenueInput | MatchCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ActivityEventCreateWithoutVenueInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityEventsInput
    match?: MatchCreateNestedOneWithoutActivityEventsInput
    tournament?: TournamentCreateNestedOneWithoutActivityEventsInput
    clan?: ClanCreateNestedOneWithoutActivityEventsInput
  }

  export type ActivityEventUncheckedCreateWithoutVenueInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    matchId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateOrConnectWithoutVenueInput = {
    where: ActivityEventWhereUniqueInput
    create: XOR<ActivityEventCreateWithoutVenueInput, ActivityEventUncheckedCreateWithoutVenueInput>
  }

  export type ActivityEventCreateManyVenueInputEnvelope = {
    data: ActivityEventCreateManyVenueInput | ActivityEventCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type VenueQuestCreateWithoutVenueInput = {
    id?: string
    title: string
    description: string
    reward?: string
    rewardDojoCoins?: number
    active?: boolean
    isActive?: boolean
    requirements?: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueQuestUncheckedCreateWithoutVenueInput = {
    id?: string
    title: string
    description: string
    reward?: string
    rewardDojoCoins?: number
    active?: boolean
    isActive?: boolean
    requirements?: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueQuestCreateOrConnectWithoutVenueInput = {
    where: VenueQuestWhereUniqueInput
    create: XOR<VenueQuestCreateWithoutVenueInput, VenueQuestUncheckedCreateWithoutVenueInput>
  }

  export type VenueQuestCreateManyVenueInputEnvelope = {
    data: VenueQuestCreateManyVenueInput | VenueQuestCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type VenueSpecialCreateWithoutVenueInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isActive?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueSpecialUncheckedCreateWithoutVenueInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isActive?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueSpecialCreateOrConnectWithoutVenueInput = {
    where: VenueSpecialWhereUniqueInput
    create: XOR<VenueSpecialCreateWithoutVenueInput, VenueSpecialUncheckedCreateWithoutVenueInput>
  }

  export type VenueSpecialCreateManyVenueInputEnvelope = {
    data: VenueSpecialCreateManyVenueInput | VenueSpecialCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type DojoCheckInCreateWithoutVenueInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDojoCheckInsInput
  }

  export type DojoCheckInUncheckedCreateWithoutVenueInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type DojoCheckInCreateOrConnectWithoutVenueInput = {
    where: DojoCheckInWhereUniqueInput
    create: XOR<DojoCheckInCreateWithoutVenueInput, DojoCheckInUncheckedCreateWithoutVenueInput>
  }

  export type DojoCheckInCreateManyVenueInputEnvelope = {
    data: DojoCheckInCreateManyVenueInput | DojoCheckInCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ShadowRunCreateWithoutTargetVenueInput = {
    id?: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutShadowRunsInput
    initiatingClan?: ClanCreateNestedOneWithoutShadowRunsInput
  }

  export type ShadowRunUncheckedCreateWithoutTargetVenueInput = {
    id?: string
    playerId: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    initiatingClanId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShadowRunCreateOrConnectWithoutTargetVenueInput = {
    where: ShadowRunWhereUniqueInput
    create: XOR<ShadowRunCreateWithoutTargetVenueInput, ShadowRunUncheckedCreateWithoutTargetVenueInput>
  }

  export type ShadowRunCreateManyTargetVenueInputEnvelope = {
    data: ShadowRunCreateManyTargetVenueInput | ShadowRunCreateManyTargetVenueInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionCreateWithoutVenueInput = {
    id?: string
    gameId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutGameSessionsInput
  }

  export type GameSessionUncheckedCreateWithoutVenueInput = {
    id?: string
    playerId: string
    gameId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameSessionCreateOrConnectWithoutVenueInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutVenueInput, GameSessionUncheckedCreateWithoutVenueInput>
  }

  export type GameSessionCreateManyVenueInputEnvelope = {
    data: GameSessionCreateManyVenueInput | GameSessionCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVenuesInput = {
    update: XOR<UserUpdateWithoutVenuesInput, UserUncheckedUpdateWithoutVenuesInput>
    create: XOR<UserCreateWithoutVenuesInput, UserUncheckedCreateWithoutVenuesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVenuesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVenuesInput, UserUncheckedUpdateWithoutVenuesInput>
  }

  export type UserUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClanUpsertWithoutControlledVenuesInput = {
    update: XOR<ClanUpdateWithoutControlledVenuesInput, ClanUncheckedUpdateWithoutControlledVenuesInput>
    create: XOR<ClanCreateWithoutControlledVenuesInput, ClanUncheckedCreateWithoutControlledVenuesInput>
    where?: ClanWhereInput
  }

  export type ClanUpdateToOneWithWhereWithoutControlledVenuesInput = {
    where?: ClanWhereInput
    data: XOR<ClanUpdateWithoutControlledVenuesInput, ClanUncheckedUpdateWithoutControlledVenuesInput>
  }

  export type ClanUpdateWithoutControlledVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutLedClansNestedInput
    members?: ClanMemberUpdateManyWithoutClanNestedInput
    territories?: TerritoryUpdateManyWithoutClanNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanUncheckedUpdateWithoutControlledVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    leaderId?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClanMemberUncheckedUpdateManyWithoutClanNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutClanNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutInitiatingClanNestedInput
  }

  export type TableUpsertWithWhereUniqueWithoutVenueInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutVenueInput, TableUncheckedUpdateWithoutVenueInput>
    create: XOR<TableCreateWithoutVenueInput, TableUncheckedCreateWithoutVenueInput>
  }

  export type TableUpdateWithWhereUniqueWithoutVenueInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutVenueInput, TableUncheckedUpdateWithoutVenueInput>
  }

  export type TableUpdateManyWithWhereWithoutVenueInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutVenueInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    id?: StringFilter<"Table"> | string
    venueId?: StringFilter<"Table"> | string
    name?: StringFilter<"Table"> | string
    status?: EnumTableStatusFilter<"Table"> | $Enums.TableStatus
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
  }

  export type TournamentUpsertWithWhereUniqueWithoutVenueInput = {
    where: TournamentWhereUniqueInput
    update: XOR<TournamentUpdateWithoutVenueInput, TournamentUncheckedUpdateWithoutVenueInput>
    create: XOR<TournamentCreateWithoutVenueInput, TournamentUncheckedCreateWithoutVenueInput>
  }

  export type TournamentUpdateWithWhereUniqueWithoutVenueInput = {
    where: TournamentWhereUniqueInput
    data: XOR<TournamentUpdateWithoutVenueInput, TournamentUncheckedUpdateWithoutVenueInput>
  }

  export type TournamentUpdateManyWithWhereWithoutVenueInput = {
    where: TournamentScalarWhereInput
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyWithoutVenueInput>
  }

  export type TournamentScalarWhereInput = {
    AND?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
    OR?: TournamentScalarWhereInput[]
    NOT?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
    id?: StringFilter<"Tournament"> | string
    venueId?: StringNullableFilter<"Tournament"> | string | null
    name?: StringFilter<"Tournament"> | string
    status?: EnumTournamentStatusFilter<"Tournament"> | $Enums.TournamentStatus
    startTime?: DateTimeFilter<"Tournament"> | Date | string
    endTime?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    isSponsored?: BoolFilter<"Tournament"> | boolean
    sponsoredBy?: StringNullableFilter<"Tournament"> | string | null
    startDate?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Tournament"> | Date | string | null
    sponsorBannerUrl?: StringNullableFilter<"Tournament"> | string | null
    maxPlayers?: IntFilter<"Tournament"> | number
    entryFee?: IntFilter<"Tournament"> | number
    rewards?: StringNullableFilter<"Tournament"> | string | null
    prizePool?: IntFilter<"Tournament"> | number
    format?: StringFilter<"Tournament"> | string
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeFilter<"Tournament"> | Date | string
  }

  export type TerritoryUpsertWithWhereUniqueWithoutVenueInput = {
    where: TerritoryWhereUniqueInput
    update: XOR<TerritoryUpdateWithoutVenueInput, TerritoryUncheckedUpdateWithoutVenueInput>
    create: XOR<TerritoryCreateWithoutVenueInput, TerritoryUncheckedCreateWithoutVenueInput>
  }

  export type TerritoryUpdateWithWhereUniqueWithoutVenueInput = {
    where: TerritoryWhereUniqueInput
    data: XOR<TerritoryUpdateWithoutVenueInput, TerritoryUncheckedUpdateWithoutVenueInput>
  }

  export type TerritoryUpdateManyWithWhereWithoutVenueInput = {
    where: TerritoryScalarWhereInput
    data: XOR<TerritoryUpdateManyMutationInput, TerritoryUncheckedUpdateManyWithoutVenueInput>
  }

  export type CheckInUpsertWithWhereUniqueWithoutVenueInput = {
    where: CheckInWhereUniqueInput
    update: XOR<CheckInUpdateWithoutVenueInput, CheckInUncheckedUpdateWithoutVenueInput>
    create: XOR<CheckInCreateWithoutVenueInput, CheckInUncheckedCreateWithoutVenueInput>
  }

  export type CheckInUpdateWithWhereUniqueWithoutVenueInput = {
    where: CheckInWhereUniqueInput
    data: XOR<CheckInUpdateWithoutVenueInput, CheckInUncheckedUpdateWithoutVenueInput>
  }

  export type CheckInUpdateManyWithWhereWithoutVenueInput = {
    where: CheckInScalarWhereInput
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyWithoutVenueInput>
  }

  export type ChallengeUpsertWithWhereUniqueWithoutVenueInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutVenueInput, ChallengeUncheckedUpdateWithoutVenueInput>
    create: XOR<ChallengeCreateWithoutVenueInput, ChallengeUncheckedCreateWithoutVenueInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutVenueInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutVenueInput, ChallengeUncheckedUpdateWithoutVenueInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutVenueInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutVenueInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutVenueInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutVenueInput, MatchUncheckedUpdateWithoutVenueInput>
    create: XOR<MatchCreateWithoutVenueInput, MatchUncheckedCreateWithoutVenueInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutVenueInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutVenueInput, MatchUncheckedUpdateWithoutVenueInput>
  }

  export type MatchUpdateManyWithWhereWithoutVenueInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutVenueInput>
  }

  export type ActivityEventUpsertWithWhereUniqueWithoutVenueInput = {
    where: ActivityEventWhereUniqueInput
    update: XOR<ActivityEventUpdateWithoutVenueInput, ActivityEventUncheckedUpdateWithoutVenueInput>
    create: XOR<ActivityEventCreateWithoutVenueInput, ActivityEventUncheckedCreateWithoutVenueInput>
  }

  export type ActivityEventUpdateWithWhereUniqueWithoutVenueInput = {
    where: ActivityEventWhereUniqueInput
    data: XOR<ActivityEventUpdateWithoutVenueInput, ActivityEventUncheckedUpdateWithoutVenueInput>
  }

  export type ActivityEventUpdateManyWithWhereWithoutVenueInput = {
    where: ActivityEventScalarWhereInput
    data: XOR<ActivityEventUpdateManyMutationInput, ActivityEventUncheckedUpdateManyWithoutVenueInput>
  }

  export type VenueQuestUpsertWithWhereUniqueWithoutVenueInput = {
    where: VenueQuestWhereUniqueInput
    update: XOR<VenueQuestUpdateWithoutVenueInput, VenueQuestUncheckedUpdateWithoutVenueInput>
    create: XOR<VenueQuestCreateWithoutVenueInput, VenueQuestUncheckedCreateWithoutVenueInput>
  }

  export type VenueQuestUpdateWithWhereUniqueWithoutVenueInput = {
    where: VenueQuestWhereUniqueInput
    data: XOR<VenueQuestUpdateWithoutVenueInput, VenueQuestUncheckedUpdateWithoutVenueInput>
  }

  export type VenueQuestUpdateManyWithWhereWithoutVenueInput = {
    where: VenueQuestScalarWhereInput
    data: XOR<VenueQuestUpdateManyMutationInput, VenueQuestUncheckedUpdateManyWithoutVenueInput>
  }

  export type VenueQuestScalarWhereInput = {
    AND?: VenueQuestScalarWhereInput | VenueQuestScalarWhereInput[]
    OR?: VenueQuestScalarWhereInput[]
    NOT?: VenueQuestScalarWhereInput | VenueQuestScalarWhereInput[]
    id?: StringFilter<"VenueQuest"> | string
    venueId?: StringFilter<"VenueQuest"> | string
    title?: StringFilter<"VenueQuest"> | string
    description?: StringFilter<"VenueQuest"> | string
    reward?: StringFilter<"VenueQuest"> | string
    rewardDojoCoins?: IntFilter<"VenueQuest"> | number
    active?: BoolFilter<"VenueQuest"> | boolean
    isActive?: BoolFilter<"VenueQuest"> | boolean
    requirements?: StringFilter<"VenueQuest"> | string
    type?: StringFilter<"VenueQuest"> | string
    createdAt?: DateTimeFilter<"VenueQuest"> | Date | string
    updatedAt?: DateTimeFilter<"VenueQuest"> | Date | string
  }

  export type VenueSpecialUpsertWithWhereUniqueWithoutVenueInput = {
    where: VenueSpecialWhereUniqueInput
    update: XOR<VenueSpecialUpdateWithoutVenueInput, VenueSpecialUncheckedUpdateWithoutVenueInput>
    create: XOR<VenueSpecialCreateWithoutVenueInput, VenueSpecialUncheckedCreateWithoutVenueInput>
  }

  export type VenueSpecialUpdateWithWhereUniqueWithoutVenueInput = {
    where: VenueSpecialWhereUniqueInput
    data: XOR<VenueSpecialUpdateWithoutVenueInput, VenueSpecialUncheckedUpdateWithoutVenueInput>
  }

  export type VenueSpecialUpdateManyWithWhereWithoutVenueInput = {
    where: VenueSpecialScalarWhereInput
    data: XOR<VenueSpecialUpdateManyMutationInput, VenueSpecialUncheckedUpdateManyWithoutVenueInput>
  }

  export type VenueSpecialScalarWhereInput = {
    AND?: VenueSpecialScalarWhereInput | VenueSpecialScalarWhereInput[]
    OR?: VenueSpecialScalarWhereInput[]
    NOT?: VenueSpecialScalarWhereInput | VenueSpecialScalarWhereInput[]
    id?: StringFilter<"VenueSpecial"> | string
    venueId?: StringFilter<"VenueSpecial"> | string
    title?: StringFilter<"VenueSpecial"> | string
    description?: StringNullableFilter<"VenueSpecial"> | string | null
    type?: StringFilter<"VenueSpecial"> | string
    isActive?: BoolFilter<"VenueSpecial"> | boolean
    validUntil?: DateTimeNullableFilter<"VenueSpecial"> | Date | string | null
    createdAt?: DateTimeFilter<"VenueSpecial"> | Date | string
    updatedAt?: DateTimeFilter<"VenueSpecial"> | Date | string
  }

  export type DojoCheckInUpsertWithWhereUniqueWithoutVenueInput = {
    where: DojoCheckInWhereUniqueInput
    update: XOR<DojoCheckInUpdateWithoutVenueInput, DojoCheckInUncheckedUpdateWithoutVenueInput>
    create: XOR<DojoCheckInCreateWithoutVenueInput, DojoCheckInUncheckedCreateWithoutVenueInput>
  }

  export type DojoCheckInUpdateWithWhereUniqueWithoutVenueInput = {
    where: DojoCheckInWhereUniqueInput
    data: XOR<DojoCheckInUpdateWithoutVenueInput, DojoCheckInUncheckedUpdateWithoutVenueInput>
  }

  export type DojoCheckInUpdateManyWithWhereWithoutVenueInput = {
    where: DojoCheckInScalarWhereInput
    data: XOR<DojoCheckInUpdateManyMutationInput, DojoCheckInUncheckedUpdateManyWithoutVenueInput>
  }

  export type ShadowRunUpsertWithWhereUniqueWithoutTargetVenueInput = {
    where: ShadowRunWhereUniqueInput
    update: XOR<ShadowRunUpdateWithoutTargetVenueInput, ShadowRunUncheckedUpdateWithoutTargetVenueInput>
    create: XOR<ShadowRunCreateWithoutTargetVenueInput, ShadowRunUncheckedCreateWithoutTargetVenueInput>
  }

  export type ShadowRunUpdateWithWhereUniqueWithoutTargetVenueInput = {
    where: ShadowRunWhereUniqueInput
    data: XOR<ShadowRunUpdateWithoutTargetVenueInput, ShadowRunUncheckedUpdateWithoutTargetVenueInput>
  }

  export type ShadowRunUpdateManyWithWhereWithoutTargetVenueInput = {
    where: ShadowRunScalarWhereInput
    data: XOR<ShadowRunUpdateManyMutationInput, ShadowRunUncheckedUpdateManyWithoutTargetVenueInput>
  }

  export type GameSessionUpsertWithWhereUniqueWithoutVenueInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutVenueInput, GameSessionUncheckedUpdateWithoutVenueInput>
    create: XOR<GameSessionCreateWithoutVenueInput, GameSessionUncheckedCreateWithoutVenueInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutVenueInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutVenueInput, GameSessionUncheckedUpdateWithoutVenueInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutVenueInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutVenueInput>
  }

  export type VenueCreateWithoutTablesListInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutTablesListInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutTablesListInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutTablesListInput, VenueUncheckedCreateWithoutTablesListInput>
  }

  export type MatchCreateWithoutTableInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament?: TournamentCreateNestedOneWithoutMatchesInput
    venue?: VenueCreateNestedOneWithoutMatchesInput
    playerA: UserCreateNestedOneWithoutMatchesAsPlayerAInput
    playerB: UserCreateNestedOneWithoutMatchesAsPlayerBInput
    events?: MatchEventCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutTableInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: MatchEventUncheckedCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutTableInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutTableInput, MatchUncheckedCreateWithoutTableInput>
  }

  export type MatchCreateManyTableInputEnvelope = {
    data: MatchCreateManyTableInput | MatchCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithoutTablesListInput = {
    update: XOR<VenueUpdateWithoutTablesListInput, VenueUncheckedUpdateWithoutTablesListInput>
    create: XOR<VenueCreateWithoutTablesListInput, VenueUncheckedCreateWithoutTablesListInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutTablesListInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutTablesListInput, VenueUncheckedUpdateWithoutTablesListInput>
  }

  export type VenueUpdateWithoutTablesListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutTablesListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type MatchUpsertWithWhereUniqueWithoutTableInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutTableInput, MatchUncheckedUpdateWithoutTableInput>
    create: XOR<MatchCreateWithoutTableInput, MatchUncheckedCreateWithoutTableInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutTableInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutTableInput, MatchUncheckedUpdateWithoutTableInput>
  }

  export type MatchUpdateManyWithWhereWithoutTableInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutTableInput>
  }

  export type UserCreateWithoutCheckInsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCheckInsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCheckInsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
  }

  export type VenueCreateWithoutCheckInsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutCheckInsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutCheckInsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutCheckInsInput, VenueUncheckedCreateWithoutCheckInsInput>
  }

  export type UserUpsertWithoutCheckInsInput = {
    update: XOR<UserUpdateWithoutCheckInsInput, UserUncheckedUpdateWithoutCheckInsInput>
    create: XOR<UserCreateWithoutCheckInsInput, UserUncheckedCreateWithoutCheckInsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCheckInsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCheckInsInput, UserUncheckedUpdateWithoutCheckInsInput>
  }

  export type UserUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenueUpsertWithoutCheckInsInput = {
    update: XOR<VenueUpdateWithoutCheckInsInput, VenueUncheckedUpdateWithoutCheckInsInput>
    create: XOR<VenueCreateWithoutCheckInsInput, VenueUncheckedCreateWithoutCheckInsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutCheckInsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutCheckInsInput, VenueUncheckedUpdateWithoutCheckInsInput>
  }

  export type VenueUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserCreateWithoutLedClansInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLedClansInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLedClansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLedClansInput, UserUncheckedCreateWithoutLedClansInput>
  }

  export type ClanMemberCreateWithoutClanInput = {
    id?: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type ClanMemberUncheckedCreateWithoutClanInput = {
    id?: string
    userId: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
  }

  export type ClanMemberCreateOrConnectWithoutClanInput = {
    where: ClanMemberWhereUniqueInput
    create: XOR<ClanMemberCreateWithoutClanInput, ClanMemberUncheckedCreateWithoutClanInput>
  }

  export type ClanMemberCreateManyClanInputEnvelope = {
    data: ClanMemberCreateManyClanInput | ClanMemberCreateManyClanInput[]
    skipDuplicates?: boolean
  }

  export type TerritoryCreateWithoutClanInput = {
    id?: string
    name?: string
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutTerritoriesInput
    owner?: UserCreateNestedOneWithoutTerritoriesInput
    events?: TerritoryEventCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryUncheckedCreateWithoutClanInput = {
    id?: string
    venueId: string
    name?: string
    ownerId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TerritoryEventUncheckedCreateNestedManyWithoutTerritoryInput
  }

  export type TerritoryCreateOrConnectWithoutClanInput = {
    where: TerritoryWhereUniqueInput
    create: XOR<TerritoryCreateWithoutClanInput, TerritoryUncheckedCreateWithoutClanInput>
  }

  export type TerritoryCreateManyClanInputEnvelope = {
    data: TerritoryCreateManyClanInput | TerritoryCreateManyClanInput[]
    skipDuplicates?: boolean
  }

  export type VenueCreateWithoutControllingClanInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutControllingClanInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutControllingClanInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutControllingClanInput, VenueUncheckedCreateWithoutControllingClanInput>
  }

  export type VenueCreateManyControllingClanInputEnvelope = {
    data: VenueCreateManyControllingClanInput | VenueCreateManyControllingClanInput[]
    skipDuplicates?: boolean
  }

  export type ActivityEventCreateWithoutClanInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityEventsInput
    venue?: VenueCreateNestedOneWithoutActivityEventsInput
    match?: MatchCreateNestedOneWithoutActivityEventsInput
    tournament?: TournamentCreateNestedOneWithoutActivityEventsInput
  }

  export type ActivityEventUncheckedCreateWithoutClanInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    tournamentId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateOrConnectWithoutClanInput = {
    where: ActivityEventWhereUniqueInput
    create: XOR<ActivityEventCreateWithoutClanInput, ActivityEventUncheckedCreateWithoutClanInput>
  }

  export type ActivityEventCreateManyClanInputEnvelope = {
    data: ActivityEventCreateManyClanInput | ActivityEventCreateManyClanInput[]
    skipDuplicates?: boolean
  }

  export type ShadowRunCreateWithoutInitiatingClanInput = {
    id?: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutShadowRunsInput
    targetVenue?: VenueCreateNestedOneWithoutShadowRunsInput
  }

  export type ShadowRunUncheckedCreateWithoutInitiatingClanInput = {
    id?: string
    playerId: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    targetVenueId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShadowRunCreateOrConnectWithoutInitiatingClanInput = {
    where: ShadowRunWhereUniqueInput
    create: XOR<ShadowRunCreateWithoutInitiatingClanInput, ShadowRunUncheckedCreateWithoutInitiatingClanInput>
  }

  export type ShadowRunCreateManyInitiatingClanInputEnvelope = {
    data: ShadowRunCreateManyInitiatingClanInput | ShadowRunCreateManyInitiatingClanInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLedClansInput = {
    update: XOR<UserUpdateWithoutLedClansInput, UserUncheckedUpdateWithoutLedClansInput>
    create: XOR<UserCreateWithoutLedClansInput, UserUncheckedCreateWithoutLedClansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLedClansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLedClansInput, UserUncheckedUpdateWithoutLedClansInput>
  }

  export type UserUpdateWithoutLedClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLedClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClanMemberUpsertWithWhereUniqueWithoutClanInput = {
    where: ClanMemberWhereUniqueInput
    update: XOR<ClanMemberUpdateWithoutClanInput, ClanMemberUncheckedUpdateWithoutClanInput>
    create: XOR<ClanMemberCreateWithoutClanInput, ClanMemberUncheckedCreateWithoutClanInput>
  }

  export type ClanMemberUpdateWithWhereUniqueWithoutClanInput = {
    where: ClanMemberWhereUniqueInput
    data: XOR<ClanMemberUpdateWithoutClanInput, ClanMemberUncheckedUpdateWithoutClanInput>
  }

  export type ClanMemberUpdateManyWithWhereWithoutClanInput = {
    where: ClanMemberScalarWhereInput
    data: XOR<ClanMemberUpdateManyMutationInput, ClanMemberUncheckedUpdateManyWithoutClanInput>
  }

  export type TerritoryUpsertWithWhereUniqueWithoutClanInput = {
    where: TerritoryWhereUniqueInput
    update: XOR<TerritoryUpdateWithoutClanInput, TerritoryUncheckedUpdateWithoutClanInput>
    create: XOR<TerritoryCreateWithoutClanInput, TerritoryUncheckedCreateWithoutClanInput>
  }

  export type TerritoryUpdateWithWhereUniqueWithoutClanInput = {
    where: TerritoryWhereUniqueInput
    data: XOR<TerritoryUpdateWithoutClanInput, TerritoryUncheckedUpdateWithoutClanInput>
  }

  export type TerritoryUpdateManyWithWhereWithoutClanInput = {
    where: TerritoryScalarWhereInput
    data: XOR<TerritoryUpdateManyMutationInput, TerritoryUncheckedUpdateManyWithoutClanInput>
  }

  export type VenueUpsertWithWhereUniqueWithoutControllingClanInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutControllingClanInput, VenueUncheckedUpdateWithoutControllingClanInput>
    create: XOR<VenueCreateWithoutControllingClanInput, VenueUncheckedCreateWithoutControllingClanInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutControllingClanInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutControllingClanInput, VenueUncheckedUpdateWithoutControllingClanInput>
  }

  export type VenueUpdateManyWithWhereWithoutControllingClanInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutControllingClanInput>
  }

  export type ActivityEventUpsertWithWhereUniqueWithoutClanInput = {
    where: ActivityEventWhereUniqueInput
    update: XOR<ActivityEventUpdateWithoutClanInput, ActivityEventUncheckedUpdateWithoutClanInput>
    create: XOR<ActivityEventCreateWithoutClanInput, ActivityEventUncheckedCreateWithoutClanInput>
  }

  export type ActivityEventUpdateWithWhereUniqueWithoutClanInput = {
    where: ActivityEventWhereUniqueInput
    data: XOR<ActivityEventUpdateWithoutClanInput, ActivityEventUncheckedUpdateWithoutClanInput>
  }

  export type ActivityEventUpdateManyWithWhereWithoutClanInput = {
    where: ActivityEventScalarWhereInput
    data: XOR<ActivityEventUpdateManyMutationInput, ActivityEventUncheckedUpdateManyWithoutClanInput>
  }

  export type ShadowRunUpsertWithWhereUniqueWithoutInitiatingClanInput = {
    where: ShadowRunWhereUniqueInput
    update: XOR<ShadowRunUpdateWithoutInitiatingClanInput, ShadowRunUncheckedUpdateWithoutInitiatingClanInput>
    create: XOR<ShadowRunCreateWithoutInitiatingClanInput, ShadowRunUncheckedCreateWithoutInitiatingClanInput>
  }

  export type ShadowRunUpdateWithWhereUniqueWithoutInitiatingClanInput = {
    where: ShadowRunWhereUniqueInput
    data: XOR<ShadowRunUpdateWithoutInitiatingClanInput, ShadowRunUncheckedUpdateWithoutInitiatingClanInput>
  }

  export type ShadowRunUpdateManyWithWhereWithoutInitiatingClanInput = {
    where: ShadowRunScalarWhereInput
    data: XOR<ShadowRunUpdateManyMutationInput, ShadowRunUncheckedUpdateManyWithoutInitiatingClanInput>
  }

  export type ClanCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutLedClansInput
    territories?: TerritoryCreateNestedManyWithoutClanInput
    controlledVenues?: VenueCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    leaderId: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    territories?: TerritoryUncheckedCreateNestedManyWithoutClanInput
    controlledVenues?: VenueUncheckedCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanCreateOrConnectWithoutMembersInput = {
    where: ClanWhereUniqueInput
    create: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type ClanUpsertWithoutMembersInput = {
    update: XOR<ClanUpdateWithoutMembersInput, ClanUncheckedUpdateWithoutMembersInput>
    create: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
    where?: ClanWhereInput
  }

  export type ClanUpdateToOneWithWhereWithoutMembersInput = {
    where?: ClanWhereInput
    data: XOR<ClanUpdateWithoutMembersInput, ClanUncheckedUpdateWithoutMembersInput>
  }

  export type ClanUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutLedClansNestedInput
    territories?: TerritoryUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    leaderId?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    territories?: TerritoryUncheckedUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUncheckedUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutInitiatingClanNestedInput
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenueCreateWithoutTerritoriesInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutTerritoriesInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutTerritoriesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutTerritoriesInput, VenueUncheckedCreateWithoutTerritoriesInput>
  }

  export type UserCreateWithoutTerritoriesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTerritoriesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTerritoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTerritoriesInput, UserUncheckedCreateWithoutTerritoriesInput>
  }

  export type ClanCreateWithoutTerritoriesInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutLedClansInput
    members?: ClanMemberCreateNestedManyWithoutClanInput
    controlledVenues?: VenueCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanUncheckedCreateWithoutTerritoriesInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    leaderId: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClanMemberUncheckedCreateNestedManyWithoutClanInput
    controlledVenues?: VenueUncheckedCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutClanInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanCreateOrConnectWithoutTerritoriesInput = {
    where: ClanWhereUniqueInput
    create: XOR<ClanCreateWithoutTerritoriesInput, ClanUncheckedCreateWithoutTerritoriesInput>
  }

  export type TerritoryEventCreateWithoutTerritoryInput = {
    id?: string
    type: $Enums.TerritoryEventType
    metadata: string
    createdAt?: Date | string
  }

  export type TerritoryEventUncheckedCreateWithoutTerritoryInput = {
    id?: string
    type: $Enums.TerritoryEventType
    metadata: string
    createdAt?: Date | string
  }

  export type TerritoryEventCreateOrConnectWithoutTerritoryInput = {
    where: TerritoryEventWhereUniqueInput
    create: XOR<TerritoryEventCreateWithoutTerritoryInput, TerritoryEventUncheckedCreateWithoutTerritoryInput>
  }

  export type TerritoryEventCreateManyTerritoryInputEnvelope = {
    data: TerritoryEventCreateManyTerritoryInput | TerritoryEventCreateManyTerritoryInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithoutTerritoriesInput = {
    update: XOR<VenueUpdateWithoutTerritoriesInput, VenueUncheckedUpdateWithoutTerritoriesInput>
    create: XOR<VenueCreateWithoutTerritoriesInput, VenueUncheckedCreateWithoutTerritoriesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutTerritoriesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutTerritoriesInput, VenueUncheckedUpdateWithoutTerritoriesInput>
  }

  export type VenueUpdateWithoutTerritoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutTerritoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserUpsertWithoutTerritoriesInput = {
    update: XOR<UserUpdateWithoutTerritoriesInput, UserUncheckedUpdateWithoutTerritoriesInput>
    create: XOR<UserCreateWithoutTerritoriesInput, UserUncheckedCreateWithoutTerritoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTerritoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTerritoriesInput, UserUncheckedUpdateWithoutTerritoriesInput>
  }

  export type UserUpdateWithoutTerritoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTerritoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClanUpsertWithoutTerritoriesInput = {
    update: XOR<ClanUpdateWithoutTerritoriesInput, ClanUncheckedUpdateWithoutTerritoriesInput>
    create: XOR<ClanCreateWithoutTerritoriesInput, ClanUncheckedCreateWithoutTerritoriesInput>
    where?: ClanWhereInput
  }

  export type ClanUpdateToOneWithWhereWithoutTerritoriesInput = {
    where?: ClanWhereInput
    data: XOR<ClanUpdateWithoutTerritoriesInput, ClanUncheckedUpdateWithoutTerritoriesInput>
  }

  export type ClanUpdateWithoutTerritoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutLedClansNestedInput
    members?: ClanMemberUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanUncheckedUpdateWithoutTerritoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    leaderId?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClanMemberUncheckedUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUncheckedUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutInitiatingClanNestedInput
  }

  export type TerritoryEventUpsertWithWhereUniqueWithoutTerritoryInput = {
    where: TerritoryEventWhereUniqueInput
    update: XOR<TerritoryEventUpdateWithoutTerritoryInput, TerritoryEventUncheckedUpdateWithoutTerritoryInput>
    create: XOR<TerritoryEventCreateWithoutTerritoryInput, TerritoryEventUncheckedCreateWithoutTerritoryInput>
  }

  export type TerritoryEventUpdateWithWhereUniqueWithoutTerritoryInput = {
    where: TerritoryEventWhereUniqueInput
    data: XOR<TerritoryEventUpdateWithoutTerritoryInput, TerritoryEventUncheckedUpdateWithoutTerritoryInput>
  }

  export type TerritoryEventUpdateManyWithWhereWithoutTerritoryInput = {
    where: TerritoryEventScalarWhereInput
    data: XOR<TerritoryEventUpdateManyMutationInput, TerritoryEventUncheckedUpdateManyWithoutTerritoryInput>
  }

  export type TerritoryEventScalarWhereInput = {
    AND?: TerritoryEventScalarWhereInput | TerritoryEventScalarWhereInput[]
    OR?: TerritoryEventScalarWhereInput[]
    NOT?: TerritoryEventScalarWhereInput | TerritoryEventScalarWhereInput[]
    id?: StringFilter<"TerritoryEvent"> | string
    territoryId?: StringFilter<"TerritoryEvent"> | string
    type?: EnumTerritoryEventTypeFilter<"TerritoryEvent"> | $Enums.TerritoryEventType
    metadata?: StringFilter<"TerritoryEvent"> | string
    createdAt?: DateTimeFilter<"TerritoryEvent"> | Date | string
  }

  export type TerritoryCreateWithoutEventsInput = {
    id?: string
    name?: string
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutTerritoriesInput
    owner?: UserCreateNestedOneWithoutTerritoriesInput
    clan?: ClanCreateNestedOneWithoutTerritoriesInput
  }

  export type TerritoryUncheckedCreateWithoutEventsInput = {
    id?: string
    venueId: string
    name?: string
    ownerId?: string | null
    clanId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerritoryCreateOrConnectWithoutEventsInput = {
    where: TerritoryWhereUniqueInput
    create: XOR<TerritoryCreateWithoutEventsInput, TerritoryUncheckedCreateWithoutEventsInput>
  }

  export type TerritoryUpsertWithoutEventsInput = {
    update: XOR<TerritoryUpdateWithoutEventsInput, TerritoryUncheckedUpdateWithoutEventsInput>
    create: XOR<TerritoryCreateWithoutEventsInput, TerritoryUncheckedCreateWithoutEventsInput>
    where?: TerritoryWhereInput
  }

  export type TerritoryUpdateToOneWithWhereWithoutEventsInput = {
    where?: TerritoryWhereInput
    data: XOR<TerritoryUpdateWithoutEventsInput, TerritoryUncheckedUpdateWithoutEventsInput>
  }

  export type TerritoryUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutTerritoriesNestedInput
    owner?: UserUpdateOneWithoutTerritoriesNestedInput
    clan?: ClanUpdateOneWithoutTerritoriesNestedInput
  }

  export type TerritoryUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueCreateWithoutTournamentsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutTournamentsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutTournamentsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutTournamentsInput, VenueUncheckedCreateWithoutTournamentsInput>
  }

  export type TournamentParticipantCreateWithoutTournamentInput = {
    id?: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTournamentsInput
  }

  export type TournamentParticipantUncheckedCreateWithoutTournamentInput = {
    id?: string
    userId: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
  }

  export type TournamentParticipantCreateOrConnectWithoutTournamentInput = {
    where: TournamentParticipantWhereUniqueInput
    create: XOR<TournamentParticipantCreateWithoutTournamentInput, TournamentParticipantUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentParticipantCreateManyTournamentInputEnvelope = {
    data: TournamentParticipantCreateManyTournamentInput | TournamentParticipantCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutTournamentInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutMatchesInput
    table?: TableCreateNestedOneWithoutMatchesInput
    playerA: UserCreateNestedOneWithoutMatchesAsPlayerAInput
    playerB: UserCreateNestedOneWithoutMatchesAsPlayerBInput
    events?: MatchEventCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutTournamentInput = {
    id?: string
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: MatchEventUncheckedCreateNestedManyWithoutMatchInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutTournamentInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutTournamentInput, MatchUncheckedCreateWithoutTournamentInput>
  }

  export type MatchCreateManyTournamentInputEnvelope = {
    data: MatchCreateManyTournamentInput | MatchCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type ActivityEventCreateWithoutTournamentInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityEventsInput
    venue?: VenueCreateNestedOneWithoutActivityEventsInput
    match?: MatchCreateNestedOneWithoutActivityEventsInput
    clan?: ClanCreateNestedOneWithoutActivityEventsInput
  }

  export type ActivityEventUncheckedCreateWithoutTournamentInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateOrConnectWithoutTournamentInput = {
    where: ActivityEventWhereUniqueInput
    create: XOR<ActivityEventCreateWithoutTournamentInput, ActivityEventUncheckedCreateWithoutTournamentInput>
  }

  export type ActivityEventCreateManyTournamentInputEnvelope = {
    data: ActivityEventCreateManyTournamentInput | ActivityEventCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithoutTournamentsInput = {
    update: XOR<VenueUpdateWithoutTournamentsInput, VenueUncheckedUpdateWithoutTournamentsInput>
    create: XOR<VenueCreateWithoutTournamentsInput, VenueUncheckedCreateWithoutTournamentsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutTournamentsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutTournamentsInput, VenueUncheckedUpdateWithoutTournamentsInput>
  }

  export type VenueUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type TournamentParticipantUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentParticipantWhereUniqueInput
    update: XOR<TournamentParticipantUpdateWithoutTournamentInput, TournamentParticipantUncheckedUpdateWithoutTournamentInput>
    create: XOR<TournamentParticipantCreateWithoutTournamentInput, TournamentParticipantUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentParticipantUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentParticipantWhereUniqueInput
    data: XOR<TournamentParticipantUpdateWithoutTournamentInput, TournamentParticipantUncheckedUpdateWithoutTournamentInput>
  }

  export type TournamentParticipantUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentParticipantScalarWhereInput
    data: XOR<TournamentParticipantUpdateManyMutationInput, TournamentParticipantUncheckedUpdateManyWithoutTournamentInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutTournamentInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutTournamentInput, MatchUncheckedUpdateWithoutTournamentInput>
    create: XOR<MatchCreateWithoutTournamentInput, MatchUncheckedCreateWithoutTournamentInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutTournamentInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutTournamentInput, MatchUncheckedUpdateWithoutTournamentInput>
  }

  export type MatchUpdateManyWithWhereWithoutTournamentInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutTournamentInput>
  }

  export type ActivityEventUpsertWithWhereUniqueWithoutTournamentInput = {
    where: ActivityEventWhereUniqueInput
    update: XOR<ActivityEventUpdateWithoutTournamentInput, ActivityEventUncheckedUpdateWithoutTournamentInput>
    create: XOR<ActivityEventCreateWithoutTournamentInput, ActivityEventUncheckedCreateWithoutTournamentInput>
  }

  export type ActivityEventUpdateWithWhereUniqueWithoutTournamentInput = {
    where: ActivityEventWhereUniqueInput
    data: XOR<ActivityEventUpdateWithoutTournamentInput, ActivityEventUncheckedUpdateWithoutTournamentInput>
  }

  export type ActivityEventUpdateManyWithWhereWithoutTournamentInput = {
    where: ActivityEventScalarWhereInput
    data: XOR<ActivityEventUpdateManyMutationInput, ActivityEventUncheckedUpdateManyWithoutTournamentInput>
  }

  export type TournamentCreateWithoutParticipantsInput = {
    id?: string
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutTournamentsInput
    matches?: MatchCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutParticipantsInput = {
    id?: string
    venueId?: string | null
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    matches?: MatchUncheckedCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutParticipantsInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutParticipantsInput, TournamentUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTournamentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTournamentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTournamentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTournamentsInput, UserUncheckedCreateWithoutTournamentsInput>
  }

  export type TournamentUpsertWithoutParticipantsInput = {
    update: XOR<TournamentUpdateWithoutParticipantsInput, TournamentUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TournamentCreateWithoutParticipantsInput, TournamentUncheckedCreateWithoutParticipantsInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutParticipantsInput, TournamentUncheckedUpdateWithoutParticipantsInput>
  }

  export type TournamentUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutTournamentsNestedInput
    matches?: MatchUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type UserUpsertWithoutTournamentsInput = {
    update: XOR<UserUpdateWithoutTournamentsInput, UserUncheckedUpdateWithoutTournamentsInput>
    create: XOR<UserCreateWithoutTournamentsInput, UserUncheckedCreateWithoutTournamentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTournamentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTournamentsInput, UserUncheckedUpdateWithoutTournamentsInput>
  }

  export type UserUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TournamentCreateWithoutMatchesInput = {
    id?: string
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutTournamentsInput
    participants?: TournamentParticipantCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutMatchesInput = {
    id?: string
    venueId?: string | null
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TournamentParticipantUncheckedCreateNestedManyWithoutTournamentInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutMatchesInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
  }

  export type VenueCreateWithoutMatchesInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutMatchesInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutMatchesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutMatchesInput, VenueUncheckedCreateWithoutMatchesInput>
  }

  export type TableCreateWithoutMatchesInput = {
    id?: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutTablesListInput
  }

  export type TableUncheckedCreateWithoutMatchesInput = {
    id?: string
    venueId: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableCreateOrConnectWithoutMatchesInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutMatchesInput, TableUncheckedCreateWithoutMatchesInput>
  }

  export type UserCreateWithoutMatchesAsPlayerAInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchesAsPlayerAInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchesAsPlayerAInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesAsPlayerAInput, UserUncheckedCreateWithoutMatchesAsPlayerAInput>
  }

  export type UserCreateWithoutMatchesAsPlayerBInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchesAsPlayerBInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchesAsPlayerBInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesAsPlayerBInput, UserUncheckedCreateWithoutMatchesAsPlayerBInput>
  }

  export type MatchEventCreateWithoutMatchInput = {
    id?: string
    type: $Enums.MatchEventType
    payload: string
    ts?: Date | string
  }

  export type MatchEventUncheckedCreateWithoutMatchInput = {
    id?: string
    type: $Enums.MatchEventType
    payload: string
    ts?: Date | string
  }

  export type MatchEventCreateOrConnectWithoutMatchInput = {
    where: MatchEventWhereUniqueInput
    create: XOR<MatchEventCreateWithoutMatchInput, MatchEventUncheckedCreateWithoutMatchInput>
  }

  export type MatchEventCreateManyMatchInputEnvelope = {
    data: MatchEventCreateManyMatchInput | MatchEventCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type ActivityEventCreateWithoutMatchInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityEventsInput
    venue?: VenueCreateNestedOneWithoutActivityEventsInput
    tournament?: TournamentCreateNestedOneWithoutActivityEventsInput
    clan?: ClanCreateNestedOneWithoutActivityEventsInput
  }

  export type ActivityEventUncheckedCreateWithoutMatchInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateOrConnectWithoutMatchInput = {
    where: ActivityEventWhereUniqueInput
    create: XOR<ActivityEventCreateWithoutMatchInput, ActivityEventUncheckedCreateWithoutMatchInput>
  }

  export type ActivityEventCreateManyMatchInputEnvelope = {
    data: ActivityEventCreateManyMatchInput | ActivityEventCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type TournamentUpsertWithoutMatchesInput = {
    update: XOR<TournamentUpdateWithoutMatchesInput, TournamentUncheckedUpdateWithoutMatchesInput>
    create: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutMatchesInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutMatchesInput, TournamentUncheckedUpdateWithoutMatchesInput>
  }

  export type TournamentUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutTournamentsNestedInput
    participants?: TournamentParticipantUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TournamentParticipantUncheckedUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type VenueUpsertWithoutMatchesInput = {
    update: XOR<VenueUpdateWithoutMatchesInput, VenueUncheckedUpdateWithoutMatchesInput>
    create: XOR<VenueCreateWithoutMatchesInput, VenueUncheckedCreateWithoutMatchesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutMatchesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutMatchesInput, VenueUncheckedUpdateWithoutMatchesInput>
  }

  export type VenueUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type TableUpsertWithoutMatchesInput = {
    update: XOR<TableUpdateWithoutMatchesInput, TableUncheckedUpdateWithoutMatchesInput>
    create: XOR<TableCreateWithoutMatchesInput, TableUncheckedCreateWithoutMatchesInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutMatchesInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutMatchesInput, TableUncheckedUpdateWithoutMatchesInput>
  }

  export type TableUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutTablesListNestedInput
  }

  export type TableUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMatchesAsPlayerAInput = {
    update: XOR<UserUpdateWithoutMatchesAsPlayerAInput, UserUncheckedUpdateWithoutMatchesAsPlayerAInput>
    create: XOR<UserCreateWithoutMatchesAsPlayerAInput, UserUncheckedCreateWithoutMatchesAsPlayerAInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesAsPlayerAInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesAsPlayerAInput, UserUncheckedUpdateWithoutMatchesAsPlayerAInput>
  }

  export type UserUpdateWithoutMatchesAsPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesAsPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMatchesAsPlayerBInput = {
    update: XOR<UserUpdateWithoutMatchesAsPlayerBInput, UserUncheckedUpdateWithoutMatchesAsPlayerBInput>
    create: XOR<UserCreateWithoutMatchesAsPlayerBInput, UserUncheckedCreateWithoutMatchesAsPlayerBInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesAsPlayerBInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesAsPlayerBInput, UserUncheckedUpdateWithoutMatchesAsPlayerBInput>
  }

  export type UserUpdateWithoutMatchesAsPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesAsPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatchEventUpsertWithWhereUniqueWithoutMatchInput = {
    where: MatchEventWhereUniqueInput
    update: XOR<MatchEventUpdateWithoutMatchInput, MatchEventUncheckedUpdateWithoutMatchInput>
    create: XOR<MatchEventCreateWithoutMatchInput, MatchEventUncheckedCreateWithoutMatchInput>
  }

  export type MatchEventUpdateWithWhereUniqueWithoutMatchInput = {
    where: MatchEventWhereUniqueInput
    data: XOR<MatchEventUpdateWithoutMatchInput, MatchEventUncheckedUpdateWithoutMatchInput>
  }

  export type MatchEventUpdateManyWithWhereWithoutMatchInput = {
    where: MatchEventScalarWhereInput
    data: XOR<MatchEventUpdateManyMutationInput, MatchEventUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchEventScalarWhereInput = {
    AND?: MatchEventScalarWhereInput | MatchEventScalarWhereInput[]
    OR?: MatchEventScalarWhereInput[]
    NOT?: MatchEventScalarWhereInput | MatchEventScalarWhereInput[]
    id?: StringFilter<"MatchEvent"> | string
    matchId?: StringFilter<"MatchEvent"> | string
    type?: EnumMatchEventTypeFilter<"MatchEvent"> | $Enums.MatchEventType
    payload?: StringFilter<"MatchEvent"> | string
    ts?: DateTimeFilter<"MatchEvent"> | Date | string
  }

  export type ActivityEventUpsertWithWhereUniqueWithoutMatchInput = {
    where: ActivityEventWhereUniqueInput
    update: XOR<ActivityEventUpdateWithoutMatchInput, ActivityEventUncheckedUpdateWithoutMatchInput>
    create: XOR<ActivityEventCreateWithoutMatchInput, ActivityEventUncheckedCreateWithoutMatchInput>
  }

  export type ActivityEventUpdateWithWhereUniqueWithoutMatchInput = {
    where: ActivityEventWhereUniqueInput
    data: XOR<ActivityEventUpdateWithoutMatchInput, ActivityEventUncheckedUpdateWithoutMatchInput>
  }

  export type ActivityEventUpdateManyWithWhereWithoutMatchInput = {
    where: ActivityEventScalarWhereInput
    data: XOR<ActivityEventUpdateManyMutationInput, ActivityEventUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchCreateWithoutEventsInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament?: TournamentCreateNestedOneWithoutMatchesInput
    venue?: VenueCreateNestedOneWithoutMatchesInput
    table?: TableCreateNestedOneWithoutMatchesInput
    playerA: UserCreateNestedOneWithoutMatchesAsPlayerAInput
    playerB: UserCreateNestedOneWithoutMatchesAsPlayerBInput
    activityEvents?: ActivityEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutEventsInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutEventsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutEventsInput, MatchUncheckedCreateWithoutEventsInput>
  }

  export type MatchUpsertWithoutEventsInput = {
    update: XOR<MatchUpdateWithoutEventsInput, MatchUncheckedUpdateWithoutEventsInput>
    create: XOR<MatchCreateWithoutEventsInput, MatchUncheckedCreateWithoutEventsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutEventsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutEventsInput, MatchUncheckedUpdateWithoutEventsInput>
  }

  export type MatchUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneWithoutMatchesNestedInput
    venue?: VenueUpdateOneWithoutMatchesNestedInput
    table?: TableUpdateOneWithoutMatchesNestedInput
    playerA?: UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput
    playerB?: UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type UserCreateWithoutChallengesAsChallengerInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallengesAsChallengerInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallengesAsChallengerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengesAsChallengerInput, UserUncheckedCreateWithoutChallengesAsChallengerInput>
  }

  export type UserCreateWithoutChallengesAsDefenderInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallengesAsDefenderInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallengesAsDefenderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengesAsDefenderInput, UserUncheckedCreateWithoutChallengesAsDefenderInput>
  }

  export type VenueCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutChallengesInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutChallengesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
  }

  export type UserUpsertWithoutChallengesAsChallengerInput = {
    update: XOR<UserUpdateWithoutChallengesAsChallengerInput, UserUncheckedUpdateWithoutChallengesAsChallengerInput>
    create: XOR<UserCreateWithoutChallengesAsChallengerInput, UserUncheckedCreateWithoutChallengesAsChallengerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengesAsChallengerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengesAsChallengerInput, UserUncheckedUpdateWithoutChallengesAsChallengerInput>
  }

  export type UserUpdateWithoutChallengesAsChallengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengesAsChallengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutChallengesAsDefenderInput = {
    update: XOR<UserUpdateWithoutChallengesAsDefenderInput, UserUncheckedUpdateWithoutChallengesAsDefenderInput>
    create: XOR<UserCreateWithoutChallengesAsDefenderInput, UserUncheckedCreateWithoutChallengesAsDefenderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengesAsDefenderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengesAsDefenderInput, UserUncheckedUpdateWithoutChallengesAsDefenderInput>
  }

  export type UserUpdateWithoutChallengesAsDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengesAsDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenueUpsertWithoutChallengesInput = {
    update: XOR<VenueUpdateWithoutChallengesInput, VenueUncheckedUpdateWithoutChallengesInput>
    create: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutChallengesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutChallengesInput, VenueUncheckedUpdateWithoutChallengesInput>
  }

  export type VenueUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserCreateWithoutWalletsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
  }

  export type UserUpsertWithoutWalletsInput = {
    update: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type UserUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserNFTCreateWithoutNftInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNftsInput
  }

  export type UserNFTUncheckedCreateWithoutNftInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserNFTCreateOrConnectWithoutNftInput = {
    where: UserNFTWhereUniqueInput
    create: XOR<UserNFTCreateWithoutNftInput, UserNFTUncheckedCreateWithoutNftInput>
  }

  export type UserNFTCreateManyNftInputEnvelope = {
    data: UserNFTCreateManyNftInput | UserNFTCreateManyNftInput[]
    skipDuplicates?: boolean
  }

  export type UserNFTUpsertWithWhereUniqueWithoutNftInput = {
    where: UserNFTWhereUniqueInput
    update: XOR<UserNFTUpdateWithoutNftInput, UserNFTUncheckedUpdateWithoutNftInput>
    create: XOR<UserNFTCreateWithoutNftInput, UserNFTUncheckedCreateWithoutNftInput>
  }

  export type UserNFTUpdateWithWhereUniqueWithoutNftInput = {
    where: UserNFTWhereUniqueInput
    data: XOR<UserNFTUpdateWithoutNftInput, UserNFTUncheckedUpdateWithoutNftInput>
  }

  export type UserNFTUpdateManyWithWhereWithoutNftInput = {
    where: UserNFTScalarWhereInput
    data: XOR<UserNFTUpdateManyMutationInput, UserNFTUncheckedUpdateManyWithoutNftInput>
  }

  export type UserCreateWithoutNftsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNftsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNftsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNftsInput, UserUncheckedCreateWithoutNftsInput>
  }

  export type NFTCreateWithoutUsersInput = {
    id?: string
    contract: string
    tokenId: string
    chain: string
    metadata: string
    createdAt?: Date | string
  }

  export type NFTUncheckedCreateWithoutUsersInput = {
    id?: string
    contract: string
    tokenId: string
    chain: string
    metadata: string
    createdAt?: Date | string
  }

  export type NFTCreateOrConnectWithoutUsersInput = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutUsersInput, NFTUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutNftsInput = {
    update: XOR<UserUpdateWithoutNftsInput, UserUncheckedUpdateWithoutNftsInput>
    create: XOR<UserCreateWithoutNftsInput, UserUncheckedCreateWithoutNftsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNftsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNftsInput, UserUncheckedUpdateWithoutNftsInput>
  }

  export type UserUpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NFTUpsertWithoutUsersInput = {
    update: XOR<NFTUpdateWithoutUsersInput, NFTUncheckedUpdateWithoutUsersInput>
    create: XOR<NFTCreateWithoutUsersInput, NFTUncheckedCreateWithoutUsersInput>
    where?: NFTWhereInput
  }

  export type NFTUpdateToOneWithWhereWithoutUsersInput = {
    where?: NFTWhereInput
    data: XOR<NFTUpdateWithoutUsersInput, NFTUncheckedUpdateWithoutUsersInput>
  }

  export type NFTUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUsersInput = {
    id?: string
    key: string
    name: string
    desc?: string | null
    description?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUsersInput = {
    id?: string
    key: string
    name: string
    desc?: string | null
    description?: string | null
    category?: string
    points?: number
    createdAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUsersInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUsersInput = {
    update: XOR<AchievementUpdateWithoutUsersInput, AchievementUncheckedUpdateWithoutUsersInput>
    create: XOR<AchievementCreateWithoutUsersInput, AchievementUncheckedCreateWithoutUsersInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUsersInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUsersInput, AchievementUncheckedUpdateWithoutUsersInput>
  }

  export type AchievementUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFriendshipsAsRequesterInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendshipsAsRequesterInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendshipsAsRequesterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendshipsAsRequesterInput, UserUncheckedCreateWithoutFriendshipsAsRequesterInput>
  }

  export type UserCreateWithoutFriendshipsAsAddresseeInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendshipsAsAddresseeInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendshipsAsAddresseeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendshipsAsAddresseeInput, UserUncheckedCreateWithoutFriendshipsAsAddresseeInput>
  }

  export type UserUpsertWithoutFriendshipsAsRequesterInput = {
    update: XOR<UserUpdateWithoutFriendshipsAsRequesterInput, UserUncheckedUpdateWithoutFriendshipsAsRequesterInput>
    create: XOR<UserCreateWithoutFriendshipsAsRequesterInput, UserUncheckedCreateWithoutFriendshipsAsRequesterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendshipsAsRequesterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendshipsAsRequesterInput, UserUncheckedUpdateWithoutFriendshipsAsRequesterInput>
  }

  export type UserUpdateWithoutFriendshipsAsRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendshipsAsRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFriendshipsAsAddresseeInput = {
    update: XOR<UserUpdateWithoutFriendshipsAsAddresseeInput, UserUncheckedUpdateWithoutFriendshipsAsAddresseeInput>
    create: XOR<UserCreateWithoutFriendshipsAsAddresseeInput, UserUncheckedCreateWithoutFriendshipsAsAddresseeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendshipsAsAddresseeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendshipsAsAddresseeInput, UserUncheckedUpdateWithoutFriendshipsAsAddresseeInput>
  }

  export type UserUpdateWithoutFriendshipsAsAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendshipsAsAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivityEventsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityEventsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityEventsInput, UserUncheckedCreateWithoutActivityEventsInput>
  }

  export type VenueCreateWithoutActivityEventsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutActivityEventsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutActivityEventsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutActivityEventsInput, VenueUncheckedCreateWithoutActivityEventsInput>
  }

  export type MatchCreateWithoutActivityEventsInput = {
    id?: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tournament?: TournamentCreateNestedOneWithoutMatchesInput
    venue?: VenueCreateNestedOneWithoutMatchesInput
    table?: TableCreateNestedOneWithoutMatchesInput
    playerA: UserCreateNestedOneWithoutMatchesAsPlayerAInput
    playerB: UserCreateNestedOneWithoutMatchesAsPlayerBInput
    events?: MatchEventCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutActivityEventsInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: MatchEventUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutActivityEventsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutActivityEventsInput, MatchUncheckedCreateWithoutActivityEventsInput>
  }

  export type TournamentCreateWithoutActivityEventsInput = {
    id?: string
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutTournamentsInput
    participants?: TournamentParticipantCreateNestedManyWithoutTournamentInput
    matches?: MatchCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutActivityEventsInput = {
    id?: string
    venueId?: string | null
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TournamentParticipantUncheckedCreateNestedManyWithoutTournamentInput
    matches?: MatchUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutActivityEventsInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutActivityEventsInput, TournamentUncheckedCreateWithoutActivityEventsInput>
  }

  export type ClanCreateWithoutActivityEventsInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutLedClansInput
    members?: ClanMemberCreateNestedManyWithoutClanInput
    territories?: TerritoryCreateNestedManyWithoutClanInput
    controlledVenues?: VenueCreateNestedManyWithoutControllingClanInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanUncheckedCreateWithoutActivityEventsInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    leaderId: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClanMemberUncheckedCreateNestedManyWithoutClanInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutClanInput
    controlledVenues?: VenueUncheckedCreateNestedManyWithoutControllingClanInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutInitiatingClanInput
  }

  export type ClanCreateOrConnectWithoutActivityEventsInput = {
    where: ClanWhereUniqueInput
    create: XOR<ClanCreateWithoutActivityEventsInput, ClanUncheckedCreateWithoutActivityEventsInput>
  }

  export type UserUpsertWithoutActivityEventsInput = {
    update: XOR<UserUpdateWithoutActivityEventsInput, UserUncheckedUpdateWithoutActivityEventsInput>
    create: XOR<UserCreateWithoutActivityEventsInput, UserUncheckedCreateWithoutActivityEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityEventsInput, UserUncheckedUpdateWithoutActivityEventsInput>
  }

  export type UserUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenueUpsertWithoutActivityEventsInput = {
    update: XOR<VenueUpdateWithoutActivityEventsInput, VenueUncheckedUpdateWithoutActivityEventsInput>
    create: XOR<VenueCreateWithoutActivityEventsInput, VenueUncheckedCreateWithoutActivityEventsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutActivityEventsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutActivityEventsInput, VenueUncheckedUpdateWithoutActivityEventsInput>
  }

  export type VenueUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type MatchUpsertWithoutActivityEventsInput = {
    update: XOR<MatchUpdateWithoutActivityEventsInput, MatchUncheckedUpdateWithoutActivityEventsInput>
    create: XOR<MatchCreateWithoutActivityEventsInput, MatchUncheckedCreateWithoutActivityEventsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutActivityEventsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutActivityEventsInput, MatchUncheckedUpdateWithoutActivityEventsInput>
  }

  export type MatchUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneWithoutMatchesNestedInput
    venue?: VenueUpdateOneWithoutMatchesNestedInput
    table?: TableUpdateOneWithoutMatchesNestedInput
    playerA?: UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput
    playerB?: UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput
    events?: MatchEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: MatchEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type TournamentUpsertWithoutActivityEventsInput = {
    update: XOR<TournamentUpdateWithoutActivityEventsInput, TournamentUncheckedUpdateWithoutActivityEventsInput>
    create: XOR<TournamentCreateWithoutActivityEventsInput, TournamentUncheckedCreateWithoutActivityEventsInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutActivityEventsInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutActivityEventsInput, TournamentUncheckedUpdateWithoutActivityEventsInput>
  }

  export type TournamentUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutTournamentsNestedInput
    participants?: TournamentParticipantUpdateManyWithoutTournamentNestedInput
    matches?: MatchUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TournamentParticipantUncheckedUpdateManyWithoutTournamentNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type ClanUpsertWithoutActivityEventsInput = {
    update: XOR<ClanUpdateWithoutActivityEventsInput, ClanUncheckedUpdateWithoutActivityEventsInput>
    create: XOR<ClanCreateWithoutActivityEventsInput, ClanUncheckedCreateWithoutActivityEventsInput>
    where?: ClanWhereInput
  }

  export type ClanUpdateToOneWithWhereWithoutActivityEventsInput = {
    where?: ClanWhereInput
    data: XOR<ClanUpdateWithoutActivityEventsInput, ClanUncheckedUpdateWithoutActivityEventsInput>
  }

  export type ClanUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutLedClansNestedInput
    members?: ClanMemberUpdateManyWithoutClanNestedInput
    territories?: TerritoryUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUpdateManyWithoutControllingClanNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanUncheckedUpdateWithoutActivityEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    leaderId?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClanMemberUncheckedUpdateManyWithoutClanNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUncheckedUpdateManyWithoutControllingClanNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutInitiatingClanNestedInput
  }

  export type VenueCreateWithoutQuestsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutQuestsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutQuestsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutQuestsInput, VenueUncheckedCreateWithoutQuestsInput>
  }

  export type VenueUpsertWithoutQuestsInput = {
    update: XOR<VenueUpdateWithoutQuestsInput, VenueUncheckedUpdateWithoutQuestsInput>
    create: XOR<VenueCreateWithoutQuestsInput, VenueUncheckedCreateWithoutQuestsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutQuestsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutQuestsInput, VenueUncheckedUpdateWithoutQuestsInput>
  }

  export type VenueUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserCreateWithoutGameSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGameSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGameSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGameSessionsInput, UserUncheckedCreateWithoutGameSessionsInput>
  }

  export type VenueCreateWithoutGameSessionsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
  }

  export type VenueUncheckedCreateWithoutGameSessionsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
  }

  export type VenueCreateOrConnectWithoutGameSessionsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutGameSessionsInput, VenueUncheckedCreateWithoutGameSessionsInput>
  }

  export type UserUpsertWithoutGameSessionsInput = {
    update: XOR<UserUpdateWithoutGameSessionsInput, UserUncheckedUpdateWithoutGameSessionsInput>
    create: XOR<UserCreateWithoutGameSessionsInput, UserUncheckedCreateWithoutGameSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGameSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGameSessionsInput, UserUncheckedUpdateWithoutGameSessionsInput>
  }

  export type UserUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenueUpsertWithoutGameSessionsInput = {
    update: XOR<VenueUpdateWithoutGameSessionsInput, VenueUncheckedUpdateWithoutGameSessionsInput>
    create: XOR<VenueCreateWithoutGameSessionsInput, VenueUncheckedCreateWithoutGameSessionsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutGameSessionsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutGameSessionsInput, VenueUncheckedUpdateWithoutGameSessionsInput>
  }

  export type VenueUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutGameSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
  }

  export type UserInventoryItemCreateWithoutMarketplaceItemInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInventoryItemsInput
  }

  export type UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserInventoryItemCreateOrConnectWithoutMarketplaceItemInput = {
    where: UserInventoryItemWhereUniqueInput
    create: XOR<UserInventoryItemCreateWithoutMarketplaceItemInput, UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput>
  }

  export type UserInventoryItemCreateManyMarketplaceItemInputEnvelope = {
    data: UserInventoryItemCreateManyMarketplaceItemInput | UserInventoryItemCreateManyMarketplaceItemInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCosmeticItemCreateWithoutApprovedItemInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCommunityItemsInput
    reviewer?: UserCreateNestedOneWithoutReviewedItemsInput
    likedBy?: CosmeticItemLikeCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemUncheckedCreateWithoutApprovedItemInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    reviewerId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: CosmeticItemLikeUncheckedCreateNestedManyWithoutCosmeticItemInput
  }

  export type CommunityCosmeticItemCreateOrConnectWithoutApprovedItemInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    create: XOR<CommunityCosmeticItemCreateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedCreateWithoutApprovedItemInput>
  }

  export type UserInventoryItemUpsertWithWhereUniqueWithoutMarketplaceItemInput = {
    where: UserInventoryItemWhereUniqueInput
    update: XOR<UserInventoryItemUpdateWithoutMarketplaceItemInput, UserInventoryItemUncheckedUpdateWithoutMarketplaceItemInput>
    create: XOR<UserInventoryItemCreateWithoutMarketplaceItemInput, UserInventoryItemUncheckedCreateWithoutMarketplaceItemInput>
  }

  export type UserInventoryItemUpdateWithWhereUniqueWithoutMarketplaceItemInput = {
    where: UserInventoryItemWhereUniqueInput
    data: XOR<UserInventoryItemUpdateWithoutMarketplaceItemInput, UserInventoryItemUncheckedUpdateWithoutMarketplaceItemInput>
  }

  export type UserInventoryItemUpdateManyWithWhereWithoutMarketplaceItemInput = {
    where: UserInventoryItemScalarWhereInput
    data: XOR<UserInventoryItemUpdateManyMutationInput, UserInventoryItemUncheckedUpdateManyWithoutMarketplaceItemInput>
  }

  export type CommunityCosmeticItemUpsertWithoutApprovedItemInput = {
    update: XOR<CommunityCosmeticItemUpdateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedUpdateWithoutApprovedItemInput>
    create: XOR<CommunityCosmeticItemCreateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedCreateWithoutApprovedItemInput>
    where?: CommunityCosmeticItemWhereInput
  }

  export type CommunityCosmeticItemUpdateToOneWithWhereWithoutApprovedItemInput = {
    where?: CommunityCosmeticItemWhereInput
    data: XOR<CommunityCosmeticItemUpdateWithoutApprovedItemInput, CommunityCosmeticItemUncheckedUpdateWithoutApprovedItemInput>
  }

  export type CommunityCosmeticItemUpdateWithoutApprovedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCommunityItemsNestedInput
    reviewer?: UserUpdateOneWithoutReviewedItemsNestedInput
    likedBy?: CosmeticItemLikeUpdateManyWithoutCosmeticItemNestedInput
  }

  export type CommunityCosmeticItemUncheckedUpdateWithoutApprovedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: CosmeticItemLikeUncheckedUpdateManyWithoutCosmeticItemNestedInput
  }

  export type UserCreateWithoutCommunityItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunityItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunityItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityItemsInput, UserUncheckedCreateWithoutCommunityItemsInput>
  }

  export type MarketplaceItemCreateWithoutCommunityItemInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    category: string
    imageUrl?: string | null
    available?: boolean
    communityItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutMarketplaceItemInput
  }

  export type MarketplaceItemUncheckedCreateWithoutCommunityItemInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    category: string
    imageUrl?: string | null
    available?: boolean
    communityItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutMarketplaceItemInput
  }

  export type MarketplaceItemCreateOrConnectWithoutCommunityItemInput = {
    where: MarketplaceItemWhereUniqueInput
    create: XOR<MarketplaceItemCreateWithoutCommunityItemInput, MarketplaceItemUncheckedCreateWithoutCommunityItemInput>
  }

  export type UserCreateWithoutReviewedItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewedItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewedItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewedItemsInput, UserUncheckedCreateWithoutReviewedItemsInput>
  }

  export type CosmeticItemLikeCreateWithoutCosmeticItemInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCosmeticLikesInput
  }

  export type CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CosmeticItemLikeCreateOrConnectWithoutCosmeticItemInput = {
    where: CosmeticItemLikeWhereUniqueInput
    create: XOR<CosmeticItemLikeCreateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput>
  }

  export type CosmeticItemLikeCreateManyCosmeticItemInputEnvelope = {
    data: CosmeticItemLikeCreateManyCosmeticItemInput | CosmeticItemLikeCreateManyCosmeticItemInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommunityItemsInput = {
    update: XOR<UserUpdateWithoutCommunityItemsInput, UserUncheckedUpdateWithoutCommunityItemsInput>
    create: XOR<UserCreateWithoutCommunityItemsInput, UserUncheckedCreateWithoutCommunityItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunityItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunityItemsInput, UserUncheckedUpdateWithoutCommunityItemsInput>
  }

  export type UserUpdateWithoutCommunityItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunityItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MarketplaceItemUpsertWithoutCommunityItemInput = {
    update: XOR<MarketplaceItemUpdateWithoutCommunityItemInput, MarketplaceItemUncheckedUpdateWithoutCommunityItemInput>
    create: XOR<MarketplaceItemCreateWithoutCommunityItemInput, MarketplaceItemUncheckedCreateWithoutCommunityItemInput>
    where?: MarketplaceItemWhereInput
  }

  export type MarketplaceItemUpdateToOneWithWhereWithoutCommunityItemInput = {
    where?: MarketplaceItemWhereInput
    data: XOR<MarketplaceItemUpdateWithoutCommunityItemInput, MarketplaceItemUncheckedUpdateWithoutCommunityItemInput>
  }

  export type MarketplaceItemUpdateWithoutCommunityItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: UserInventoryItemUpdateManyWithoutMarketplaceItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateWithoutCommunityItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutMarketplaceItemNestedInput
  }

  export type UserUpsertWithoutReviewedItemsInput = {
    update: XOR<UserUpdateWithoutReviewedItemsInput, UserUncheckedUpdateWithoutReviewedItemsInput>
    create: XOR<UserCreateWithoutReviewedItemsInput, UserUncheckedCreateWithoutReviewedItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewedItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewedItemsInput, UserUncheckedUpdateWithoutReviewedItemsInput>
  }

  export type UserUpdateWithoutReviewedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CosmeticItemLikeUpsertWithWhereUniqueWithoutCosmeticItemInput = {
    where: CosmeticItemLikeWhereUniqueInput
    update: XOR<CosmeticItemLikeUpdateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedUpdateWithoutCosmeticItemInput>
    create: XOR<CosmeticItemLikeCreateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedCreateWithoutCosmeticItemInput>
  }

  export type CosmeticItemLikeUpdateWithWhereUniqueWithoutCosmeticItemInput = {
    where: CosmeticItemLikeWhereUniqueInput
    data: XOR<CosmeticItemLikeUpdateWithoutCosmeticItemInput, CosmeticItemLikeUncheckedUpdateWithoutCosmeticItemInput>
  }

  export type CosmeticItemLikeUpdateManyWithWhereWithoutCosmeticItemInput = {
    where: CosmeticItemLikeScalarWhereInput
    data: XOR<CosmeticItemLikeUpdateManyMutationInput, CosmeticItemLikeUncheckedUpdateManyWithoutCosmeticItemInput>
  }

  export type UserCreateWithoutCosmeticLikesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCosmeticLikesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCosmeticLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCosmeticLikesInput, UserUncheckedCreateWithoutCosmeticLikesInput>
  }

  export type CommunityCosmeticItemCreateWithoutLikedByInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCommunityItemsInput
    approvedItem?: MarketplaceItemCreateNestedOneWithoutCommunityItemInput
    reviewer?: UserCreateNestedOneWithoutReviewedItemsInput
  }

  export type CommunityCosmeticItemUncheckedCreateWithoutLikedByInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    approvedItemId?: string | null
    reviewerId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityCosmeticItemCreateOrConnectWithoutLikedByInput = {
    where: CommunityCosmeticItemWhereUniqueInput
    create: XOR<CommunityCosmeticItemCreateWithoutLikedByInput, CommunityCosmeticItemUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutCosmeticLikesInput = {
    update: XOR<UserUpdateWithoutCosmeticLikesInput, UserUncheckedUpdateWithoutCosmeticLikesInput>
    create: XOR<UserCreateWithoutCosmeticLikesInput, UserUncheckedCreateWithoutCosmeticLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCosmeticLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCosmeticLikesInput, UserUncheckedUpdateWithoutCosmeticLikesInput>
  }

  export type UserUpdateWithoutCosmeticLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCosmeticLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityCosmeticItemUpsertWithoutLikedByInput = {
    update: XOR<CommunityCosmeticItemUpdateWithoutLikedByInput, CommunityCosmeticItemUncheckedUpdateWithoutLikedByInput>
    create: XOR<CommunityCosmeticItemCreateWithoutLikedByInput, CommunityCosmeticItemUncheckedCreateWithoutLikedByInput>
    where?: CommunityCosmeticItemWhereInput
  }

  export type CommunityCosmeticItemUpdateToOneWithWhereWithoutLikedByInput = {
    where?: CommunityCosmeticItemWhereInput
    data: XOR<CommunityCosmeticItemUpdateWithoutLikedByInput, CommunityCosmeticItemUncheckedUpdateWithoutLikedByInput>
  }

  export type CommunityCosmeticItemUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCommunityItemsNestedInput
    approvedItem?: MarketplaceItemUpdateOneWithoutCommunityItemNestedInput
    reviewer?: UserUpdateOneWithoutReviewedItemsNestedInput
  }

  export type CommunityCosmeticItemUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedItemId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutShadowRunsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShadowRunsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShadowRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShadowRunsInput, UserUncheckedCreateWithoutShadowRunsInput>
  }

  export type ClanCreateWithoutShadowRunsInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutLedClansInput
    members?: ClanMemberCreateNestedManyWithoutClanInput
    territories?: TerritoryCreateNestedManyWithoutClanInput
    controlledVenues?: VenueCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventCreateNestedManyWithoutClanInput
  }

  export type ClanUncheckedCreateWithoutShadowRunsInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    leaderId: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ClanMemberUncheckedCreateNestedManyWithoutClanInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutClanInput
    controlledVenues?: VenueUncheckedCreateNestedManyWithoutControllingClanInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutClanInput
  }

  export type ClanCreateOrConnectWithoutShadowRunsInput = {
    where: ClanWhereUniqueInput
    create: XOR<ClanCreateWithoutShadowRunsInput, ClanUncheckedCreateWithoutShadowRunsInput>
  }

  export type VenueCreateWithoutShadowRunsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutShadowRunsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutShadowRunsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutShadowRunsInput, VenueUncheckedCreateWithoutShadowRunsInput>
  }

  export type UserUpsertWithoutShadowRunsInput = {
    update: XOR<UserUpdateWithoutShadowRunsInput, UserUncheckedUpdateWithoutShadowRunsInput>
    create: XOR<UserCreateWithoutShadowRunsInput, UserUncheckedCreateWithoutShadowRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShadowRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShadowRunsInput, UserUncheckedUpdateWithoutShadowRunsInput>
  }

  export type UserUpdateWithoutShadowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShadowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClanUpsertWithoutShadowRunsInput = {
    update: XOR<ClanUpdateWithoutShadowRunsInput, ClanUncheckedUpdateWithoutShadowRunsInput>
    create: XOR<ClanCreateWithoutShadowRunsInput, ClanUncheckedCreateWithoutShadowRunsInput>
    where?: ClanWhereInput
  }

  export type ClanUpdateToOneWithWhereWithoutShadowRunsInput = {
    where?: ClanWhereInput
    data: XOR<ClanUpdateWithoutShadowRunsInput, ClanUncheckedUpdateWithoutShadowRunsInput>
  }

  export type ClanUpdateWithoutShadowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutLedClansNestedInput
    members?: ClanMemberUpdateManyWithoutClanNestedInput
    territories?: TerritoryUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutClanNestedInput
  }

  export type ClanUncheckedUpdateWithoutShadowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    leaderId?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClanMemberUncheckedUpdateManyWithoutClanNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUncheckedUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutClanNestedInput
  }

  export type VenueUpsertWithoutShadowRunsInput = {
    update: XOR<VenueUpdateWithoutShadowRunsInput, VenueUncheckedUpdateWithoutShadowRunsInput>
    create: XOR<VenueCreateWithoutShadowRunsInput, VenueUncheckedCreateWithoutShadowRunsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutShadowRunsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutShadowRunsInput, VenueUncheckedUpdateWithoutShadowRunsInput>
  }

  export type VenueUpdateWithoutShadowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutShadowRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserCreateWithoutDojoCheckInsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDojoCheckInsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDojoCheckInsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDojoCheckInsInput, UserUncheckedCreateWithoutDojoCheckInsInput>
  }

  export type VenueCreateWithoutDojoCheckInsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutDojoCheckInsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    specials?: VenueSpecialUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutDojoCheckInsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutDojoCheckInsInput, VenueUncheckedCreateWithoutDojoCheckInsInput>
  }

  export type UserUpsertWithoutDojoCheckInsInput = {
    update: XOR<UserUpdateWithoutDojoCheckInsInput, UserUncheckedUpdateWithoutDojoCheckInsInput>
    create: XOR<UserCreateWithoutDojoCheckInsInput, UserUncheckedCreateWithoutDojoCheckInsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDojoCheckInsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDojoCheckInsInput, UserUncheckedUpdateWithoutDojoCheckInsInput>
  }

  export type UserUpdateWithoutDojoCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDojoCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VenueUpsertWithoutDojoCheckInsInput = {
    update: XOR<VenueUpdateWithoutDojoCheckInsInput, VenueUncheckedUpdateWithoutDojoCheckInsInput>
    create: XOR<VenueCreateWithoutDojoCheckInsInput, VenueUncheckedCreateWithoutDojoCheckInsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutDojoCheckInsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutDojoCheckInsInput, VenueUncheckedUpdateWithoutDojoCheckInsInput>
  }

  export type VenueUpdateWithoutDojoCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutDojoCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateWithoutSpecialsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutVenuesInput
    controllingClan?: ClanCreateNestedOneWithoutControlledVenuesInput
    tablesList?: TableCreateNestedManyWithoutVenueInput
    tournaments?: TournamentCreateNestedManyWithoutVenueInput
    territories?: TerritoryCreateNestedManyWithoutVenueInput
    checkIns?: CheckInCreateNestedManyWithoutVenueInput
    challenges?: ChallengeCreateNestedManyWithoutVenueInput
    matches?: MatchCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventCreateNestedManyWithoutVenueInput
    quests?: VenueQuestCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutSpecialsInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tablesList?: TableUncheckedCreateNestedManyWithoutVenueInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutVenueInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutVenueInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeUncheckedCreateNestedManyWithoutVenueInput
    matches?: MatchUncheckedCreateNestedManyWithoutVenueInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutVenueInput
    quests?: VenueQuestUncheckedCreateNestedManyWithoutVenueInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutVenueInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutTargetVenueInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutSpecialsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutSpecialsInput, VenueUncheckedCreateWithoutSpecialsInput>
  }

  export type VenueUpsertWithoutSpecialsInput = {
    update: XOR<VenueUpdateWithoutSpecialsInput, VenueUncheckedUpdateWithoutSpecialsInput>
    create: XOR<VenueCreateWithoutSpecialsInput, VenueUncheckedCreateWithoutSpecialsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutSpecialsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutSpecialsInput, VenueUncheckedUpdateWithoutSpecialsInput>
  }

  export type VenueUpdateWithoutSpecialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutSpecialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserCreateWithoutInventoryItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryItemsInput, UserUncheckedCreateWithoutInventoryItemsInput>
  }

  export type MarketplaceItemCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    category: string
    imageUrl?: string | null
    available?: boolean
    communityItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    communityItem?: CommunityCosmeticItemCreateNestedOneWithoutApprovedItemInput
  }

  export type MarketplaceItemUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    category: string
    imageUrl?: string | null
    available?: boolean
    communityItemId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    communityItem?: CommunityCosmeticItemUncheckedCreateNestedOneWithoutApprovedItemInput
  }

  export type MarketplaceItemCreateOrConnectWithoutInventoryItemsInput = {
    where: MarketplaceItemWhereUniqueInput
    create: XOR<MarketplaceItemCreateWithoutInventoryItemsInput, MarketplaceItemUncheckedCreateWithoutInventoryItemsInput>
  }

  export type UserUpsertWithoutInventoryItemsInput = {
    update: XOR<UserUpdateWithoutInventoryItemsInput, UserUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<UserCreateWithoutInventoryItemsInput, UserUncheckedCreateWithoutInventoryItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryItemsInput, UserUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type UserUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MarketplaceItemUpsertWithoutInventoryItemsInput = {
    update: XOR<MarketplaceItemUpdateWithoutInventoryItemsInput, MarketplaceItemUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<MarketplaceItemCreateWithoutInventoryItemsInput, MarketplaceItemUncheckedCreateWithoutInventoryItemsInput>
    where?: MarketplaceItemWhereInput
  }

  export type MarketplaceItemUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: MarketplaceItemWhereInput
    data: XOR<MarketplaceItemUpdateWithoutInventoryItemsInput, MarketplaceItemUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type MarketplaceItemUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityItem?: CommunityCosmeticItemUpdateOneWithoutApprovedItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    communityItemId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityItem?: CommunityCosmeticItemUncheckedUpdateOneWithoutApprovedItemNestedInput
  }

  export type UserCreateWithoutFeedbackInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
  }

  export type UserCreateWithoutResolvedFeedbackInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResolvedFeedbackInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResolvedFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResolvedFeedbackInput, UserUncheckedCreateWithoutResolvedFeedbackInput>
  }

  export type UserUpsertWithoutFeedbackInput = {
    update: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutResolvedFeedbackInput = {
    update: XOR<UserUpdateWithoutResolvedFeedbackInput, UserUncheckedUpdateWithoutResolvedFeedbackInput>
    create: XOR<UserCreateWithoutResolvedFeedbackInput, UserUncheckedCreateWithoutResolvedFeedbackInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResolvedFeedbackInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResolvedFeedbackInput, UserUncheckedUpdateWithoutResolvedFeedbackInput>
  }

  export type UserUpdateWithoutResolvedFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResolvedFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutContentInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContentInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContentInput, UserUncheckedCreateWithoutContentInput>
  }

  export type UserCreateWithoutModeratedContentInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModeratedContentInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModeratedContentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModeratedContentInput, UserUncheckedCreateWithoutModeratedContentInput>
  }

  export type ContentLikeCreateWithoutContentInput = {
    id?: string
    likes?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutContentLikesInput
  }

  export type ContentLikeUncheckedCreateWithoutContentInput = {
    id?: string
    userId: string
    likes?: number
    createdAt?: Date | string
  }

  export type ContentLikeCreateOrConnectWithoutContentInput = {
    where: ContentLikeWhereUniqueInput
    create: XOR<ContentLikeCreateWithoutContentInput, ContentLikeUncheckedCreateWithoutContentInput>
  }

  export type ContentLikeCreateManyContentInputEnvelope = {
    data: ContentLikeCreateManyContentInput | ContentLikeCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentShareCreateWithoutContentInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSharedContentInput
    sharedWith: UserCreateNestedOneWithoutReceivedSharesInput
  }

  export type ContentShareUncheckedCreateWithoutContentInput = {
    id?: string
    userId: string
    sharedWithId: string
    createdAt?: Date | string
  }

  export type ContentShareCreateOrConnectWithoutContentInput = {
    where: ContentShareWhereUniqueInput
    create: XOR<ContentShareCreateWithoutContentInput, ContentShareUncheckedCreateWithoutContentInput>
  }

  export type ContentShareCreateManyContentInputEnvelope = {
    data: ContentShareCreateManyContentInput | ContentShareCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutContentInput = {
    update: XOR<UserUpdateWithoutContentInput, UserUncheckedUpdateWithoutContentInput>
    create: XOR<UserCreateWithoutContentInput, UserUncheckedCreateWithoutContentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContentInput, UserUncheckedUpdateWithoutContentInput>
  }

  export type UserUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutModeratedContentInput = {
    update: XOR<UserUpdateWithoutModeratedContentInput, UserUncheckedUpdateWithoutModeratedContentInput>
    create: XOR<UserCreateWithoutModeratedContentInput, UserUncheckedCreateWithoutModeratedContentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModeratedContentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModeratedContentInput, UserUncheckedUpdateWithoutModeratedContentInput>
  }

  export type UserUpdateWithoutModeratedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModeratedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentLikeUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentLikeWhereUniqueInput
    update: XOR<ContentLikeUpdateWithoutContentInput, ContentLikeUncheckedUpdateWithoutContentInput>
    create: XOR<ContentLikeCreateWithoutContentInput, ContentLikeUncheckedCreateWithoutContentInput>
  }

  export type ContentLikeUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentLikeWhereUniqueInput
    data: XOR<ContentLikeUpdateWithoutContentInput, ContentLikeUncheckedUpdateWithoutContentInput>
  }

  export type ContentLikeUpdateManyWithWhereWithoutContentInput = {
    where: ContentLikeScalarWhereInput
    data: XOR<ContentLikeUpdateManyMutationInput, ContentLikeUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentShareUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentShareWhereUniqueInput
    update: XOR<ContentShareUpdateWithoutContentInput, ContentShareUncheckedUpdateWithoutContentInput>
    create: XOR<ContentShareCreateWithoutContentInput, ContentShareUncheckedCreateWithoutContentInput>
  }

  export type ContentShareUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentShareWhereUniqueInput
    data: XOR<ContentShareUpdateWithoutContentInput, ContentShareUncheckedUpdateWithoutContentInput>
  }

  export type ContentShareUpdateManyWithWhereWithoutContentInput = {
    where: ContentShareScalarWhereInput
    data: XOR<ContentShareUpdateManyMutationInput, ContentShareUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentCreateWithoutLikedByInput = {
    id?: string
    contentId?: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContentInput
    moderator?: UserCreateNestedOneWithoutModeratedContentInput
    sharedEntries?: ContentShareCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutLikedByInput = {
    id?: string
    contentId?: string
    userId: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sharedEntries?: ContentShareUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutLikedByInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutLikedByInput, ContentUncheckedCreateWithoutLikedByInput>
  }

  export type UserCreateWithoutContentLikesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContentLikesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContentLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContentLikesInput, UserUncheckedCreateWithoutContentLikesInput>
  }

  export type ContentUpsertWithoutLikedByInput = {
    update: XOR<ContentUpdateWithoutLikedByInput, ContentUncheckedUpdateWithoutLikedByInput>
    create: XOR<ContentCreateWithoutLikedByInput, ContentUncheckedCreateWithoutLikedByInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutLikedByInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutLikedByInput, ContentUncheckedUpdateWithoutLikedByInput>
  }

  export type ContentUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContentNestedInput
    moderator?: UserUpdateOneWithoutModeratedContentNestedInput
    sharedEntries?: ContentShareUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedEntries?: ContentShareUncheckedUpdateManyWithoutContentNestedInput
  }

  export type UserUpsertWithoutContentLikesInput = {
    update: XOR<UserUpdateWithoutContentLikesInput, UserUncheckedUpdateWithoutContentLikesInput>
    create: XOR<UserCreateWithoutContentLikesInput, UserUncheckedCreateWithoutContentLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContentLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContentLikesInput, UserUncheckedUpdateWithoutContentLikesInput>
  }

  export type UserUpdateWithoutContentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentCreateWithoutSharedEntriesInput = {
    id?: string
    contentId?: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContentInput
    moderator?: UserCreateNestedOneWithoutModeratedContentInput
    likedBy?: ContentLikeCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutSharedEntriesInput = {
    id?: string
    contentId?: string
    userId: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likedBy?: ContentLikeUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutSharedEntriesInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutSharedEntriesInput, ContentUncheckedCreateWithoutSharedEntriesInput>
  }

  export type UserCreateWithoutSharedContentInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedContentInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedContentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedContentInput, UserUncheckedCreateWithoutSharedContentInput>
  }

  export type UserCreateWithoutReceivedSharesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedSharesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedSharesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
  }

  export type ContentUpsertWithoutSharedEntriesInput = {
    update: XOR<ContentUpdateWithoutSharedEntriesInput, ContentUncheckedUpdateWithoutSharedEntriesInput>
    create: XOR<ContentCreateWithoutSharedEntriesInput, ContentUncheckedCreateWithoutSharedEntriesInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutSharedEntriesInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutSharedEntriesInput, ContentUncheckedUpdateWithoutSharedEntriesInput>
  }

  export type ContentUpdateWithoutSharedEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContentNestedInput
    moderator?: UserUpdateOneWithoutModeratedContentNestedInput
    likedBy?: ContentLikeUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutSharedEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: ContentLikeUncheckedUpdateManyWithoutContentNestedInput
  }

  export type UserUpsertWithoutSharedContentInput = {
    update: XOR<UserUpdateWithoutSharedContentInput, UserUncheckedUpdateWithoutSharedContentInput>
    create: XOR<UserCreateWithoutSharedContentInput, UserUncheckedCreateWithoutSharedContentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedContentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedContentInput, UserUncheckedUpdateWithoutSharedContentInput>
  }

  export type UserUpdateWithoutSharedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedSharesInput = {
    update: XOR<UserUpdateWithoutReceivedSharesInput, UserUncheckedUpdateWithoutReceivedSharesInput>
    create: XOR<UserCreateWithoutReceivedSharesInput, UserUncheckedCreateWithoutReceivedSharesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedSharesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedSharesInput, UserUncheckedUpdateWithoutReceivedSharesInput>
  }

  export type UserUpdateWithoutReceivedSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    nfts?: UserNFTCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    memberships?: ClanMemberCreateNestedManyWithoutUserInput
    territories?: TerritoryCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeCreateNestedManyWithoutDefenderInput
    ledClans?: ClanCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    venues?: VenueCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemCreateNestedManyWithoutUserInput
    feedback?: FeedbackCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackCreateNestedManyWithoutResolverInput
    content?: ContentCreateNestedManyWithoutUserInput
    moderatedContent?: ContentCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    role?: $Enums.UserRole
    isBanned?: boolean
    avatarUrl?: string | null
    dojoCoinBalance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    nfts?: UserNFTUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    memberships?: ClanMemberUncheckedCreateNestedManyWithoutUserInput
    territories?: TerritoryUncheckedCreateNestedManyWithoutOwnerInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutUserInput
    challengesAsChallenger?: ChallengeUncheckedCreateNestedManyWithoutChallengerInput
    challengesAsDefender?: ChallengeUncheckedCreateNestedManyWithoutDefenderInput
    ledClans?: ClanUncheckedCreateNestedManyWithoutLeaderInput
    matchesAsPlayerA?: MatchUncheckedCreateNestedManyWithoutPlayerAInput
    matchesAsPlayerB?: MatchUncheckedCreateNestedManyWithoutPlayerBInput
    tournaments?: TournamentParticipantUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    venues?: VenueUncheckedCreateNestedManyWithoutOwnerInput
    friendshipsAsRequester?: FriendshipUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsAsAddressee?: FriendshipUncheckedCreateNestedManyWithoutAddresseeInput
    sentMessages?: DirectMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: DirectMessageUncheckedCreateNestedManyWithoutReceiverInput
    activityEvents?: ActivityEventUncheckedCreateNestedManyWithoutUserInput
    gameSessions?: GameSessionUncheckedCreateNestedManyWithoutPlayerInput
    shadowRuns?: ShadowRunUncheckedCreateNestedManyWithoutPlayerInput
    dojoCheckIns?: DojoCheckInUncheckedCreateNestedManyWithoutUserInput
    inventoryItems?: UserInventoryItemUncheckedCreateNestedManyWithoutUserInput
    feedback?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    resolvedFeedback?: FeedbackUncheckedCreateNestedManyWithoutResolverInput
    content?: ContentUncheckedCreateNestedManyWithoutUserInput
    moderatedContent?: ContentUncheckedCreateNestedManyWithoutModeratorInput
    contentLikes?: ContentLikeUncheckedCreateNestedManyWithoutUserInput
    sharedContent?: ContentShareUncheckedCreateNestedManyWithoutUserInput
    receivedShares?: ContentShareUncheckedCreateNestedManyWithoutSharedWithInput
    communityItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutCreatorInput
    reviewedItems?: CommunityCosmeticItemUncheckedCreateNestedManyWithoutReviewerInput
    cosmeticLikes?: CosmeticItemLikeUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUpdateManyWithoutUserNestedInput
    territories?: TerritoryUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    venues?: VenueUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUpdateManyWithoutResolverNestedInput
    content?: ContentUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    nfts?: UserNFTUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    memberships?: ClanMemberUncheckedUpdateManyWithoutUserNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutOwnerNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutUserNestedInput
    challengesAsChallenger?: ChallengeUncheckedUpdateManyWithoutChallengerNestedInput
    challengesAsDefender?: ChallengeUncheckedUpdateManyWithoutDefenderNestedInput
    ledClans?: ClanUncheckedUpdateManyWithoutLeaderNestedInput
    matchesAsPlayerA?: MatchUncheckedUpdateManyWithoutPlayerANestedInput
    matchesAsPlayerB?: MatchUncheckedUpdateManyWithoutPlayerBNestedInput
    tournaments?: TournamentParticipantUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    venues?: VenueUncheckedUpdateManyWithoutOwnerNestedInput
    friendshipsAsRequester?: FriendshipUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsAsAddressee?: FriendshipUncheckedUpdateManyWithoutAddresseeNestedInput
    sentMessages?: DirectMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: DirectMessageUncheckedUpdateManyWithoutReceiverNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutUserNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutPlayerNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutPlayerNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutUserNestedInput
    inventoryItems?: UserInventoryItemUncheckedUpdateManyWithoutUserNestedInput
    feedback?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    resolvedFeedback?: FeedbackUncheckedUpdateManyWithoutResolverNestedInput
    content?: ContentUncheckedUpdateManyWithoutUserNestedInput
    moderatedContent?: ContentUncheckedUpdateManyWithoutModeratorNestedInput
    contentLikes?: ContentLikeUncheckedUpdateManyWithoutUserNestedInput
    sharedContent?: ContentShareUncheckedUpdateManyWithoutUserNestedInput
    receivedShares?: ContentShareUncheckedUpdateManyWithoutSharedWithNestedInput
    communityItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorNestedInput
    reviewedItems?: CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerNestedInput
    cosmeticLikes?: CosmeticItemLikeUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WalletCreateManyUserInput = {
    id?: string
    chain: string
    address: string
    createdAt?: Date | string
  }

  export type UserNFTCreateManyUserInput = {
    id?: string
    nftId: string
    createdAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    earnedAt?: Date | string
  }

  export type ClanMemberCreateManyUserInput = {
    id?: string
    clanId: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
  }

  export type TerritoryCreateManyOwnerInput = {
    id?: string
    venueId: string
    name?: string
    clanId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckInCreateManyUserInput = {
    id?: string
    venueId: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
  }

  export type ChallengeCreateManyChallengerInput = {
    id?: string
    defenderId: string
    venueId?: string | null
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeCreateManyDefenderInput = {
    id?: string
    challengerId: string
    venueId?: string | null
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClanCreateManyLeaderInput = {
    id?: string
    name: string
    description?: string | null
    tag: string
    maxMembers?: number
    dojoCoinBalance?: number
    seasonalPoints?: number
    bannerUrl?: string | null
    color?: string
    level?: number
    experience?: number
    reputation?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyPlayerAInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyPlayerBInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentParticipantCreateManyUserInput = {
    id?: string
    tournamentId: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    amount: number
    currency?: string
    type: $Enums.TxType
    metadata: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    message?: string | null
    payload: string
    read?: boolean
    isRead?: boolean
    recipientId?: string | null
    title?: string | null
    priority?: string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    action: string
    target?: string | null
    metadata: string
    ts?: Date | string
  }

  export type VenueCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    controllingClanId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendshipCreateManyRequesterInput = {
    id?: string
    addresseeId: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendshipCreateManyAddresseeInput = {
    id?: string
    requesterId: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateManySenderInput = {
    id?: string
    receiverId: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type DirectMessageCreateManyReceiverInput = {
    id?: string
    senderId: string
    content: string
    read?: boolean
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ActivityEventCreateManyUserInput = {
    id?: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameSessionCreateManyPlayerInput = {
    id?: string
    gameId?: string | null
    venueId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShadowRunCreateManyPlayerInput = {
    id?: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    initiatingClanId?: string | null
    targetVenueId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DojoCheckInCreateManyUserInput = {
    id?: string
    venueId: string
    createdAt?: Date | string
  }

  export type UserInventoryItemCreateManyUserInput = {
    id?: string
    marketplaceItemId: string
    createdAt?: Date | string
  }

  export type FeedbackCreateManyUserInput = {
    id?: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
  }

  export type FeedbackCreateManyResolverInput = {
    id?: string
    userId: string
    message: string
    category: $Enums.FeedbackCategory
    status?: $Enums.FeedbackStatus
    priority?: $Enums.FeedbackPriority
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ContentCreateManyUserInput = {
    id?: string
    contentId?: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentCreateManyModeratorInput = {
    id?: string
    contentId?: string
    userId: string
    title: string
    description?: string | null
    contentType: $Enums.ContentType
    fileUrl?: string | null
    thumbnailUrl?: string | null
    status?: $Enums.ContentStatus
    visibility?: $Enums.ContentVisibility
    metadata?: string
    tags?: string
    likes?: number
    shares?: number
    views?: number
    moderatedAt?: Date | string | null
    moderationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentLikeCreateManyUserInput = {
    id?: string
    contentId: string
    likes?: number
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    tokenHash: string
    deviceId?: string | null
    deviceInfo?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentShareCreateManyUserInput = {
    id?: string
    contentId: string
    sharedWithId: string
    createdAt?: Date | string
  }

  export type ContentShareCreateManySharedWithInput = {
    id?: string
    contentId: string
    userId: string
    createdAt?: Date | string
  }

  export type CommunityCosmeticItemCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    approvedItemId?: string | null
    reviewerId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityCosmeticItemCreateManyReviewerInput = {
    id?: string
    creatorId: string
    title: string
    description?: string | null
    category: $Enums.CosmeticCategory
    designFileUrl?: string | null
    previewImageUrl?: string | null
    status?: $Enums.SubmissionStatus
    rejectionReason?: string | null
    approvedItemId?: string | null
    reviewedAt?: Date | string | null
    metadata?: string
    tags?: string
    likes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CosmeticItemLikeCreateManyUserInput = {
    id?: string
    cosmeticItemId: string
    createdAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNFTUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nft?: NFTUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserNFTUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNFTUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clan?: ClanUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ClanMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutTerritoriesNestedInput
    clan?: ClanUpdateOneWithoutTerritoriesNestedInput
    events?: TerritoryEventUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TerritoryEventUncheckedUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutCheckInsNestedInput
  }

  export type CheckInUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUpdateWithoutChallengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defender?: UserUpdateOneRequiredWithoutChallengesAsDefenderNestedInput
    venue?: VenueUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutChallengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyWithoutChallengerInput = {
    id?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUpdateWithoutDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenger?: UserUpdateOneRequiredWithoutChallengesAsChallengerNestedInput
    venue?: VenueUpdateOneWithoutChallengesNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengerId?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyWithoutDefenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengerId?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanUpdateWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClanMemberUpdateManyWithoutClanNestedInput
    territories?: TerritoryUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanUncheckedUpdateWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ClanMemberUncheckedUpdateManyWithoutClanNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutClanNestedInput
    controlledVenues?: VenueUncheckedUpdateManyWithoutControllingClanNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutClanNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutInitiatingClanNestedInput
  }

  export type ClanUncheckedUpdateManyWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: StringFieldUpdateOperationsInput | string
    maxMembers?: IntFieldUpdateOperationsInput | number
    dojoCoinBalance?: IntFieldUpdateOperationsInput | number
    seasonalPoints?: IntFieldUpdateOperationsInput | number
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    reputation?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneWithoutMatchesNestedInput
    venue?: VenueUpdateOneWithoutMatchesNestedInput
    table?: TableUpdateOneWithoutMatchesNestedInput
    playerB?: UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput
    events?: MatchEventUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: MatchEventUncheckedUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneWithoutMatchesNestedInput
    venue?: VenueUpdateOneWithoutMatchesNestedInput
    table?: TableUpdateOneWithoutMatchesNestedInput
    playerA?: UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput
    events?: MatchEventUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: MatchEventUncheckedUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type TournamentParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    type?: EnumTxTypeFieldUpdateOperationsInput | $Enums.TxType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    controllingClan?: ClanUpdateOneWithoutControlledVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    controllingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressee?: UserUpdateOneRequiredWithoutFriendshipsAsAddresseeNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutFriendshipsAsRequesterNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutActivityEventsNestedInput
    match?: MatchUpdateOneWithoutActivityEventsNestedInput
    tournament?: TournamentUpdateOneWithoutActivityEventsNestedInput
    clan?: ClanUpdateOneWithoutActivityEventsNestedInput
  }

  export type ActivityEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initiatingClan?: ClanUpdateOneWithoutShadowRunsNestedInput
    targetVenue?: VenueUpdateOneWithoutShadowRunsNestedInput
  }

  export type ShadowRunUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVenueId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVenueId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DojoCheckInUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutDojoCheckInsNestedInput
  }

  export type DojoCheckInUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DojoCheckInUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplaceItem?: MarketplaceItemUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type UserInventoryItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolver?: UserUpdateOneWithoutResolvedFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackUpdateWithoutResolverInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutResolverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedbackUncheckedUpdateManyWithoutResolverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    moderator?: UserUpdateOneWithoutModeratedContentNestedInput
    likedBy?: ContentLikeUpdateManyWithoutContentNestedInput
    sharedEntries?: ContentShareUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: ContentLikeUncheckedUpdateManyWithoutContentNestedInput
    sharedEntries?: ContentShareUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUpdateWithoutModeratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContentNestedInput
    likedBy?: ContentLikeUpdateManyWithoutContentNestedInput
    sharedEntries?: ContentShareUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutModeratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: ContentLikeUncheckedUpdateManyWithoutContentNestedInput
    sharedEntries?: ContentShareUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateManyWithoutModeratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    visibility?: EnumContentVisibilityFieldUpdateOperationsInput | $Enums.ContentVisibility
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type ContentLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentUpdateOneRequiredWithoutSharedEntriesNestedInput
    sharedWith?: UserUpdateOneRequiredWithoutReceivedSharesNestedInput
  }

  export type ContentShareUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    sharedWithId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    sharedWithId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentUpdateOneRequiredWithoutSharedEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutSharedContentNestedInput
  }

  export type ContentShareUncheckedUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareUncheckedUpdateManyWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCosmeticItemUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedItem?: MarketplaceItemUpdateOneWithoutCommunityItemNestedInput
    reviewer?: UserUpdateOneWithoutReviewedItemsNestedInput
    likedBy?: CosmeticItemLikeUpdateManyWithoutCosmeticItemNestedInput
  }

  export type CommunityCosmeticItemUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedItemId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: CosmeticItemLikeUncheckedUpdateManyWithoutCosmeticItemNestedInput
  }

  export type CommunityCosmeticItemUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedItemId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCosmeticItemUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCommunityItemsNestedInput
    approvedItem?: MarketplaceItemUpdateOneWithoutCommunityItemNestedInput
    likedBy?: CosmeticItemLikeUpdateManyWithoutCosmeticItemNestedInput
  }

  export type CommunityCosmeticItemUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedItemId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likedBy?: CosmeticItemLikeUncheckedUpdateManyWithoutCosmeticItemNestedInput
  }

  export type CommunityCosmeticItemUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCosmeticCategoryFieldUpdateOperationsInput | $Enums.CosmeticCategory
    designFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    previewImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedItemId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CosmeticItemLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cosmeticItem?: CommunityCosmeticItemUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type CosmeticItemLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cosmeticItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CosmeticItemLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cosmeticItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableCreateManyVenueInput = {
    id?: string
    name: string
    status?: $Enums.TableStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentCreateManyVenueInput = {
    id?: string
    name: string
    status?: $Enums.TournamentStatus
    startTime: Date | string
    endTime?: Date | string | null
    isSponsored?: boolean
    sponsoredBy?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    sponsorBannerUrl?: string | null
    maxPlayers?: number
    entryFee?: number
    rewards?: string | null
    prizePool?: number
    format?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerritoryCreateManyVenueInput = {
    id?: string
    name?: string
    ownerId?: string | null
    clanId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckInCreateManyVenueInput = {
    id?: string
    userId: string
    via?: $Enums.CheckInMethod
    createdAt?: Date | string
  }

  export type ChallengeCreateManyVenueInput = {
    id?: string
    challengerId: string
    defenderId: string
    status?: $Enums.ChallengeStatus
    stakeCoins?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyVenueInput = {
    id?: string
    tournamentId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateManyVenueInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    matchId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueQuestCreateManyVenueInput = {
    id?: string
    title: string
    description: string
    reward?: string
    rewardDojoCoins?: number
    active?: boolean
    isActive?: boolean
    requirements?: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueSpecialCreateManyVenueInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    isActive?: boolean
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DojoCheckInCreateManyVenueInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ShadowRunCreateManyTargetVenueInput = {
    id?: string
    playerId: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    initiatingClanId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameSessionCreateManyVenueInput = {
    id?: string
    playerId: string
    gameId?: string | null
    status?: string
    gameType?: string | null
    rules: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    playerIds: string
    currentPlayerId?: string | null
    ballStates: string
    fouls: string
    score: string
    events: string
    totalShots?: number
    totalFouls?: number
    totalFrames?: number
    lastUpdated?: Date | string | null
    winnerId?: string | null
    data: JsonNullValueInput | InputJsonValue
    frameCount?: number
    shotCount?: number
    foulCount?: number
    shots: string
    statistics: string
    aiCommentary: string
    matchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matches?: MatchUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTableStatusFieldUpdateOperationsInput | $Enums.TableStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TournamentParticipantUpdateManyWithoutTournamentNestedInput
    matches?: MatchUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TournamentParticipantUncheckedUpdateManyWithoutTournamentNestedInput
    matches?: MatchUncheckedUpdateManyWithoutTournamentNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsoredBy?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sponsorBannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizePool?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutTerritoriesNestedInput
    clan?: ClanUpdateOneWithoutTerritoriesNestedInput
    events?: TerritoryEventUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TerritoryEventUncheckedUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCheckInsNestedInput
  }

  export type CheckInUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    via?: EnumCheckInMethodFieldUpdateOperationsInput | $Enums.CheckInMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenger?: UserUpdateOneRequiredWithoutChallengesAsChallengerNestedInput
    defender?: UserUpdateOneRequiredWithoutChallengesAsDefenderNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengerId?: StringFieldUpdateOperationsInput | string
    defenderId?: StringFieldUpdateOperationsInput | string
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    stakeCoins?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneWithoutMatchesNestedInput
    table?: TableUpdateOneWithoutMatchesNestedInput
    playerA?: UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput
    playerB?: UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput
    events?: MatchEventUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: MatchEventUncheckedUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityEventsNestedInput
    match?: MatchUpdateOneWithoutActivityEventsNestedInput
    tournament?: TournamentUpdateOneWithoutActivityEventsNestedInput
    clan?: ClanUpdateOneWithoutActivityEventsNestedInput
  }

  export type ActivityEventUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueQuestUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    rewardDojoCoins?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requirements?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueQuestUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    rewardDojoCoins?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requirements?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueQuestUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    rewardDojoCoins?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requirements?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueSpecialUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueSpecialUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueSpecialUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DojoCheckInUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDojoCheckInsNestedInput
  }

  export type DojoCheckInUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DojoCheckInUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunUpdateWithoutTargetVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutShadowRunsNestedInput
    initiatingClan?: ClanUpdateOneWithoutShadowRunsNestedInput
  }

  export type ShadowRunUncheckedUpdateWithoutTargetVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunUncheckedUpdateManyWithoutTargetVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiatingClanId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutGameSessionsNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    gameType?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    playerIds?: StringFieldUpdateOperationsInput | string
    currentPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    ballStates?: StringFieldUpdateOperationsInput | string
    fouls?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    totalShots?: IntFieldUpdateOperationsInput | number
    totalFouls?: IntFieldUpdateOperationsInput | number
    totalFrames?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    frameCount?: IntFieldUpdateOperationsInput | number
    shotCount?: IntFieldUpdateOperationsInput | number
    foulCount?: IntFieldUpdateOperationsInput | number
    shots?: StringFieldUpdateOperationsInput | string
    statistics?: StringFieldUpdateOperationsInput | string
    aiCommentary?: StringFieldUpdateOperationsInput | string
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateManyTableInput = {
    id?: string
    tournamentId?: string | null
    venueId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: TournamentUpdateOneWithoutMatchesNestedInput
    venue?: VenueUpdateOneWithoutMatchesNestedInput
    playerA?: UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput
    playerB?: UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput
    events?: MatchEventUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: MatchEventUncheckedUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanMemberCreateManyClanInput = {
    id?: string
    userId: string
    role?: $Enums.ClanRole
    joinedAt?: Date | string
  }

  export type TerritoryCreateManyClanInput = {
    id?: string
    venueId: string
    name?: string
    ownerId?: string | null
    level?: number
    defenseScore?: number
    resources?: string
    strategicValue?: number
    resourceRate?: string
    lastTickAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueCreateManyControllingClanInput = {
    id?: string
    name: string
    description?: string | null
    lat: number
    lng: number
    address?: string | null
    ownerId?: string | null
    incomeModifier?: number
    defenseLevel?: number
    status?: string
    photos?: string
    rating?: number
    features?: string
    tables?: number
    reviews?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateManyClanInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    tournamentId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShadowRunCreateManyInitiatingClanInput = {
    id?: string
    playerId: string
    type: string
    status?: string
    cost: number
    reward?: number | null
    completedAt?: Date | string | null
    targetVenueId?: string | null
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClanMemberUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type ClanMemberUncheckedUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanMemberUncheckedUpdateManyWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumClanRoleFieldUpdateOperationsInput | $Enums.ClanRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutTerritoriesNestedInput
    owner?: UserUpdateOneWithoutTerritoriesNestedInput
    events?: TerritoryEventUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TerritoryEventUncheckedUpdateManyWithoutTerritoryNestedInput
  }

  export type TerritoryUncheckedUpdateManyWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    defenseScore?: IntFieldUpdateOperationsInput | number
    resources?: StringFieldUpdateOperationsInput | string
    strategicValue?: IntFieldUpdateOperationsInput | number
    resourceRate?: StringFieldUpdateOperationsInput | string
    lastTickAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUpdateWithoutControllingClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutVenuesNestedInput
    tablesList?: TableUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUpdateManyWithoutVenueNestedInput
    matches?: MatchUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutControllingClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tablesList?: TableUncheckedUpdateManyWithoutVenueNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutVenueNestedInput
    territories?: TerritoryUncheckedUpdateManyWithoutVenueNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeUncheckedUpdateManyWithoutVenueNestedInput
    matches?: MatchUncheckedUpdateManyWithoutVenueNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutVenueNestedInput
    quests?: VenueQuestUncheckedUpdateManyWithoutVenueNestedInput
    specials?: VenueSpecialUncheckedUpdateManyWithoutVenueNestedInput
    dojoCheckIns?: DojoCheckInUncheckedUpdateManyWithoutVenueNestedInput
    shadowRuns?: ShadowRunUncheckedUpdateManyWithoutTargetVenueNestedInput
    gameSessions?: GameSessionUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateManyWithoutControllingClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: FloatFieldUpdateOperationsInput | number
    lng?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    incomeModifier?: FloatFieldUpdateOperationsInput | number
    defenseLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    photos?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    features?: StringFieldUpdateOperationsInput | string
    tables?: IntFieldUpdateOperationsInput | number
    reviews?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityEventsNestedInput
    venue?: VenueUpdateOneWithoutActivityEventsNestedInput
    match?: MatchUpdateOneWithoutActivityEventsNestedInput
    tournament?: TournamentUpdateOneWithoutActivityEventsNestedInput
  }

  export type ActivityEventUncheckedUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUncheckedUpdateManyWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunUpdateWithoutInitiatingClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutShadowRunsNestedInput
    targetVenue?: VenueUpdateOneWithoutShadowRunsNestedInput
  }

  export type ShadowRunUncheckedUpdateWithoutInitiatingClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetVenueId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShadowRunUncheckedUpdateManyWithoutInitiatingClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetVenueId?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryEventCreateManyTerritoryInput = {
    id?: string
    type: $Enums.TerritoryEventType
    metadata: string
    createdAt?: Date | string
  }

  export type TerritoryEventUpdateWithoutTerritoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTerritoryEventTypeFieldUpdateOperationsInput | $Enums.TerritoryEventType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryEventUncheckedUpdateWithoutTerritoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTerritoryEventTypeFieldUpdateOperationsInput | $Enums.TerritoryEventType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerritoryEventUncheckedUpdateManyWithoutTerritoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTerritoryEventTypeFieldUpdateOperationsInput | $Enums.TerritoryEventType
    metadata?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentParticipantCreateManyTournamentInput = {
    id?: string
    userId: string
    seed?: number | null
    finalRank?: number | null
    createdAt?: Date | string
  }

  export type MatchCreateManyTournamentInput = {
    id?: string
    venueId?: string | null
    tableId?: string | null
    playerAId: string
    playerBId: string
    winnerId?: string | null
    loserId?: string | null
    status?: $Enums.MatchStatus
    scoreA?: number
    scoreB?: number
    round?: number | null
    wager?: number
    aiAnalysisJson?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityEventCreateManyTournamentInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    matchId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentParticipantUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTournamentsNestedInput
  }

  export type TournamentParticipantUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentParticipantUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seed?: NullableIntFieldUpdateOperationsInput | number | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutMatchesNestedInput
    table?: TableUpdateOneWithoutMatchesNestedInput
    playerA?: UserUpdateOneRequiredWithoutMatchesAsPlayerANestedInput
    playerB?: UserUpdateOneRequiredWithoutMatchesAsPlayerBNestedInput
    events?: MatchEventUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: MatchEventUncheckedUpdateManyWithoutMatchNestedInput
    activityEvents?: ActivityEventUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    playerAId?: StringFieldUpdateOperationsInput | string
    playerBId?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    loserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    scoreA?: IntFieldUpdateOperationsInput | number
    scoreB?: IntFieldUpdateOperationsInput | number
    round?: NullableIntFieldUpdateOperationsInput | number | null
    wager?: IntFieldUpdateOperationsInput | number
    aiAnalysisJson?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityEventsNestedInput
    venue?: VenueUpdateOneWithoutActivityEventsNestedInput
    match?: MatchUpdateOneWithoutActivityEventsNestedInput
    clan?: ClanUpdateOneWithoutActivityEventsNestedInput
  }

  export type ActivityEventUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    matchId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchEventCreateManyMatchInput = {
    id?: string
    type: $Enums.MatchEventType
    payload: string
    ts?: Date | string
  }

  export type ActivityEventCreateManyMatchInput = {
    id?: string
    userId: string
    type: string
    message?: string | null
    data: string
    venueId?: string | null
    tournamentId?: string | null
    clanId?: string | null
    metadata?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchEventUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchEventTypeFieldUpdateOperationsInput | $Enums.MatchEventType
    payload?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchEventUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchEventTypeFieldUpdateOperationsInput | $Enums.MatchEventType
    payload?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchEventUncheckedUpdateManyWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchEventTypeFieldUpdateOperationsInput | $Enums.MatchEventType
    payload?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityEventsNestedInput
    venue?: VenueUpdateOneWithoutActivityEventsNestedInput
    tournament?: TournamentUpdateOneWithoutActivityEventsNestedInput
    clan?: ClanUpdateOneWithoutActivityEventsNestedInput
  }

  export type ActivityEventUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityEventUncheckedUpdateManyWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    data?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    clanId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNFTCreateManyNftInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserNFTUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNftsNestedInput
  }

  export type UserNFTUncheckedUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNFTUncheckedUpdateManyWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemCreateManyMarketplaceItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserInventoryItemUpdateWithoutMarketplaceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type UserInventoryItemUncheckedUpdateWithoutMarketplaceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryItemUncheckedUpdateManyWithoutMarketplaceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CosmeticItemLikeCreateManyCosmeticItemInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CosmeticItemLikeUpdateWithoutCosmeticItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCosmeticLikesNestedInput
  }

  export type CosmeticItemLikeUncheckedUpdateWithoutCosmeticItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CosmeticItemLikeUncheckedUpdateManyWithoutCosmeticItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentLikeCreateManyContentInput = {
    id?: string
    userId: string
    likes?: number
    createdAt?: Date | string
  }

  export type ContentShareCreateManyContentInput = {
    id?: string
    userId: string
    sharedWithId: string
    createdAt?: Date | string
  }

  export type ContentLikeUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContentLikesNestedInput
  }

  export type ContentLikeUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentLikeUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedContentNestedInput
    sharedWith?: UserUpdateOneRequiredWithoutReceivedSharesNestedInput
  }

  export type ContentShareUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharedWithId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentShareUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sharedWithId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueCountOutputTypeDefaultArgs instead
     */
    export type VenueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TableCountOutputTypeDefaultArgs instead
     */
    export type TableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClanCountOutputTypeDefaultArgs instead
     */
    export type ClanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TerritoryCountOutputTypeDefaultArgs instead
     */
    export type TerritoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TerritoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentCountOutputTypeDefaultArgs instead
     */
    export type TournamentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchCountOutputTypeDefaultArgs instead
     */
    export type MatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NFTCountOutputTypeDefaultArgs instead
     */
    export type NFTCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NFTCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementCountOutputTypeDefaultArgs instead
     */
    export type AchievementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketplaceItemCountOutputTypeDefaultArgs instead
     */
    export type MarketplaceItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityCosmeticItemCountOutputTypeDefaultArgs instead
     */
    export type CommunityCosmeticItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityCosmeticItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentCountOutputTypeDefaultArgs instead
     */
    export type ContentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingsDefaultArgs instead
     */
    export type UserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueDefaultArgs instead
     */
    export type VenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TableDefaultArgs instead
     */
    export type TableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheckInDefaultArgs instead
     */
    export type CheckInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheckInDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClanDefaultArgs instead
     */
    export type ClanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClanMemberDefaultArgs instead
     */
    export type ClanMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClanMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TerritoryDefaultArgs instead
     */
    export type TerritoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TerritoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TerritoryEventDefaultArgs instead
     */
    export type TerritoryEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TerritoryEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentDefaultArgs instead
     */
    export type TournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TournamentParticipantDefaultArgs instead
     */
    export type TournamentParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TournamentParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchDefaultArgs instead
     */
    export type MatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchEventDefaultArgs instead
     */
    export type MatchEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeDefaultArgs instead
     */
    export type ChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletDefaultArgs instead
     */
    export type WalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NFTDefaultArgs instead
     */
    export type NFTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NFTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserNFTDefaultArgs instead
     */
    export type UserNFTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserNFTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FriendshipDefaultArgs instead
     */
    export type FriendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FriendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DirectMessageDefaultArgs instead
     */
    export type DirectMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DirectMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityEventDefaultArgs instead
     */
    export type ActivityEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueQuestDefaultArgs instead
     */
    export type VenueQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueQuestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameSessionDefaultArgs instead
     */
    export type GameSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketplaceItemDefaultArgs instead
     */
    export type MarketplaceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketplaceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityCosmeticItemDefaultArgs instead
     */
    export type CommunityCosmeticItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityCosmeticItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CosmeticItemLikeDefaultArgs instead
     */
    export type CosmeticItemLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CosmeticItemLikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeasonDefaultArgs instead
     */
    export type SeasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeasonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShadowRunDefaultArgs instead
     */
    export type ShadowRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShadowRunDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DojoCheckInDefaultArgs instead
     */
    export type DojoCheckInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DojoCheckInDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueSpecialDefaultArgs instead
     */
    export type VenueSpecialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueSpecialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserInventoryItemDefaultArgs instead
     */
    export type UserInventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserInventoryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentDefaultArgs instead
     */
    export type ContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentLikeDefaultArgs instead
     */
    export type ContentLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentLikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentShareDefaultArgs instead
     */
    export type ContentShareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentShareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}