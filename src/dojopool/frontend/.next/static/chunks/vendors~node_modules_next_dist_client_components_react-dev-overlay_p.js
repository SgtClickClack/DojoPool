"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors~node_modules_next_dist_client_components_react-dev-overlay_p"],{

/***/ "./node_modules/next/dist/client/components/react-dev-overlay/pages/bus.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/pages/bus.js ***!
  \*********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  emit: function emit() {\n    return _emit;\n  },\n  off: function off() {\n    return _off;\n  },\n  on: function on() {\n    return _on;\n  }\n});\nvar handlers = new Set();\nvar queue = [];\nfunction drain() {\n  // Draining should never happen synchronously in case multiple handlers are\n  // registered.\n  setTimeout(function () {\n    var _loop = function _loop() {\n      var ev = queue.shift();\n      handlers.forEach(function (handler) {\n        return handler(ev);\n      });\n    };\n    while (\n    // Until we are out of events:\n    Boolean(queue.length) &&\n    // Or, if all handlers removed themselves as a result of handling the\n    // event(s)\n    Boolean(handlers.size)) {\n      _loop();\n    }\n  }, 1);\n}\nfunction _emit(ev) {\n  queue.push(Object.freeze(_objectSpread({}, ev)));\n  drain();\n}\nfunction _on(fn) {\n  if (handlers.has(fn)) {\n    return false;\n  }\n  handlers.add(fn);\n  drain();\n  return true;\n}\nfunction _off(fn) {\n  if (handlers.has(fn)) {\n    handlers[\"delete\"](fn);\n    return true;\n  }\n  return false;\n}\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL2J1cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFBQSxJQUFBQSxlQUFBLEdBQUFDLG1CQUFBO0FBQUEsU0FBQUMsUUFBQUMsQ0FBQSxFQUFBQyxDQUFBLFFBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxJQUFBLENBQUFKLENBQUEsT0FBQUcsTUFBQSxDQUFBRSxxQkFBQSxRQUFBQyxDQUFBLEdBQUFILE1BQUEsQ0FBQUUscUJBQUEsQ0FBQUwsQ0FBQSxHQUFBQyxDQUFBLEtBQUFLLENBQUEsR0FBQUEsQ0FBQSxDQUFBQyxNQUFBLFdBQUFOLENBQUEsV0FBQUUsTUFBQSxDQUFBSyx3QkFBQSxDQUFBUixDQUFBLEVBQUFDLENBQUEsRUFBQVEsVUFBQSxPQUFBUCxDQUFBLENBQUFRLElBQUEsQ0FBQUMsS0FBQSxDQUFBVCxDQUFBLEVBQUFJLENBQUEsWUFBQUosQ0FBQTtBQUFBLFNBQUFVLGNBQUFaLENBQUEsYUFBQUMsQ0FBQSxNQUFBQSxDQUFBLEdBQUFZLFNBQUEsQ0FBQUMsTUFBQSxFQUFBYixDQUFBLFVBQUFDLENBQUEsV0FBQVcsU0FBQSxDQUFBWixDQUFBLElBQUFZLFNBQUEsQ0FBQVosQ0FBQSxRQUFBQSxDQUFBLE9BQUFGLE9BQUEsQ0FBQUksTUFBQSxDQUFBRCxDQUFBLE9BQUFhLE9BQUEsV0FBQWQsQ0FBQSxJQUFBSixlQUFBLENBQUFHLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBLENBQUFELENBQUEsU0FBQUUsTUFBQSxDQUFBYSx5QkFBQSxHQUFBYixNQUFBLENBQUFjLGdCQUFBLENBQUFqQixDQUFBLEVBQUFHLE1BQUEsQ0FBQWEseUJBQUEsQ0FBQWQsQ0FBQSxLQUFBSCxPQUFBLENBQUFJLE1BQUEsQ0FBQUQsQ0FBQSxHQUFBYSxPQUFBLFdBQUFkLENBQUEsSUFBQUUsTUFBQSxDQUFBZSxjQUFBLENBQUFsQixDQUFBLEVB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TyxHQUFHQSxPQUFPLFdBQVE7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9wYWdlcy9idXMuanM/Y2QyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVtaXQ6IG51bGwsXG4gICAgb2ZmOiBudWxsLFxuICAgIG9uOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZW1pdDtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvZmY7XG4gICAgfSxcbiAgICBvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvbjtcbiAgICB9XG59KTtcbmxldCBoYW5kbGVycyA9IG5ldyBTZXQoKTtcbmxldCBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgLy8gRHJhaW5pbmcgc2hvdWxkIG5ldmVyIGhhcHBlbiBzeW5jaHJvbm91c2x5IGluIGNhc2UgbXVsdGlwbGUgaGFuZGxlcnMgYXJlXG4gICAgLy8gcmVnaXN0ZXJlZC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSgvLyBVbnRpbCB3ZSBhcmUgb3V0IG9mIGV2ZW50czpcbiAgICAgICAgQm9vbGVhbihxdWV1ZS5sZW5ndGgpICYmIC8vIE9yLCBpZiBhbGwgaGFuZGxlcnMgcmVtb3ZlZCB0aGVtc2VsdmVzIGFzIGEgcmVzdWx0IG9mIGhhbmRsaW5nIHRoZVxuICAgICAgICAvLyBldmVudChzKVxuICAgICAgICBCb29sZWFuKGhhbmRsZXJzLnNpemUpKXtcbiAgICAgICAgICAgIGNvbnN0IGV2ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpPT5oYW5kbGVyKGV2KSk7XG4gICAgICAgIH1cbiAgICB9LCAxKTtcbn1cbmZ1bmN0aW9uIGVtaXQoZXYpIHtcbiAgICBxdWV1ZS5wdXNoKE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5ldlxuICAgIH0pKTtcbiAgICBkcmFpbigpO1xufVxuZnVuY3Rpb24gb24oZm4pIHtcbiAgICBpZiAoaGFuZGxlcnMuaGFzKGZuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhbmRsZXJzLmFkZChmbik7XG4gICAgZHJhaW4oKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9mZihmbikge1xuICAgIGlmIChoYW5kbGVycy5oYXMoZm4pKSB7XG4gICAgICAgIGhhbmRsZXJzLmRlbGV0ZShmbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1cy5qcy5tYXAiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5IiwicmVxdWlyZSIsIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJlbWl0Iiwib2ZmIiwib24iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImhhbmRsZXJzIiwiU2V0IiwicXVldWUiLCJkcmFpbiIsInNldFRpbWVvdXQiLCJfbG9vcCIsImV2Iiwic2hpZnQiLCJoYW5kbGVyIiwiQm9vbGVhbiIsInNpemUiLCJmcmVlemUiLCJmbiIsImhhcyIsImFkZCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/react-dev-overlay/pages/bus.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js ***!
  \************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  ReactDevOverlay: function ReactDevOverlay() {\n    return _ReactDevOverlay[\"default\"];\n  },\n  getErrorByType: function getErrorByType() {\n    return _getErrorByType.getErrorByType;\n  },\n  getServerError: function getServerError() {\n    return _nodeStackFrames.getServerError;\n  },\n  onBeforeRefresh: function onBeforeRefresh() {\n    return _onBeforeRefresh;\n  },\n  onBuildError: function onBuildError() {\n    return _onBuildError;\n  },\n  onBuildOk: function onBuildOk() {\n    return _onBuildOk;\n  },\n  onRefresh: function onRefresh() {\n    return _onRefresh;\n  },\n  onVersionInfo: function onVersionInfo() {\n    return _onVersionInfo;\n  },\n  register: function register() {\n    return _register;\n  },\n  unregister: function unregister() {\n    return _unregister;\n  }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _bus = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ./bus */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/bus.js\"));\nvar _parseStack = __webpack_require__(/*! ../internal/helpers/parseStack */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parseStack.js\");\nvar _parsecomponentstack = __webpack_require__(/*! ../internal/helpers/parse-component-stack */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parse-component-stack.js\");\nvar _hydrationerrorinfo = __webpack_require__(/*! ../internal/helpers/hydration-error-info */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/hydration-error-info.js\");\nvar _shared = __webpack_require__(/*! ../shared */ \"./node_modules/next/dist/client/components/react-dev-overlay/shared.js\");\nvar _getErrorByType = __webpack_require__(/*! ../internal/helpers/getErrorByType */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/getErrorByType.js\");\nvar _nodeStackFrames = __webpack_require__(/*! ../internal/helpers/nodeStackFrames */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/nodeStackFrames.js\");\nvar _ReactDevOverlay = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./ReactDevOverlay */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/ReactDevOverlay.js\"));\n// Patch console.error to collect information about hydration errors\n(0, _hydrationerrorinfo.patchConsoleError)();\nvar isRegistered = false;\nvar stackTraceLimit = undefined;\nfunction onUnhandledError(ev) {\n  var error = ev == null ? void 0 : ev.error;\n  if (!error || !(error instanceof Error) || typeof error.stack !== \"string\") {\n    // A non-error was thrown, we don't have anything to show. :-(\n    return;\n  }\n  if (error.message.match(/(hydration|content does not match|did not match)/i)) {\n    if (_hydrationerrorinfo.hydrationErrorState.warning) {\n      error.details = _objectSpread(_objectSpread({}, error.details), _hydrationerrorinfo.hydrationErrorState);\n    }\n    error.message += \"\\nSee more info here: https://nextjs.org/docs/messages/react-hydration-error\";\n  }\n  var e = error;\n  var componentStackFrames = typeof _hydrationerrorinfo.hydrationErrorState.componentStack === \"string\" ? (0, _parsecomponentstack.parseComponentStack)(_hydrationerrorinfo.hydrationErrorState.componentStack) : undefined;\n  // Skip ModuleBuildError and ModuleNotFoundError, as it will be sent through onBuildError callback.\n  // This is to avoid same error as different type showing up on client to cause flashing.\n  if (e.name !== \"ModuleBuildError\" && e.name !== \"ModuleNotFoundError\") {\n    _bus.emit({\n      type: _shared.ACTION_UNHANDLED_ERROR,\n      reason: error,\n      frames: (0, _parseStack.parseStack)(e.stack),\n      componentStackFrames: componentStackFrames\n    });\n  }\n}\nfunction onUnhandledRejection(ev) {\n  var reason = ev == null ? void 0 : ev.reason;\n  if (!reason || !(reason instanceof Error) || typeof reason.stack !== \"string\") {\n    // A non-error was thrown, we don't have anything to show. :-(\n    return;\n  }\n  var e = reason;\n  _bus.emit({\n    type: _shared.ACTION_UNHANDLED_REJECTION,\n    reason: reason,\n    frames: (0, _parseStack.parseStack)(e.stack)\n  });\n}\nfunction _register() {\n  if (isRegistered) {\n    return;\n  }\n  isRegistered = true;\n  try {\n    var limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 50;\n    stackTraceLimit = limit;\n  } catch (e) {}\n  window.addEventListener(\"error\", onUnhandledError);\n  window.addEventListener(\"unhandledrejection\", onUnhandledRejection);\n}\nfunction _unregister() {\n  if (!isRegistered) {\n    return;\n  }\n  isRegistered = false;\n  if (stackTraceLimit !== undefined) {\n    try {\n      Error.stackTraceLimit = stackTraceLimit;\n    } catch (e) {}\n    stackTraceLimit = undefined;\n  }\n  window.removeEventListener(\"error\", onUnhandledError);\n  window.removeEventListener(\"unhandledrejection\", onUnhandledRejection);\n}\nfunction _onBuildOk() {\n  _bus.emit({\n    type: _shared.ACTION_BUILD_OK\n  });\n}\nfunction _onBuildError(message) {\n  _bus.emit({\n    type: _shared.ACTION_BUILD_ERROR,\n    message: message\n  });\n}\nfunction _onRefresh() {\n  _bus.emit({\n    type: _shared.ACTION_REFRESH\n  });\n}\nfunction _onBeforeRefresh() {\n  _bus.emit({\n    type: _shared.ACTION_BEFORE_REFRESH\n  });\n}\nfunction _onVersionInfo(versionInfo) {\n  _bus.emit({\n    type: _shared.ACTION_VERSION_INFO,\n    versionInfo: versionInfo\n  });\n}\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFBQSxJQUFBQSxlQUFBLEdBQUFDLG1CQUFBO0FBQUEsU0FBQUMsUUFBQUMsQ0FBQSxFQUFBQyxDQUFBLFFBQUFDLENBQUEsR0FBQUMsTUFBQSxDQUFBQyxJQUFBLENBQUFKLENBQUEsT0FBQUcsTUFBQSxDQUFBRSxxQkFBQSxRQUFBQyxDQUFBLEdBQUFILE1BQUEsQ0FBQUUscUJBQUEsQ0FBQUwsQ0FBQSxHQUFBQyxDQUFBLEtBQUFLLENBQUEsR0FBQUEsQ0FBQSxDQUFBQyxNQUFBLFdBQUFOLENBQUEsV0FBQUUsTUFBQSxDQUFBSyx3QkFBQSxDQUFBUixDQUFBLEVBQUFDLENBQUEsRUFBQVEsVUFBQSxPQUFBUCxDQUFBLENBQUFRLElBQUEsQ0FBQUMsS0FBQSxDQUFBVCxDQUFBLEVBQUFJLENBQUEsWUFBQUosQ0FBQTtBQUFBLFNBQUFVLGNBQUFaLENBQUEsYUFBQUMsQ0FBQSxNQUFBQSxDQUFBLEdBQUFZLFNBQUEsQ0FBQUMsTUFBQSxFQUFBYixDQUFBLFVBQUFDLENBQUEsV0FBQVcsU0FBQSxDQUFBWixDQUFBLElBQUFZLFNBQUEsQ0FBQVosQ0FBQSxRQUFBQSxDQUFBLE9BQUFGLE9BQUEsQ0FBQUksTUFBQSxDQUFBRCxDQUFBLE9BQUFhLE9BQUEsV0FBQWQsQ0FBQSxJQUFBSixlQUFBLENBQUFHLENBQUEsRUFBQUMsQ0FBQSxFQUFBQyxDQUFBLENBQUFELENBQUEsU0FBQUUsTUFBQSxDQUFBYSx5QkFBQSxHQUFBYixNQUFBLENBQUFjLGdCQUFBLENBQUFqQixDQUFBLEVBQUFHLE1BQUEsQ0FBQWEseUJBQUEsQ0FBQWQsQ0FBQSxLQUFBSCxPQUFBLENBQUFJLE1BQUEsQ0FBQUQsQ0FBQSxHQUFBYSxPQUFBLFdBQUFkLENBQUEsSUFBQUUsTUFBQSxDQUFBZSxjQUFBLENBQUFsQixDQUFB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LEtBQUssT0FBT0EsT0FBTyxXQUFRLENBQUNnRSxVQUFVLEtBQUssV0FBVyxFQUFFO0VBQ3JLaEYsTUFBTSxDQUFDZSxjQUFjLENBQUNDLE9BQU8sV0FBUSxFQUFFLFlBQVksRUFBRTtJQUFFQyxLQUFLLEVBQUU7RUFBSyxDQUFDLENBQUM7RUFDckVqQixNQUFNLENBQUNpRixNQUFNLENBQUNqRSxPQUFPLFdBQVEsRUFBRUEsT0FBTyxDQUFDO0VBQ3ZDRSxNQUFNLENBQUNGLE9BQU8sR0FBR0EsT0FBTyxXQUFRO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvcGFnZXMvY2xpZW50LmpzP2MwZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBSZWFjdERldk92ZXJsYXk6IG51bGwsXG4gICAgZ2V0RXJyb3JCeVR5cGU6IG51bGwsXG4gICAgZ2V0U2VydmVyRXJyb3I6IG51bGwsXG4gICAgb25CZWZvcmVSZWZyZXNoOiBudWxsLFxuICAgIG9uQnVpbGRFcnJvcjogbnVsbCxcbiAgICBvbkJ1aWxkT2s6IG51bGwsXG4gICAgb25SZWZyZXNoOiBudWxsLFxuICAgIG9uVmVyc2lvbkluZm86IG51bGwsXG4gICAgcmVnaXN0ZXI6IG51bGwsXG4gICAgdW5yZWdpc3RlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBSZWFjdERldk92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1JlYWN0RGV2T3ZlcmxheS5kZWZhdWx0O1xuICAgIH0sXG4gICAgZ2V0RXJyb3JCeVR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2dldEVycm9yQnlUeXBlLmdldEVycm9yQnlUeXBlO1xuICAgIH0sXG4gICAgZ2V0U2VydmVyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX25vZGVTdGFja0ZyYW1lcy5nZXRTZXJ2ZXJFcnJvcjtcbiAgICB9LFxuICAgIG9uQmVmb3JlUmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvbkJlZm9yZVJlZnJlc2g7XG4gICAgfSxcbiAgICBvbkJ1aWxkRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb25CdWlsZEVycm9yO1xuICAgIH0sXG4gICAgb25CdWlsZE9rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG9uQnVpbGRPaztcbiAgICB9LFxuICAgIG9uUmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvblJlZnJlc2g7XG4gICAgfSxcbiAgICBvblZlcnNpb25JbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG9uVmVyc2lvbkluZm87XG4gICAgfSxcbiAgICByZWdpc3RlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlcjtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdW5yZWdpc3RlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfYnVzID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4vYnVzXCIpKTtcbmNvbnN0IF9wYXJzZVN0YWNrID0gcmVxdWlyZShcIi4uL2ludGVybmFsL2hlbHBlcnMvcGFyc2VTdGFja1wiKTtcbmNvbnN0IF9wYXJzZWNvbXBvbmVudHN0YWNrID0gcmVxdWlyZShcIi4uL2ludGVybmFsL2hlbHBlcnMvcGFyc2UtY29tcG9uZW50LXN0YWNrXCIpO1xuY29uc3QgX2h5ZHJhdGlvbmVycm9yaW5mbyA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9oZWxwZXJzL2h5ZHJhdGlvbi1lcnJvci1pbmZvXCIpO1xuY29uc3QgX3NoYXJlZCA9IHJlcXVpcmUoXCIuLi9zaGFyZWRcIik7XG5jb25zdCBfZ2V0RXJyb3JCeVR5cGUgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvaGVscGVycy9nZXRFcnJvckJ5VHlwZVwiKTtcbmNvbnN0IF9ub2RlU3RhY2tGcmFtZXMgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XG5jb25zdCBfUmVhY3REZXZPdmVybGF5ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9SZWFjdERldk92ZXJsYXlcIikpO1xuLy8gUGF0Y2ggY29uc29sZS5lcnJvciB0byBjb2xsZWN0IGluZm9ybWF0aW9uIGFib3V0IGh5ZHJhdGlvbiBlcnJvcnNcbigwLCBfaHlkcmF0aW9uZXJyb3JpbmZvLnBhdGNoQ29uc29sZUVycm9yKSgpO1xubGV0IGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xubGV0IHN0YWNrVHJhY2VMaW1pdCA9IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXYpIHtcbiAgICBjb25zdCBlcnJvciA9IGV2ID09IG51bGwgPyB2b2lkIDAgOiBldi5lcnJvcjtcbiAgICBpZiAoIWVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgfHwgdHlwZW9mIGVycm9yLnN0YWNrICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEEgbm9uLWVycm9yIHdhcyB0aHJvd24sIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gc2hvdy4gOi0oXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVycm9yLm1lc3NhZ2UubWF0Y2goLyhoeWRyYXRpb258Y29udGVudCBkb2VzIG5vdCBtYXRjaHxkaWQgbm90IG1hdGNoKS9pKSkge1xuICAgICAgICBpZiAoX2h5ZHJhdGlvbmVycm9yaW5mby5oeWRyYXRpb25FcnJvclN0YXRlLndhcm5pbmcpIHtcbiAgICAgICAgICAgIGVycm9yLmRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZXJyb3IuZGV0YWlscyxcbiAgICAgICAgICAgICAgICAvLyBJdCBjb250YWlucyB0aGUgd2FybmluZywgY29tcG9uZW50IHN0YWNrLCBzZXJ2ZXIgYW5kIGNsaWVudCB0YWcgbmFtZXNcbiAgICAgICAgICAgICAgICAuLi5faHlkcmF0aW9uZXJyb3JpbmZvLmh5ZHJhdGlvbkVycm9yU3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IubWVzc2FnZSArPSBcIlxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcmVhY3QtaHlkcmF0aW9uLWVycm9yXCI7XG4gICAgfVxuICAgIGNvbnN0IGUgPSBlcnJvcjtcbiAgICBjb25zdCBjb21wb25lbnRTdGFja0ZyYW1lcyA9IHR5cGVvZiBfaHlkcmF0aW9uZXJyb3JpbmZvLmh5ZHJhdGlvbkVycm9yU3RhdGUuY29tcG9uZW50U3RhY2sgPT09IFwic3RyaW5nXCIgPyAoMCwgX3BhcnNlY29tcG9uZW50c3RhY2sucGFyc2VDb21wb25lbnRTdGFjaykoX2h5ZHJhdGlvbmVycm9yaW5mby5oeWRyYXRpb25FcnJvclN0YXRlLmNvbXBvbmVudFN0YWNrKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBTa2lwIE1vZHVsZUJ1aWxkRXJyb3IgYW5kIE1vZHVsZU5vdEZvdW5kRXJyb3IsIGFzIGl0IHdpbGwgYmUgc2VudCB0aHJvdWdoIG9uQnVpbGRFcnJvciBjYWxsYmFjay5cbiAgICAvLyBUaGlzIGlzIHRvIGF2b2lkIHNhbWUgZXJyb3IgYXMgZGlmZmVyZW50IHR5cGUgc2hvd2luZyB1cCBvbiBjbGllbnQgdG8gY2F1c2UgZmxhc2hpbmcuXG4gICAgaWYgKGUubmFtZSAhPT0gXCJNb2R1bGVCdWlsZEVycm9yXCIgJiYgZS5uYW1lICE9PSBcIk1vZHVsZU5vdEZvdW5kRXJyb3JcIikge1xuICAgICAgICBfYnVzLmVtaXQoe1xuICAgICAgICAgICAgdHlwZTogX3NoYXJlZC5BQ1RJT05fVU5IQU5ETEVEX0VSUk9SLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvcixcbiAgICAgICAgICAgIGZyYW1lczogKDAsIF9wYXJzZVN0YWNrLnBhcnNlU3RhY2spKGUuc3RhY2spLFxuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tGcmFtZXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25VbmhhbmRsZWRSZWplY3Rpb24oZXYpIHtcbiAgICBjb25zdCByZWFzb24gPSBldiA9PSBudWxsID8gdm9pZCAwIDogZXYucmVhc29uO1xuICAgIGlmICghcmVhc29uIHx8ICEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IpIHx8IHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gcmVhc29uO1xuICAgIF9idXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04sXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICBmcmFtZXM6ICgwLCBfcGFyc2VTdGFjay5wYXJzZVN0YWNrKShlLnN0YWNrKVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgaWYgKGlzUmVnaXN0ZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzUmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDUwO1xuICAgICAgICBzdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25VbmhhbmRsZWRFcnJvcik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmhhbmRsZWRyZWplY3Rpb25cIiwgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgICBpZiAoIWlzUmVnaXN0ZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGlmIChzdGFja1RyYWNlTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0O1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICBzdGFja1RyYWNlTGltaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25VbmhhbmRsZWRFcnJvcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1bmhhbmRsZWRyZWplY3Rpb25cIiwgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xufVxuZnVuY3Rpb24gb25CdWlsZE9rKCkge1xuICAgIF9idXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX0JVSUxEX09LXG4gICAgfSk7XG59XG5mdW5jdGlvbiBvbkJ1aWxkRXJyb3IobWVzc2FnZSkge1xuICAgIF9idXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX0JVSUxEX0VSUk9SLFxuICAgICAgICBtZXNzYWdlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBvblJlZnJlc2goKSB7XG4gICAgX2J1cy5lbWl0KHtcbiAgICAgICAgdHlwZTogX3NoYXJlZC5BQ1RJT05fUkVGUkVTSFxuICAgIH0pO1xufVxuZnVuY3Rpb24gb25CZWZvcmVSZWZyZXNoKCkge1xuICAgIF9idXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IF9zaGFyZWQuQUNUSU9OX0JFRk9SRV9SRUZSRVNIXG4gICAgfSk7XG59XG5mdW5jdGlvbiBvblZlcnNpb25JbmZvKHZlcnNpb25JbmZvKSB7XG4gICAgX2J1cy5lbWl0KHtcbiAgICAgICAgdHlwZTogX3NoYXJlZC5BQ1RJT05fVkVSU0lPTl9JTkZPLFxuICAgICAgICB2ZXJzaW9uSW5mb1xuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsInJlcXVpcmUiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiUmVhY3REZXZPdmVybGF5IiwiZ2V0RXJyb3JCeVR5cGUiLCJnZXRTZXJ2ZXJFcnJvciIsIm9uQmVmb3JlUmVmcmVzaCIsIm9uQnVpbGRFcnJvciIsIm9uQnVpbGRPayIsIm9uUmVmcmVzaCIsIm9uVmVyc2lvbkluZm8iLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsIl9SZWFjdERldk92ZXJsYXkiLCJfZ2V0RXJyb3JCeVR5cGUiLCJfbm9kZVN0YWNrRnJhbWVzIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9idXMiLCJfIiwiX3BhcnNlU3RhY2siLCJfcGFyc2Vjb21wb25lbnRzdGFjayIsIl9oeWRyYXRpb25lcnJvcmluZm8iLCJfc2hhcmVkIiwicGF0Y2hDb25zb2xlRXJyb3IiLCJpc1JlZ2lzdGVyZWQiLCJzdGFja1RyYWNlTGltaXQiLCJ1bmRlZmluZWQiLCJvblVuaGFuZGxlZEVycm9yIiwiZXYiLCJlcnJvciIsIkVycm9yIiwic3RhY2siLCJtZXNzYWdlIiwibWF0Y2giLCJoeWRyYXRpb25FcnJvclN0YXRlIiwid2FybmluZyIsImRldGFpbHMiLCJjb21wb25lbnRTdGFja0ZyYW1lcyIsImNvbXBvbmVudFN0YWNrIiwicGFyc2VDb21wb25lbnRTdGFjayIsImVtaXQiLCJ0eXBlIiwiQUNUSU9OX1VOSEFORExFRF9FUlJPUiIsInJlYXNvbiIsImZyYW1lcyIsInBhcnNlU3RhY2siLCJvblVuaGFuZGxlZFJlamVjdGlvbiIsIkFDVElPTl9VTkhBTkRMRURfUkVKRUNUSU9OIiwibGltaXQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkFDVElPTl9CVUlMRF9PSyIsIkFDVElPTl9CVUlMRF9FUlJPUiIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX0JFRk9SRV9SRUZSRVNIIiwidmVyc2lvbkluZm8iLCJBQ1RJT05fVkVSU0lPTl9JTkZPIiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/react-dev-overlay/pages/hot-reloader-client.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/pages/hot-reloader-client.js ***!
  \*************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// TODO: Remove use of `any` type. Fix no-use-before-define violations.\n/* eslint-disable @typescript-eslint/no-use-before-define */ /**\n                                                             * MIT License\n                                                             *\n                                                             * Copyright (c) 2013-present, Facebook, Inc.\n                                                             *\n                                                             * Permission is hereby granted, free of charge, to any person obtaining a copy\n                                                             * of this software and associated documentation files (the \"Software\"), to deal\n                                                             * in the Software without restriction, including without limitation the rights\n                                                             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n                                                             * copies of the Software, and to permit persons to whom the Software is\n                                                             * furnished to do so, subject to the following conditions:\n                                                             *\n                                                             * The above copyright notice and this permission notice shall be included in all\n                                                             * copies or substantial portions of the Software.\n                                                             *\n                                                             * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                                                             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n                                                             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n                                                             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n                                                             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n                                                             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n                                                             * SOFTWARE.\n                                                             */ // This file is a modified version of the Create React App HMR dev client that\n// can be found here:\n// https://github.com/facebook/create-react-app/blob/v3.4.1/packages/react-dev-utils/webpackHotDevClient.js\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  \"default\": function _default() {\n    return connect;\n  },\n  performFullReload: function performFullReload() {\n    return _performFullReload;\n  }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _client = __webpack_require__(/*! ./client */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js\");\nvar _stripansi = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\"));\nvar _websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/websocket.js\");\nvar _formatwebpackmessages = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../internal/helpers/format-webpack-messages */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/format-webpack-messages.js\"));\nvar _hotreloadertypes = __webpack_require__(/*! ../../../../server/dev/hot-reloader-types */ \"./node_modules/next/dist/server/dev/hot-reloader-types.js\");\nvar _extractmodulesfromturbopackmessage = __webpack_require__(/*! ../../../../server/dev/extract-modules-from-turbopack-message */ \"./node_modules/next/dist/server/dev/extract-modules-from-turbopack-message.js\");\nvar _shared = __webpack_require__(/*! ../shared */ \"./node_modules/next/dist/client/components/react-dev-overlay/shared.js\");\nvar _runtimeerrorhandler = __webpack_require__(/*! ../internal/helpers/runtime-error-handler */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/runtime-error-handler.js\");\nwindow.__nextDevClientId = Math.round(Math.random() * 100 + Date.now());\nvar customHmrEventHandler;\nvar turbopackMessageListeners = [];\nvar MODE = \"webpack\";\nfunction connect(mode) {\n  MODE = mode;\n  (0, _client.register)();\n  (0, _websocket.addMessageListener)(function (payload) {\n    if (!(\"action\" in payload)) {\n      return;\n    }\n    try {\n      processMessage(payload);\n    } catch (err) {\n      var _err_stack;\n      console.warn(\"[HMR] Invalid message: \" + payload + \"\\n\" + ((_err_stack = err == null ? void 0 : err.stack) != null ? _err_stack : \"\"));\n    }\n  });\n  return {\n    subscribeToHmrEvent: function subscribeToHmrEvent(handler) {\n      customHmrEventHandler = handler;\n    },\n    onUnrecoverableError: function onUnrecoverableError() {\n      _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError = true;\n    },\n    addTurbopackMessageListener: function addTurbopackMessageListener(cb) {\n      turbopackMessageListeners.push(cb);\n    },\n    sendTurbopackMessage: function sendTurbopackMessage(msg) {\n      (0, _websocket.sendMessage)(msg);\n    },\n    handleUpdateError: function handleUpdateError(err) {\n      _performFullReload(err);\n    }\n  };\n}\n// Remember some state related to hot module replacement.\nvar isFirstCompilation = true;\nvar mostRecentCompilationHash = null;\nvar hasCompileErrors = false;\nfunction clearOutdatedErrors() {\n  // Clean up outdated compile errors, if any.\n  if (typeof console !== \"undefined\" && typeof console.clear === \"function\") {\n    if (hasCompileErrors) {\n      console.clear();\n    }\n  }\n}\n// Successful compilation.\nfunction handleSuccess() {\n  clearOutdatedErrors();\n  if (MODE === \"webpack\") {\n    var isHotUpdate = !isFirstCompilation || window.__NEXT_DATA__.page !== \"/_error\" && isUpdateAvailable();\n    isFirstCompilation = false;\n    hasCompileErrors = false;\n    // Attempt to apply hot updates or reload.\n    if (isHotUpdate) {\n      tryApplyUpdates(onBeforeFastRefresh, onFastRefresh);\n    }\n  } else {\n    (0, _client.onBuildOk)();\n  }\n}\n// Compilation with warnings (e.g. ESLint).\nfunction handleWarnings(warnings) {\n  clearOutdatedErrors();\n  var isHotUpdate = !isFirstCompilation;\n  isFirstCompilation = false;\n  hasCompileErrors = false;\n  function printWarnings() {\n    // Print warnings to the console.\n    var formatted = (0, _formatwebpackmessages[\"default\"])({\n      warnings: warnings,\n      errors: []\n    });\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      var _formatted_warnings;\n      for (var i = 0; i < ((_formatted_warnings = formatted.warnings) == null ? void 0 : _formatted_warnings.length); i++) {\n        if (i === 5) {\n          console.warn(\"There were more warnings in other files.\\n\" + \"You can find a complete log in the terminal.\");\n          break;\n        }\n        console.warn((0, _stripansi[\"default\"])(formatted.warnings[i]));\n      }\n    }\n  }\n  printWarnings();\n  // Attempt to apply hot updates or reload.\n  if (isHotUpdate) {\n    tryApplyUpdates(onBeforeFastRefresh, onFastRefresh);\n  }\n}\n// Compilation with errors (e.g. syntax error or missing modules).\nfunction handleErrors(errors) {\n  clearOutdatedErrors();\n  isFirstCompilation = false;\n  hasCompileErrors = true;\n  // \"Massage\" webpack messages.\n  var formatted = (0, _formatwebpackmessages[\"default\"])({\n    errors: errors,\n    warnings: []\n  });\n  // Only show the first error.\n  (0, _client.onBuildError)(formatted.errors[0]);\n  // Also log them to the console.\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    for (var i = 0; i < formatted.errors.length; i++) {\n      console.error((0, _stripansi[\"default\"])(formatted.errors[i]));\n    }\n  }\n  // Do not attempt to reload now.\n  // We will reload on next success instead.\n  if (false) {}\n}\nvar startLatency = undefined;\nfunction onBeforeFastRefresh(updatedModules) {\n  if (updatedModules.length > 0) {\n    // Only trigger a pending state if we have updates to apply\n    // (cf. onFastRefresh)\n    (0, _client.onBeforeRefresh)();\n  }\n}\nfunction onFastRefresh(updatedModules) {\n  if (updatedModules === void 0) updatedModules = [];\n  (0, _client.onBuildOk)();\n  if (updatedModules.length === 0) {\n    return;\n  }\n  (0, _client.onRefresh)();\n  reportHmrLatency();\n}\nfunction reportHmrLatency(updatedModules) {\n  if (updatedModules === void 0) updatedModules = [];\n  if (startLatency) {\n    var endLatency = Date.now();\n    var latency = endLatency - startLatency;\n    console.log(\"[Fast Refresh] done in \" + latency + \"ms\");\n    (0, _websocket.sendMessage)(JSON.stringify({\n      event: \"client-hmr-latency\",\n      id: window.__nextDevClientId,\n      startTime: startLatency,\n      endTime: endLatency,\n      page: window.location.pathname,\n      updatedModules: updatedModules,\n      // Whether the page (tab) was hidden at the time the event occurred.\n      // This can impact the accuracy of the event's timing.\n      isPageHidden: document.visibilityState === \"hidden\"\n    }));\n    if (self.__NEXT_HMR_LATENCY_CB) {\n      self.__NEXT_HMR_LATENCY_CB(latency);\n    }\n  }\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n  // Update last known compilation hash.\n  mostRecentCompilationHash = hash;\n}\n/** Handles messages from the sevrer for the Pages Router. */\nfunction processMessage(obj) {\n  if (!(\"action\" in obj)) {\n    return;\n  }\n  // Use turbopack message for analytics, (still need built for webpack)\n  switch (obj.action) {\n    case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:\n      {\n        startLatency = Date.now();\n        console.log(\"[Fast Refresh] rebuilding\");\n        break;\n      }\n    case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:\n    case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:\n      {\n        if (obj.hash) handleAvailableHash(obj.hash);\n        var errors = obj.errors,\n          warnings = obj.warnings;\n        // Is undefined when it's a 'built' event\n        if (\"versionInfo\" in obj) (0, _client.onVersionInfo)(obj.versionInfo);\n        var hasErrors = Boolean(errors && errors.length);\n        if (hasErrors) {\n          (0, _websocket.sendMessage)(JSON.stringify({\n            event: \"client-error\",\n            errorCount: errors.length,\n            clientId: window.__nextDevClientId\n          }));\n          return handleErrors(errors);\n        }\n        var hasWarnings = Boolean(warnings && warnings.length);\n        if (hasWarnings) {\n          (0, _websocket.sendMessage)(JSON.stringify({\n            event: \"client-warning\",\n            warningCount: warnings.length,\n            clientId: window.__nextDevClientId\n          }));\n          return handleWarnings(warnings);\n        }\n        (0, _websocket.sendMessage)(JSON.stringify({\n          event: \"client-success\",\n          clientId: window.__nextDevClientId\n        }));\n        return handleSuccess();\n      }\n    case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:\n      {\n        window.location.reload();\n        return;\n      }\n    case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:\n      {\n        var errorJSON = obj.errorJSON;\n        if (errorJSON) {\n          var _JSON$parse = JSON.parse(errorJSON),\n            message = _JSON$parse.message,\n            stack = _JSON$parse.stack;\n          var error = new Error(message);\n          error.stack = stack;\n          handleErrors([error]);\n        }\n        return;\n      }\n    case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:\n      {\n        var _iterator = _createForOfIteratorHelper(turbopackMessageListeners),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var listener = _step.value;\n            listener({\n              type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        break;\n      }\n    case _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:\n      {\n        var updatedModules = (0, _extractmodulesfromturbopackmessage.extractModulesFromTurbopackMessage)(obj.data);\n        onBeforeFastRefresh(updatedModules);\n        var _iterator2 = _createForOfIteratorHelper(turbopackMessageListeners),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _listener = _step2.value;\n            _listener({\n              type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n              data: obj.data\n            });\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n          console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n          _performFullReload(null);\n        }\n        (0, _client.onRefresh)();\n        reportHmrLatency(updatedModules);\n        break;\n      }\n    default:\n      {\n        if (customHmrEventHandler) {\n          customHmrEventHandler(obj);\n          break;\n        }\n        break;\n      }\n  }\n}\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n  /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n  // It's a global variable injected by Webpack.\n  return mostRecentCompilationHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n  // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n  return module.hot.status() === \"idle\";\n}\nfunction afterApplyUpdates(fn) {\n  if (canApplyUpdates()) {\n    fn();\n  } else {\n    var handler = function handler(status) {\n      if (status === \"idle\") {\n        // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n        module.hot.removeStatusHandler(handler);\n        fn();\n      }\n    }; // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n    module.hot.addStatusHandler(handler);\n  }\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdates(onBeforeHotUpdate, onHotUpdateSuccess) {\n  // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n  if (false) {}\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    (0, _client.onBuildOk)();\n    return;\n  }\n  function handleApplyUpdates(err, updatedModules) {\n    if (err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || !updatedModules) {\n      if (err) {\n        console.warn(\"[Fast Refresh] performing full reload\\n\\n\" + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + \"You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n\" + \"Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n\" + \"It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n\" + \"Fast Refresh requires at least one parent function component in your React tree.\");\n      } else if (_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {\n        console.warn(\"[Fast Refresh] performing full reload because your application had an unrecoverable error\");\n      }\n      _performFullReload(err);\n      return;\n    }\n    if (typeof onHotUpdateSuccess === \"function\") {\n      // Maybe we want to do something.\n      onHotUpdateSuccess(updatedModules);\n    }\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      // However, this time, don't trigger a pending refresh state.\n      tryApplyUpdates(updatedModules.length > 0 ? undefined : onBeforeHotUpdate, updatedModules.length > 0 ? _client.onBuildOk : onHotUpdateSuccess);\n    } else {\n      (0, _client.onBuildOk)();\n      if (false) {}\n    }\n  }\n  // https://webpack.js.org/api/hot-module-replacement/#check\n  // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n  module.hot.check( /* autoApply */false).then(function (updatedModules) {\n    if (!updatedModules) {\n      return null;\n    }\n    if (typeof onBeforeHotUpdate === \"function\") {\n      onBeforeHotUpdate(updatedModules);\n    }\n    // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n    return module.hot.apply();\n  }).then(function (updatedModules) {\n    handleApplyUpdates(null, updatedModules);\n  }, function (err) {\n    handleApplyUpdates(err, null);\n  });\n}\nfunction _performFullReload(err) {\n  var stackTrace = err && (err.stack && err.stack.split(\"\\n\").slice(0, 5).join(\"\\n\") || err.message || err + \"\");\n  (0, _websocket.sendMessage)(JSON.stringify({\n    event: \"client-full-reload\",\n    stackTrace: stackTrace,\n    hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,\n    dependencyChain: err ? err.dependencyChain : undefined\n  }));\n  window.location.reload();\n}\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL2hvdC1yZWxvYWRlci1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBdEI2RCxDQXNCekQ7QUFDSjtBQUNBO0FBQ2E7O0FBQUEsU0FBQUEsMkJBQUFDLENBQUEsRUFBQUMsY0FBQSxRQUFBQyxFQUFBLFVBQUFDLE1BQUEsb0JBQUFILENBQUEsQ0FBQUcsTUFBQSxDQUFBQyxRQUFBLEtBQUFKLENBQUEscUJBQUFFLEVBQUEsUUFBQUcsS0FBQSxDQUFBQyxPQUFBLENBQUFOLENBQUEsTUFBQUUsRUFBQSxHQUFBSywyQkFBQSxDQUFBUCxDQUFBLE1BQUFDLGNBQUEsSUFBQUQsQ0FBQSxXQUFBQSxDQUFBLENBQUFRLE1BQUEscUJBQUFOLEVBQUEsRUFBQUYsQ0FBQSxHQUFBRSxFQUFBLE1BQUFPLENBQUEsVUFBQUMsQ0FBQSxZQUFBQSxFQUFBLGVBQUFDLENBQUEsRUFBQUQsQ0FBQSxFQUFBRSxDQUFBLFdBQUFBLEVBQUEsUUFBQUgsQ0FBQSxJQUFBVCxDQUFBLENBQUFRLE1BQUEsV0FBQUssSUFBQSxtQkFBQUEsSUFBQSxTQUFBQyxLQUFBLEVBQUFkLENBQUEsQ0FBQVMsQ0FBQSxVQUFBTSxDQUFBLFdBQUFBLEVBQUFDLEVBQUEsVUFBQUEsRUFBQSxLQUFBQyxDQUFBLEVBQUFQLENBQUEsZ0JBQUFRLFNBQUEsaUpBQUFDLGdCQUFBLFNBQUFDLE1BQUEsVUFBQUMsR0FBQSxXQUFBVixDQUFBLFdBQUFBLEVBQUEsSUFBQVQsRUFBQSxHQUFBQSxFQUFBLENBQUFvQixJQUFBLENBQUF0QixDQUFBLE1BQUFZLENBQUEsV0FBQUEs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SUFBSTNLLEdBQUcsQ0FBQzhJLE9BQU8sSUFBSTlJLEdBQUcsR0FBRyxFQUFFLENBQUM7RUFDaEgsQ0FBQyxDQUFDLEVBQUVrQyxVQUFVLENBQUNtQyxXQUFXLEVBQUV1QyxJQUFJLENBQUNDLFNBQVMsQ0FBQztJQUN2Q0MsS0FBSyxFQUFFLG9CQUFvQjtJQUMzQjJELFVBQVUsRUFBVkEsVUFBVTtJQUNWMUcsZUFBZSxFQUFFLENBQUMsQ0FBQ3hCLG9CQUFvQixDQUFDdUIsbUJBQW1CLENBQUNDLGVBQWU7SUFDM0U2RyxlQUFlLEVBQUU1SyxHQUFHLEdBQUdBLEdBQUcsQ0FBQzRLLGVBQWUsR0FBR3hFO0VBQ2pELENBQUMsQ0FBQyxDQUFDO0VBQ0g1RCxNQUFNLENBQUMwRSxRQUFRLENBQUN1QixNQUFNLENBQUMsQ0FBQztBQUM1QjtBQUVBLElBQUksQ0FBQyxPQUFPdEgsT0FBTyxXQUFRLEtBQUssVUFBVSxJQUFLLE9BQU9BLE9BQU8sV0FBUSxLQUFLLFFBQVEsSUFBSUEsT0FBTyxXQUFRLEtBQUssSUFBSyxLQUFLLE9BQU9BLE9BQU8sV0FBUSxDQUFDMEosVUFBVSxLQUFLLFdBQVcsRUFBRTtFQUNyS3RLLE1BQU0sQ0FBQ1csY0FBYyxDQUFDQyxPQUFPLFdBQVEsRUFBRSxZQUFZLEVBQUU7SUFBRTFCLEtBQUssRUFBRTtFQUFLLENBQUMsQ0FBQztFQUNyRWMsTUFBTSxDQUFDdUssTUFBTSxDQUFDM0osT0FBTyxXQUFRLEVBQUVBLE9BQU8sQ0FBQztFQUN2Q0MsTUFBTSxDQUFDRCxPQUFPLEdBQUdBLE9BQU8sV0FBUTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL2hvdC1yZWxvYWRlci1jbGllbnQuanM/MWUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBSZW1vdmUgdXNlIG9mIGBhbnlgIHR5cGUuIEZpeCBuby11c2UtYmVmb3JlLWRlZmluZSB2aW9sYXRpb25zLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovIC8qKlxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovIC8vIFRoaXMgZmlsZSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIENyZWF0ZSBSZWFjdCBBcHAgSE1SIGRldiBjbGllbnQgdGhhdFxuLy8gY2FuIGJlIGZvdW5kIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9ibG9iL3YzLjQuMS9wYWNrYWdlcy9yZWFjdC1kZXYtdXRpbHMvd2VicGFja0hvdERldkNsaWVudC5qc1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIHBlcmZvcm1GdWxsUmVsb2FkOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdDtcbiAgICB9LFxuICAgIHBlcmZvcm1GdWxsUmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1GdWxsUmVsb2FkO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9jbGllbnQgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5jb25zdCBfc3RyaXBhbnNpID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2lcIikpO1xuY29uc3QgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldFwiKTtcbmNvbnN0IF9mb3JtYXR3ZWJwYWNrbWVzc2FnZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9oZWxwZXJzL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzXCIpKTtcbmNvbnN0IF9ob3RyZWxvYWRlcnR5cGVzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3NlcnZlci9kZXYvaG90LXJlbG9hZGVyLXR5cGVzXCIpO1xuY29uc3QgX2V4dHJhY3Rtb2R1bGVzZnJvbXR1cmJvcGFja21lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2VydmVyL2Rldi9leHRyYWN0LW1vZHVsZXMtZnJvbS10dXJib3BhY2stbWVzc2FnZVwiKTtcbmNvbnN0IF9zaGFyZWQgPSByZXF1aXJlKFwiLi4vc2hhcmVkXCIpO1xuY29uc3QgX3J1bnRpbWVlcnJvcmhhbmRsZXIgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvaGVscGVycy9ydW50aW1lLWVycm9yLWhhbmRsZXJcIik7XG53aW5kb3cuX19uZXh0RGV2Q2xpZW50SWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAgKyBEYXRlLm5vdygpKTtcbmxldCBjdXN0b21IbXJFdmVudEhhbmRsZXI7XG5sZXQgdHVyYm9wYWNrTWVzc2FnZUxpc3RlbmVycyA9IFtdO1xubGV0IE1PREUgPSBcIndlYnBhY2tcIjtcbmZ1bmN0aW9uIGNvbm5lY3QobW9kZSkge1xuICAgIE1PREUgPSBtb2RlO1xuICAgICgwLCBfY2xpZW50LnJlZ2lzdGVyKSgpO1xuICAgICgwLCBfd2Vic29ja2V0LmFkZE1lc3NhZ2VMaXN0ZW5lcikoKHBheWxvYWQpPT57XG4gICAgICAgIGlmICghKFwiYWN0aW9uXCIgaW4gcGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2UocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFyIF9lcnJfc3RhY2s7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSBJbnZhbGlkIG1lc3NhZ2U6IFwiICsgcGF5bG9hZCArIFwiXFxuXCIgKyAoKF9lcnJfc3RhY2sgPSBlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci5zdGFjaykgIT0gbnVsbCA/IF9lcnJfc3RhY2sgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmVUb0htckV2ZW50IChoYW5kbGVyKSB7XG4gICAgICAgICAgICBjdXN0b21IbXJFdmVudEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9LFxuICAgICAgICBvblVucmVjb3ZlcmFibGVFcnJvciAoKSB7XG4gICAgICAgICAgICBfcnVudGltZWVycm9yaGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvciA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFR1cmJvcGFja01lc3NhZ2VMaXN0ZW5lciAoY2IpIHtcbiAgICAgICAgICAgIHR1cmJvcGFja01lc3NhZ2VMaXN0ZW5lcnMucHVzaChjYik7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmRUdXJib3BhY2tNZXNzYWdlIChtc2cpIHtcbiAgICAgICAgICAgICgwLCBfd2Vic29ja2V0LnNlbmRNZXNzYWdlKShtc2cpO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVVcGRhdGVFcnJvciAoZXJyKSB7XG4gICAgICAgICAgICBwZXJmb3JtRnVsbFJlbG9hZChlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIFJlbWVtYmVyIHNvbWUgc3RhdGUgcmVsYXRlZCB0byBob3QgbW9kdWxlIHJlcGxhY2VtZW50LlxudmFyIGlzRmlyc3RDb21waWxhdGlvbiA9IHRydWU7XG52YXIgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IG51bGw7XG52YXIgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlO1xuZnVuY3Rpb24gY2xlYXJPdXRkYXRlZEVycm9ycygpIHtcbiAgICAvLyBDbGVhbiB1cCBvdXRkYXRlZCBjb21waWxlIGVycm9ycywgaWYgYW55LlxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5jbGVhciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChoYXNDb21waWxlRXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgICBjbGVhck91dGRhdGVkRXJyb3JzKCk7XG4gICAgaWYgKE1PREUgPT09IFwid2VicGFja1wiKSB7XG4gICAgICAgIGNvbnN0IGlzSG90VXBkYXRlID0gIWlzRmlyc3RDb21waWxhdGlvbiB8fCB3aW5kb3cuX19ORVhUX0RBVEFfXy5wYWdlICE9PSBcIi9fZXJyb3JcIiAmJiBpc1VwZGF0ZUF2YWlsYWJsZSgpO1xuICAgICAgICBpc0ZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZTtcbiAgICAgICAgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlO1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbiAgICAgICAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgICAgICAgICB0cnlBcHBseVVwZGF0ZXMob25CZWZvcmVGYXN0UmVmcmVzaCwgb25GYXN0UmVmcmVzaCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX2NsaWVudC5vbkJ1aWxkT2spKCk7XG4gICAgfVxufVxuLy8gQ29tcGlsYXRpb24gd2l0aCB3YXJuaW5ncyAoZS5nLiBFU0xpbnQpLlxuZnVuY3Rpb24gaGFuZGxlV2FybmluZ3Mod2FybmluZ3MpIHtcbiAgICBjbGVhck91dGRhdGVkRXJyb3JzKCk7XG4gICAgY29uc3QgaXNIb3RVcGRhdGUgPSAhaXNGaXJzdENvbXBpbGF0aW9uO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBwcmludFdhcm5pbmdzKCkge1xuICAgICAgICAvLyBQcmludCB3YXJuaW5ncyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gKDAsIF9mb3JtYXR3ZWJwYWNrbWVzc2FnZXMuZGVmYXVsdCkoe1xuICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIF9mb3JtYXR0ZWRfd2FybmluZ3M7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgKChfZm9ybWF0dGVkX3dhcm5pbmdzID0gZm9ybWF0dGVkLndhcm5pbmdzKSA9PSBudWxsID8gdm9pZCAwIDogX2Zvcm1hdHRlZF93YXJuaW5ncy5sZW5ndGgpOyBpKyspe1xuICAgICAgICAgICAgICAgIGlmIChpID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG5cIiArIFwiWW91IGNhbiBmaW5kIGEgY29tcGxldGUgbG9nIGluIHRoZSB0ZXJtaW5hbC5cIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIF9zdHJpcGFuc2kuZGVmYXVsdCkoZm9ybWF0dGVkLndhcm5pbmdzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRXYXJuaW5ncygpO1xuICAgIC8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuICAgIGlmIChpc0hvdFVwZGF0ZSkge1xuICAgICAgICB0cnlBcHBseVVwZGF0ZXMob25CZWZvcmVGYXN0UmVmcmVzaCwgb25GYXN0UmVmcmVzaCk7XG4gICAgfVxufVxuLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcnMoZXJyb3JzKSB7XG4gICAgY2xlYXJPdXRkYXRlZEVycm9ycygpO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSB0cnVlO1xuICAgIC8vIFwiTWFzc2FnZVwiIHdlYnBhY2sgbWVzc2FnZXMuXG4gICAgdmFyIGZvcm1hdHRlZCA9ICgwLCBfZm9ybWF0d2VicGFja21lc3NhZ2VzLmRlZmF1bHQpKHtcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHdhcm5pbmdzOiBbXVxuICAgIH0pO1xuICAgIC8vIE9ubHkgc2hvdyB0aGUgZmlyc3QgZXJyb3IuXG4gICAgKDAsIF9jbGllbnQub25CdWlsZEVycm9yKShmb3JtYXR0ZWQuZXJyb3JzWzBdKTtcbiAgICAvLyBBbHNvIGxvZyB0aGVtIHRvIHRoZSBjb25zb2xlLlxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKDAsIF9zdHJpcGFuc2kuZGVmYXVsdCkoZm9ybWF0dGVkLmVycm9yc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBub3cuXG4gICAgLy8gV2Ugd2lsbCByZWxvYWQgb24gbmV4dCBzdWNjZXNzIGluc3RlYWQuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKGZvcm1hdHRlZC5lcnJvcnNbMF0pO1xuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzdGFydExhdGVuY3kgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBvbkJlZm9yZUZhc3RSZWZyZXNoKHVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgaWYgKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gT25seSB0cmlnZ2VyIGEgcGVuZGluZyBzdGF0ZSBpZiB3ZSBoYXZlIHVwZGF0ZXMgdG8gYXBwbHlcbiAgICAgICAgLy8gKGNmLiBvbkZhc3RSZWZyZXNoKVxuICAgICAgICAoMCwgX2NsaWVudC5vbkJlZm9yZVJlZnJlc2gpKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25GYXN0UmVmcmVzaCh1cGRhdGVkTW9kdWxlcykge1xuICAgIGlmICh1cGRhdGVkTW9kdWxlcyA9PT0gdm9pZCAwKSB1cGRhdGVkTW9kdWxlcyA9IFtdO1xuICAgICgwLCBfY2xpZW50Lm9uQnVpbGRPaykoKTtcbiAgICBpZiAodXBkYXRlZE1vZHVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKDAsIF9jbGllbnQub25SZWZyZXNoKSgpO1xuICAgIHJlcG9ydEhtckxhdGVuY3koKTtcbn1cbmZ1bmN0aW9uIHJlcG9ydEhtckxhdGVuY3kodXBkYXRlZE1vZHVsZXMpIHtcbiAgICBpZiAodXBkYXRlZE1vZHVsZXMgPT09IHZvaWQgMCkgdXBkYXRlZE1vZHVsZXMgPSBbXTtcbiAgICBpZiAoc3RhcnRMYXRlbmN5KSB7XG4gICAgICAgIGNvbnN0IGVuZExhdGVuY3kgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBsYXRlbmN5ID0gZW5kTGF0ZW5jeSAtIHN0YXJ0TGF0ZW5jeTtcbiAgICAgICAgY29uc29sZS5sb2coXCJbRmFzdCBSZWZyZXNoXSBkb25lIGluIFwiICsgbGF0ZW5jeSArIFwibXNcIik7XG4gICAgICAgICgwLCBfd2Vic29ja2V0LnNlbmRNZXNzYWdlKShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBldmVudDogXCJjbGllbnQtaG1yLWxhdGVuY3lcIixcbiAgICAgICAgICAgIGlkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWQsXG4gICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0TGF0ZW5jeSxcbiAgICAgICAgICAgIGVuZFRpbWU6IGVuZExhdGVuY3ksXG4gICAgICAgICAgICBwYWdlOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgICB1cGRhdGVkTW9kdWxlcyxcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgdGhlIHBhZ2UgKHRhYikgd2FzIGhpZGRlbiBhdCB0aGUgdGltZSB0aGUgZXZlbnQgb2NjdXJyZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBpbXBhY3QgdGhlIGFjY3VyYWN5IG9mIHRoZSBldmVudCdzIHRpbWluZy5cbiAgICAgICAgICAgIGlzUGFnZUhpZGRlbjogZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCKSB7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfTEFURU5DWV9DQihsYXRlbmN5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgY29kZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBoYW5kbGVBdmFpbGFibGVIYXNoKGhhc2gpIHtcbiAgICAvLyBVcGRhdGUgbGFzdCBrbm93biBjb21waWxhdGlvbiBoYXNoLlxuICAgIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggPSBoYXNoO1xufVxuLyoqIEhhbmRsZXMgbWVzc2FnZXMgZnJvbSB0aGUgc2V2cmVyIGZvciB0aGUgUGFnZXMgUm91dGVyLiAqLyBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShvYmopIHtcbiAgICBpZiAoIShcImFjdGlvblwiIGluIG9iaikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVc2UgdHVyYm9wYWNrIG1lc3NhZ2UgZm9yIGFuYWx5dGljcywgKHN0aWxsIG5lZWQgYnVpbHQgZm9yIHdlYnBhY2spXG4gICAgc3dpdGNoKG9iai5hY3Rpb24pe1xuICAgICAgICBjYXNlIF9ob3RyZWxvYWRlcnR5cGVzLkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5CVUlMRElORzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydExhdGVuY3kgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0Zhc3QgUmVmcmVzaF0gcmVidWlsZGluZ1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuQlVJTFQ6XG4gICAgICAgIGNhc2UgX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNZTkM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNoKSBoYW5kbGVBdmFpbGFibGVIYXNoKG9iai5oYXNoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycywgd2FybmluZ3MgfSA9IG9iajtcbiAgICAgICAgICAgICAgICAvLyBJcyB1bmRlZmluZWQgd2hlbiBpdCdzIGEgJ2J1aWx0JyBldmVudFxuICAgICAgICAgICAgICAgIGlmIChcInZlcnNpb25JbmZvXCIgaW4gb2JqKSAoMCwgX2NsaWVudC5vblZlcnNpb25JbmZvKShvYmoudmVyc2lvbkluZm8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0Vycm9ycyA9IEJvb2xlYW4oZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQuc2VuZE1lc3NhZ2UpKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNsaWVudC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb3VudDogZXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3JzKGVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1dhcm5pbmdzID0gQm9vbGVhbih3YXJuaW5ncyAmJiB3YXJuaW5ncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNXYXJuaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3dlYnNvY2tldC5zZW5kTWVzc2FnZSkoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiY2xpZW50LXdhcm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdDb3VudDogd2FybmluZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50SWQ6IHdpbmRvdy5fX25leHREZXZDbGllbnRJZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVXYXJuaW5ncyh3YXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgwLCBfd2Vic29ja2V0LnNlbmRNZXNzYWdlKShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNsaWVudC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBfaG90cmVsb2FkZXJ0eXBlcy5ITVJfQUNUSU9OU19TRU5UX1RPX0JST1dTRVIuU0VSVkVSX0NPTVBPTkVOVF9DSEFOR0VTOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlNFUlZFUl9FUlJPUjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ySlNPTiB9ID0gb2JqO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFjayB9ID0gSlNPTi5wYXJzZShlcnJvckpTT04pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3JzKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURUQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0dXJib3BhY2tNZXNzYWdlTGlzdGVuZXJzKXtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19DT05ORUNURURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9ob3RyZWxvYWRlcnR5cGVzLkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUi5UVVJCT1BBQ0tfTUVTU0FHRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkTW9kdWxlcyA9ICgwLCBfZXh0cmFjdG1vZHVsZXNmcm9tdHVyYm9wYWNrbWVzc2FnZS5leHRyYWN0TW9kdWxlc0Zyb21UdXJib3BhY2tNZXNzYWdlKShvYmouZGF0YSk7XG4gICAgICAgICAgICAgICAgb25CZWZvcmVGYXN0UmVmcmVzaCh1cGRhdGVkTW9kdWxlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0dXJib3BhY2tNZXNzYWdlTGlzdGVuZXJzKXtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX2hvdHJlbG9hZGVydHlwZXMuSE1SX0FDVElPTlNfU0VOVF9UT19CUk9XU0VSLlRVUkJPUEFDS19NRVNTQUdFLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogb2JqLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfcnVudGltZWVycm9yaGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oX3NoYXJlZC5SRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtRnVsbFJlbG9hZChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKDAsIF9jbGllbnQub25SZWZyZXNoKSgpO1xuICAgICAgICAgICAgICAgIHJlcG9ydEhtckxhdGVuY3kodXBkYXRlZE1vZHVsZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21IbXJFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tSG1yRXZlbnRIYW5kbGVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG4vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCkge1xuICAgIC8qIGdsb2JhbHMgX193ZWJwYWNrX2hhc2hfXyAqLyAvLyBfX3dlYnBhY2tfaGFzaF9fIGlzIHRoZSBoYXNoIG9mIHRoZSBjdXJyZW50IGNvbXBpbGF0aW9uLlxuICAgIC8vIEl0J3MgYSBnbG9iYWwgdmFyaWFibGUgaW5qZWN0ZWQgYnkgV2VicGFjay5cbiAgICByZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfXztcbn1cbi8vIFdlYnBhY2sgZGlzYWxsb3dzIHVwZGF0ZXMgaW4gb3RoZXIgc3RhdGVzLlxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogbW9kdWxlLmhvdCBleGlzdHMgYnV0IHR5cGUgbmVlZHMgdG8gYmUgYWRkZWQuIENhbid0IHVzZSBgYXMgYW55YCBoZXJlIGFzIHdlYnBhY2sgcGFyc2VzIGZvciBgbW9kdWxlLmhvdGAgY2FsbHMuXG4gICAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiO1xufVxuZnVuY3Rpb24gYWZ0ZXJBcHBseVVwZGF0ZXMoZm4pIHtcbiAgICBpZiAoY2FuQXBwbHlVcGRhdGVzKCkpIHtcbiAgICAgICAgZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKHN0YXR1cykge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IG1vZHVsZS5ob3QgZXhpc3RzIGJ1dCB0eXBlIG5lZWRzIHRvIGJlIGFkZGVkLiBDYW4ndCB1c2UgYGFzIGFueWAgaGVyZSBhcyB3ZWJwYWNrIHBhcnNlcyBmb3IgYG1vZHVsZS5ob3RgIGNhbGxzLlxuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogbW9kdWxlLmhvdCBleGlzdHMgYnV0IHR5cGUgbmVlZHMgdG8gYmUgYWRkZWQuIENhbid0IHVzZSBgYXMgYW55YCBoZXJlIGFzIHdlYnBhY2sgcGFyc2VzIGZvciBgbW9kdWxlLmhvdGAgY2FsbHMuXG4gICAgICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG59XG4vLyBBdHRlbXB0IHRvIHVwZGF0ZSBjb2RlIG9uIHRoZSBmbHksIGZhbGwgYmFjayB0byBhIGhhcmQgcmVsb2FkLlxuZnVuY3Rpb24gdHJ5QXBwbHlVcGRhdGVzKG9uQmVmb3JlSG90VXBkYXRlLCBvbkhvdFVwZGF0ZVN1Y2Nlc3MpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IG1vZHVsZS5ob3QgZXhpc3RzIGJ1dCB0eXBlIG5lZWRzIHRvIGJlIGFkZGVkLiBDYW4ndCB1c2UgYGFzIGFueWAgaGVyZSBhcyB3ZWJwYWNrIHBhcnNlcyBmb3IgYG1vZHVsZS5ob3RgIGNhbGxzLlxuICAgIGlmICghbW9kdWxlLmhvdCkge1xuICAgICAgICAvLyBIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbiBpcyBub3QgaW4gV2VicGFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICBjb25zb2xlLmVycm9yKFwiSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gaXMgbm90IGluIFdlYnBhY2sgY29uZmlndXJhdGlvbi5cIik7XG4gICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzVXBkYXRlQXZhaWxhYmxlKCkgfHwgIWNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgICAgICgwLCBfY2xpZW50Lm9uQnVpbGRPaykoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBcHBseVVwZGF0ZXMoZXJyLCB1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICBpZiAoZXJyIHx8IF9ydW50aW1lZXJyb3JoYW5kbGVyLlJ1bnRpbWVFcnJvckhhbmRsZXIuaGFkUnVudGltZUVycm9yIHx8ICF1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWRcXG5cXG5cIiArIFwiRmFzdCBSZWZyZXNoIHdpbGwgcGVyZm9ybSBhIGZ1bGwgcmVsb2FkIHdoZW4geW91IGVkaXQgYSBmaWxlIHRoYXQncyBpbXBvcnRlZCBieSBtb2R1bGVzIG91dHNpZGUgb2YgdGhlIFJlYWN0IHJlbmRlcmluZyB0cmVlLlxcblwiICsgXCJZb3UgbWlnaHQgaGF2ZSBhIGZpbGUgd2hpY2ggZXhwb3J0cyBhIFJlYWN0IGNvbXBvbmVudCBidXQgYWxzbyBleHBvcnRzIGEgdmFsdWUgdGhhdCBpcyBpbXBvcnRlZCBieSBhIG5vbi1SZWFjdCBjb21wb25lbnQgZmlsZS5cXG5cIiArIFwiQ29uc2lkZXIgbWlncmF0aW5nIHRoZSBub24tUmVhY3QgY29tcG9uZW50IGV4cG9ydCB0byBhIHNlcGFyYXRlIGZpbGUgYW5kIGltcG9ydGluZyBpdCBpbnRvIGJvdGggZmlsZXMuXFxuXFxuXCIgKyBcIkl0IGlzIGFsc28gcG9zc2libGUgdGhlIHBhcmVudCBjb21wb25lbnQgb2YgdGhlIGNvbXBvbmVudCB5b3UgZWRpdGVkIGlzIGEgY2xhc3MgY29tcG9uZW50LCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuXCIgKyBcIkZhc3QgUmVmcmVzaCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgcGFyZW50IGZ1bmN0aW9uIGNvbXBvbmVudCBpbiB5b3VyIFJlYWN0IHRyZWUuXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfcnVudGltZWVycm9yaGFuZGxlci5SdW50aW1lRXJyb3JIYW5kbGVyLmhhZFJ1bnRpbWVFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltGYXN0IFJlZnJlc2hdIHBlcmZvcm1pbmcgZnVsbCByZWxvYWQgYmVjYXVzZSB5b3VyIGFwcGxpY2F0aW9uIGhhZCBhbiB1bnJlY292ZXJhYmxlIGVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVyZm9ybUZ1bGxSZWxvYWQoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uSG90VXBkYXRlU3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBNYXliZSB3ZSB3YW50IHRvIGRvIHNvbWV0aGluZy5cbiAgICAgICAgICAgIG9uSG90VXBkYXRlU3VjY2Vzcyh1cGRhdGVkTW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVXBkYXRlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIFdoaWxlIHdlIHdlcmUgdXBkYXRpbmcsIHRoZXJlIHdhcyBhIG5ldyB1cGRhdGUhIERvIGl0IGFnYWluLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhpcyB0aW1lLCBkb24ndCB0cmlnZ2VyIGEgcGVuZGluZyByZWZyZXNoIHN0YXRlLlxuICAgICAgICAgICAgdHJ5QXBwbHlVcGRhdGVzKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCA+IDAgPyB1bmRlZmluZWQgOiBvbkJlZm9yZUhvdFVwZGF0ZSwgdXBkYXRlZE1vZHVsZXMubGVuZ3RoID4gMCA/IF9jbGllbnQub25CdWlsZE9rIDogb25Ib3RVcGRhdGVTdWNjZXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICgwLCBfY2xpZW50Lm9uQnVpbGRPaykoKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJBcHBseVVwZGF0ZXMoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jY2hlY2tcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IG1vZHVsZS5ob3QgZXhpc3RzIGJ1dCB0eXBlIG5lZWRzIHRvIGJlIGFkZGVkLiBDYW4ndCB1c2UgYGFzIGFueWAgaGVyZSBhcyB3ZWJwYWNrIHBhcnNlcyBmb3IgYG1vZHVsZS5ob3RgIGNhbGxzLlxuICAgIG1vZHVsZS5ob3QuY2hlY2soLyogYXV0b0FwcGx5ICovIGZhbHNlKS50aGVuKCh1cGRhdGVkTW9kdWxlcyk9PntcbiAgICAgICAgaWYgKCF1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvbkJlZm9yZUhvdFVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvbkJlZm9yZUhvdFVwZGF0ZSh1cGRhdGVkTW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBtb2R1bGUuaG90IGV4aXN0cyBidXQgdHlwZSBuZWVkcyB0byBiZSBhZGRlZC4gQ2FuJ3QgdXNlIGBhcyBhbnlgIGhlcmUgYXMgd2VicGFjayBwYXJzZXMgZm9yIGBtb2R1bGUuaG90YCBjYWxscy5cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5ob3QuYXBwbHkoKTtcbiAgICB9KS50aGVuKCh1cGRhdGVkTW9kdWxlcyk9PntcbiAgICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKG51bGwsIHVwZGF0ZWRNb2R1bGVzKTtcbiAgICB9LCAoZXJyKT0+e1xuICAgICAgICBoYW5kbGVBcHBseVVwZGF0ZXMoZXJyLCBudWxsKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1GdWxsUmVsb2FkKGVycikge1xuICAgIGNvbnN0IHN0YWNrVHJhY2UgPSBlcnIgJiYgKGVyci5zdGFjayAmJiBlcnIuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMCwgNSkuam9pbihcIlxcblwiKSB8fCBlcnIubWVzc2FnZSB8fCBlcnIgKyBcIlwiKTtcbiAgICAoMCwgX3dlYnNvY2tldC5zZW5kTWVzc2FnZSkoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBldmVudDogXCJjbGllbnQtZnVsbC1yZWxvYWRcIixcbiAgICAgICAgc3RhY2tUcmFjZSxcbiAgICAgICAgaGFkUnVudGltZUVycm9yOiAhIV9ydW50aW1lZXJyb3JoYW5kbGVyLlJ1bnRpbWVFcnJvckhhbmRsZXIuaGFkUnVudGltZUVycm9yLFxuICAgICAgICBkZXBlbmRlbmN5Q2hhaW46IGVyciA/IGVyci5kZXBlbmRlbmN5Q2hhaW4gOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3QtcmVsb2FkZXItY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIm8iLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJsZW5ndGgiLCJpIiwiRiIsInMiLCJuIiwiZG9uZSIsInZhbHVlIiwiZSIsIl9lIiwiZiIsIlR5cGVFcnJvciIsIm5vcm1hbENvbXBsZXRpb24iLCJkaWRFcnIiLCJlcnIiLCJjYWxsIiwic3RlcCIsIm5leHQiLCJfZTIiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJmcm9tIiwidGVzdCIsImFyciIsImxlbiIsImFycjIiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJtb2R1bGUiLCJwZXJmb3JtRnVsbFJlbG9hZCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJjb25uZWN0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9jbGllbnQiLCJfc3RyaXBhbnNpIiwiXyIsIl93ZWJzb2NrZXQiLCJfZm9ybWF0d2VicGFja21lc3NhZ2VzIiwiX2hvdHJlbG9hZGVydHlwZXMiLCJfZXh0cmFjdG1vZHVsZXNmcm9tdHVyYm9wYWNrbWVzc2FnZSIsIl9zaGFyZWQiLCJfcnVudGltZWVycm9yaGFuZGxlciIsIndpbmRvdyIsIl9fbmV4dERldkNsaWVudElkIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiRGF0ZSIsIm5vdyIsImN1c3RvbUhtckV2ZW50SGFuZGxlciIsInR1cmJvcGFja01lc3NhZ2VMaXN0ZW5lcnMiLCJNT0RFIiwibW9kZSIsInJlZ2lzdGVyIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwicGF5bG9hZCIsInByb2Nlc3NNZXNzYWdlIiwiX2Vycl9zdGFjayIsImNvbnNvbGUiLCJ3YXJuIiwic3RhY2siLCJzdWJzY3JpYmVUb0htckV2ZW50IiwiaGFuZGxlciIsIm9uVW5yZWNvdmVyYWJsZUVycm9yIiwiUnVudGltZUVycm9ySGFuZGxlciIsImhhZFJ1bnRpbWVFcnJvciIsImFkZFR1cmJvcGFja01lc3NhZ2VMaXN0ZW5lciIsImNiIiwicHVzaCIsInNlbmRUdXJib3BhY2tNZXNzYWdlIiwibXNnIiwic2VuZE1lc3NhZ2UiLCJoYW5kbGVVcGRhdGVFcnJvciIsImlzRmlyc3RDb21waWxhdGlvbiIsIm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2giLCJoYXNDb21waWxlRXJyb3JzIiwiY2xlYXJPdXRkYXRlZEVycm9ycyIsImNsZWFyIiwiaGFuZGxlU3VjY2VzcyIsImlzSG90VXBkYXRlIiwiX19ORVhUX0RBVEFfXyIsInBhZ2UiLCJpc1VwZGF0ZUF2YWlsYWJsZSIsInRyeUFwcGx5VXBkYXRlcyIsIm9uQmVmb3JlRmFzdFJlZnJlc2giLCJvbkZhc3RSZWZyZXNoIiwib25CdWlsZE9rIiwiaGFuZGxlV2FybmluZ3MiLCJ3YXJuaW5ncyIsInByaW50V2FybmluZ3MiLCJmb3JtYXR0ZWQiLCJlcnJvcnMiLCJfZm9ybWF0dGVkX3dhcm5pbmdzIiwiaGFuZGxlRXJyb3JzIiwib25CdWlsZEVycm9yIiwiZXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1RFU1RfTU9ERSIsInNlbGYiLCJfX05FWFRfSE1SX0NCIiwic3RhcnRMYXRlbmN5IiwidW5kZWZpbmVkIiwidXBkYXRlZE1vZHVsZXMiLCJvbkJlZm9yZVJlZnJlc2giLCJvblJlZnJlc2giLCJyZXBvcnRIbXJMYXRlbmN5IiwiZW5kTGF0ZW5jeSIsImxhdGVuY3kiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwiZXZlbnQiLCJpZCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiaXNQYWdlSGlkZGVuIiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJfX05FWFRfSE1SX0xBVEVOQ1lfQ0IiLCJoYW5kbGVBdmFpbGFibGVIYXNoIiwiaGFzaCIsIm9iaiIsImFjdGlvbiIsIkhNUl9BQ1RJT05TX1NFTlRfVE9fQlJPV1NFUiIsIkJVSUxESU5HIiwiQlVJTFQiLCJTWU5DIiwib25WZXJzaW9uSW5mbyIsInZlcnNpb25JbmZvIiwiaGFzRXJyb3JzIiwiQm9vbGVhbiIsImVycm9yQ291bnQiLCJjbGllbnRJZCIsImhhc1dhcm5pbmdzIiwid2FybmluZ0NvdW50IiwiU0VSVkVSX0NPTVBPTkVOVF9DSEFOR0VTIiwicmVsb2FkIiwiU0VSVkVSX0VSUk9SIiwiZXJyb3JKU09OIiwiX0pTT04kcGFyc2UiLCJwYXJzZSIsIm1lc3NhZ2UiLCJFcnJvciIsIlRVUkJPUEFDS19DT05ORUNURUQiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImxpc3RlbmVyIiwidHlwZSIsIlRVUkJPUEFDS19NRVNTQUdFIiwiZXh0cmFjdE1vZHVsZXNGcm9tVHVyYm9wYWNrTWVzc2FnZSIsImRhdGEiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SIiwiX193ZWJwYWNrX2hhc2hfXyIsImNhbkFwcGx5VXBkYXRlcyIsImhvdCIsInN0YXR1cyIsImFmdGVyQXBwbHlVcGRhdGVzIiwiZm4iLCJyZW1vdmVTdGF0dXNIYW5kbGVyIiwiYWRkU3RhdHVzSGFuZGxlciIsIm9uQmVmb3JlSG90VXBkYXRlIiwib25Ib3RVcGRhdGVTdWNjZXNzIiwiaGFuZGxlQXBwbHlVcGRhdGVzIiwiY2hlY2siLCJ0aGVuIiwiYXBwbHkiLCJzdGFja1RyYWNlIiwic3BsaXQiLCJqb2luIiwiZGVwZW5kZW5jeUNoYWluIiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/react-dev-overlay/pages/hot-reloader-client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/react-dev-overlay/pages/websocket.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/pages/websocket.js ***!
  \***************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  addMessageListener: function addMessageListener() {\n    return _addMessageListener;\n  },\n  connectHMR: function connectHMR() {\n    return _connectHMR;\n  },\n  sendMessage: function sendMessage() {\n    return _sendMessage;\n  }\n});\nvar _getsocketurl = __webpack_require__(/*! ../internal/helpers/get-socket-url */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/get-socket-url.js\");\nvar source;\nvar eventCallbacks = [];\nfunction _addMessageListener(callback) {\n  eventCallbacks.push(callback);\n}\nfunction _sendMessage(data) {\n  if (!source || source.readyState !== source.OPEN) return;\n  return source.send(data);\n}\nvar reconnections = 0;\nfunction _connectHMR(options) {\n  function init() {\n    if (source) source.close();\n    function handleOnline() {\n      reconnections = 0;\n      window.console.log(\"[HMR] connected\");\n    }\n    function handleMessage(event) {\n      // Coerce into HMR_ACTION_TYPES as that is the format.\n      var msg = JSON.parse(event.data);\n      var _iterator = _createForOfIteratorHelper(eventCallbacks),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var eventCallback = _step.value;\n          eventCallback(msg);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    var timer;\n    function handleDisconnect() {\n      source.onerror = null;\n      source.onclose = null;\n      source.close();\n      reconnections++;\n      // After 25 reconnects we'll want to reload the page as it indicates the dev server is no longer running.\n      if (reconnections > 25) {\n        window.location.reload();\n        return;\n      }\n      clearTimeout(timer);\n      // Try again after 5 seconds\n      timer = setTimeout(init, reconnections > 5 ? 5000 : 1000);\n    }\n    var url = (0, _getsocketurl.getSocketUrl)(options.assetPrefix);\n    source = new window.WebSocket(\"\" + url + options.path);\n    source.onopen = handleOnline;\n    source.onerror = handleDisconnect;\n    source.onclose = handleDisconnect;\n    source.onmessage = handleMessage;\n  }\n  init();\n}\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFBQSxTQUFBQSwyQkFBQUMsQ0FBQSxFQUFBQyxjQUFBLFFBQUFDLEVBQUEsVUFBQUMsTUFBQSxvQkFBQUgsQ0FBQSxDQUFBRyxNQUFBLENBQUFDLFFBQUEsS0FBQUosQ0FBQSxxQkFBQUUsRUFBQSxRQUFBRyxLQUFBLENBQUFDLE9BQUEsQ0FBQU4sQ0FBQSxNQUFBRSxFQUFBLEdBQUFLLDJCQUFBLENBQUFQLENBQUEsTUFBQUMsY0FBQSxJQUFBRCxDQUFBLFdBQUFBLENBQUEsQ0FBQVEsTUFBQSxxQkFBQU4sRUFBQSxFQUFBRixDQUFBLEdBQUFFLEVBQUEsTUFBQU8sQ0FBQSxVQUFBQyxDQUFBLFlBQUFBLEVBQUEsZUFBQUMsQ0FBQSxFQUFBRCxDQUFBLEVBQUFFLENBQUEsV0FBQUEsRUFBQSxRQUFBSCxDQUFBLElBQUFULENBQUEsQ0FBQVEsTUFBQSxXQUFBSyxJQUFBLG1CQUFBQSxJQUFBLFNBQUFDLEtBQUEsRUFBQWQsQ0FBQSxDQUFBUyxDQUFBLFVBQUFNLENBQUEsV0FBQUEsRUFBQUMsRUFBQSxVQUFBQSxFQUFBLEtBQUFDLENBQUEsRUFBQVAsQ0FBQSxnQkFBQVEsU0FBQSxpSkFBQUMsZ0JBQUEsU0FBQUMsTUFBQSxVQUFBQyxHQUFBLFdBQUFWLENBQUEsV0FBQUEsRUFBQSxJQUFBVCxFQUFBLEdBQUFBLEVBQUEsQ0FBQW9CLElBQUEsQ0FBQXRCLENBQUEsTUFBQVksQ0FBQSxXQUFBQSxFQUFBLFFBQUFXLElBQUEsR0FBQXJCLEVBQUEsQ0FBQXNCLElBQUEsSUFBQUwsZ0JBQUEsR0FBQUksSUFBQSxDQUFBVixJQUFBLFNBQUFVLElBQUEsS0FBQVIsQ0FBQSxXQUFBQSxFQUFBVSxHQUFBLElBQUFMLE1BQUEsU0FBQUMsR0FBQSxHQUFBSSxHQUFBLEtBQUFSLENBQUEsV0FBQUEs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LEdBQUdILEdBQUcsR0FBR3ZCLE9BQU8sQ0FBQzJCLElBQUksQ0FBQztJQUN0RHBDLE1BQU0sQ0FBQ3FDLE1BQU0sR0FBR3pCLFlBQVk7SUFDNUJaLE1BQU0sQ0FBQzBCLE9BQU8sR0FBR0QsZ0JBQWdCO0lBQ2pDekIsTUFBTSxDQUFDMkIsT0FBTyxHQUFHRixnQkFBZ0I7SUFDakN6QixNQUFNLENBQUNzQyxTQUFTLEdBQUd0QixhQUFhO0VBQ3BDO0VBQ0FOLElBQUksQ0FBQyxDQUFDO0FBQ1Y7QUFFQSxJQUFJLENBQUMsT0FBT3RCLE9BQU8sV0FBUSxLQUFLLFVBQVUsSUFBSyxPQUFPQSxPQUFPLFdBQVEsS0FBSyxRQUFRLElBQUlBLE9BQU8sV0FBUSxLQUFLLElBQUssS0FBSyxPQUFPQSxPQUFPLFdBQVEsQ0FBQ21ELFVBQVUsS0FBSyxXQUFXLEVBQUU7RUFDcksvRCxNQUFNLENBQUNXLGNBQWMsQ0FBQ0MsT0FBTyxXQUFRLEVBQUUsWUFBWSxFQUFFO0lBQUUxQixLQUFLLEVBQUU7RUFBSyxDQUFDLENBQUM7RUFDckVjLE1BQU0sQ0FBQ2dFLE1BQU0sQ0FBQ3BELE9BQU8sV0FBUSxFQUFFQSxPQUFPLENBQUM7RUFDdkNDLE1BQU0sQ0FBQ0QsT0FBTyxHQUFHQSxPQUFPLFdBQVE7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9wYWdlcy93ZWJzb2NrZXQuanM/ZDBhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogbnVsbCxcbiAgICBjb25uZWN0SE1SOiBudWxsLFxuICAgIHNlbmRNZXNzYWdlOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhZGRNZXNzYWdlTGlzdGVuZXI7XG4gICAgfSxcbiAgICBjb25uZWN0SE1SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RITVI7XG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZW5kTWVzc2FnZTtcbiAgICB9XG59KTtcbmNvbnN0IF9nZXRzb2NrZXR1cmwgPSByZXF1aXJlKFwiLi4vaW50ZXJuYWwvaGVscGVycy9nZXQtc29ja2V0LXVybFwiKTtcbmxldCBzb3VyY2U7XG5jb25zdCBldmVudENhbGxiYWNrcyA9IFtdO1xuZnVuY3Rpb24gYWRkTWVzc2FnZUxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgZXZlbnRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBzZW5kTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLnJlYWR5U3RhdGUgIT09IHNvdXJjZS5PUEVOKSByZXR1cm47XG4gICAgcmV0dXJuIHNvdXJjZS5zZW5kKGRhdGEpO1xufVxubGV0IHJlY29ubmVjdGlvbnMgPSAwO1xuZnVuY3Rpb24gY29ubmVjdEhNUihvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkgc291cmNlLmNsb3NlKCk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU9ubGluZSgpIHtcbiAgICAgICAgICAgIHJlY29ubmVjdGlvbnMgPSAwO1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKFwiW0hNUl0gY29ubmVjdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIENvZXJjZSBpbnRvIEhNUl9BQ1RJT05fVFlQRVMgYXMgdGhhdCBpcyB0aGUgZm9ybWF0LlxuICAgICAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnRDYWxsYmFjayBvZiBldmVudENhbGxiYWNrcyl7XG4gICAgICAgICAgICAgICAgZXZlbnRDYWxsYmFjayhtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lcjtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZS5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgICAgcmVjb25uZWN0aW9ucysrO1xuICAgICAgICAgICAgLy8gQWZ0ZXIgMjUgcmVjb25uZWN0cyB3ZSdsbCB3YW50IHRvIHJlbG9hZCB0aGUgcGFnZSBhcyBpdCBpbmRpY2F0ZXMgdGhlIGRldiBzZXJ2ZXIgaXMgbm8gbG9uZ2VyIHJ1bm5pbmcuXG4gICAgICAgICAgICBpZiAocmVjb25uZWN0aW9ucyA+IDI1KSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAvLyBUcnkgYWdhaW4gYWZ0ZXIgNSBzZWNvbmRzXG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoaW5pdCwgcmVjb25uZWN0aW9ucyA+IDUgPyA1MDAwIDogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gKDAsIF9nZXRzb2NrZXR1cmwuZ2V0U29ja2V0VXJsKShvcHRpb25zLmFzc2V0UHJlZml4KTtcbiAgICAgICAgc291cmNlID0gbmV3IHdpbmRvdy5XZWJTb2NrZXQoXCJcIiArIHVybCArIG9wdGlvbnMucGF0aCk7XG4gICAgICAgIHNvdXJjZS5vbm9wZW4gPSBoYW5kbGVPbmxpbmU7XG4gICAgICAgIHNvdXJjZS5vbmVycm9yID0gaGFuZGxlRGlzY29ubmVjdDtcbiAgICAgICAgc291cmNlLm9uY2xvc2UgPSBoYW5kbGVEaXNjb25uZWN0O1xuICAgICAgICBzb3VyY2Uub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTtcbiAgICB9XG4gICAgaW5pdCgpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJzb2NrZXQuanMubWFwIl0sIm5hbWVzIjpbIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwibyIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkFycmF5IiwiaXNBcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImxlbmd0aCIsImkiLCJGIiwicyIsIm4iLCJkb25lIiwidmFsdWUiLCJlIiwiX2UiLCJmIiwiVHlwZUVycm9yIiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsImVyciIsImNhbGwiLCJzdGVwIiwibmV4dCIsIl9lMiIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb20iLCJ0ZXN0IiwiYXJyIiwibGVuIiwiYXJyMiIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImNvbm5lY3RITVIiLCJzZW5kTWVzc2FnZSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2dldHNvY2tldHVybCIsInJlcXVpcmUiLCJzb3VyY2UiLCJldmVudENhbGxiYWNrcyIsImNhbGxiYWNrIiwicHVzaCIsImRhdGEiLCJyZWFkeVN0YXRlIiwiT1BFTiIsInNlbmQiLCJyZWNvbm5lY3Rpb25zIiwib3B0aW9ucyIsImluaXQiLCJjbG9zZSIsImhhbmRsZU9ubGluZSIsIndpbmRvdyIsImNvbnNvbGUiLCJsb2ciLCJoYW5kbGVNZXNzYWdlIiwiZXZlbnQiLCJtc2ciLCJKU09OIiwicGFyc2UiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImV2ZW50Q2FsbGJhY2siLCJ0aW1lciIsImhhbmRsZURpc2Nvbm5lY3QiLCJvbmVycm9yIiwib25jbG9zZSIsImxvY2F0aW9uIiwicmVsb2FkIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInVybCIsImdldFNvY2tldFVybCIsImFzc2V0UHJlZml4IiwiV2ViU29ja2V0IiwicGF0aCIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/react-dev-overlay/pages/websocket.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/react-dev-overlay/shared.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/shared.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar _defineProperty = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty.js\");\nvar _toConsumableArray = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  ACTION_BEFORE_REFRESH: function ACTION_BEFORE_REFRESH() {\n    return _ACTION_BEFORE_REFRESH;\n  },\n  ACTION_BUILD_ERROR: function ACTION_BUILD_ERROR() {\n    return _ACTION_BUILD_ERROR;\n  },\n  ACTION_BUILD_OK: function ACTION_BUILD_OK() {\n    return _ACTION_BUILD_OK;\n  },\n  ACTION_REFRESH: function ACTION_REFRESH() {\n    return _ACTION_REFRESH;\n  },\n  ACTION_UNHANDLED_ERROR: function ACTION_UNHANDLED_ERROR() {\n    return _ACTION_UNHANDLED_ERROR;\n  },\n  ACTION_UNHANDLED_REJECTION: function ACTION_UNHANDLED_REJECTION() {\n    return _ACTION_UNHANDLED_REJECTION;\n  },\n  ACTION_VERSION_INFO: function ACTION_VERSION_INFO() {\n    return _ACTION_VERSION_INFO;\n  },\n  INITIAL_OVERLAY_STATE: function INITIAL_OVERLAY_STATE() {\n    return _INITIAL_OVERLAY_STATE;\n  },\n  REACT_REFRESH_FULL_RELOAD_FROM_ERROR: function REACT_REFRESH_FULL_RELOAD_FROM_ERROR() {\n    return _REACT_REFRESH_FULL_RELOAD_FROM_ERROR;\n  },\n  useErrorOverlayReducer: function useErrorOverlayReducer() {\n    return _useErrorOverlayReducer;\n  }\n});\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _ACTION_BUILD_OK = \"build-ok\";\nvar _ACTION_BUILD_ERROR = \"build-error\";\nvar _ACTION_BEFORE_REFRESH = \"before-fast-refresh\";\nvar _ACTION_REFRESH = \"fast-refresh\";\nvar _ACTION_VERSION_INFO = \"version-info\";\nvar _ACTION_UNHANDLED_ERROR = \"unhandled-error\";\nvar _ACTION_UNHANDLED_REJECTION = \"unhandled-rejection\";\nfunction pushErrorFilterDuplicates(errors, err) {\n  return [].concat(_toConsumableArray(errors.filter(function (e) {\n    // Filter out duplicate errors\n    return e.event.reason !== err.event.reason;\n  })), [err]);\n}\nvar _INITIAL_OVERLAY_STATE = {\n  nextId: 1,\n  buildError: null,\n  errors: [],\n  notFound: false,\n  refreshState: {\n    type: \"idle\"\n  },\n  rootLayoutMissingTags: [],\n  versionInfo: {\n    installed: \"0.0.0\",\n    staleness: \"unknown\"\n  }\n};\nfunction _useErrorOverlayReducer() {\n  return (0, _react.useReducer)(function (_state, action) {\n    switch (action.type) {\n      case _ACTION_BUILD_OK:\n        {\n          return _objectSpread(_objectSpread({}, _state), {}, {\n            buildError: null\n          });\n        }\n      case _ACTION_BUILD_ERROR:\n        {\n          return _objectSpread(_objectSpread({}, _state), {}, {\n            buildError: action.message\n          });\n        }\n      case _ACTION_BEFORE_REFRESH:\n        {\n          return _objectSpread(_objectSpread({}, _state), {}, {\n            refreshState: {\n              type: \"pending\",\n              errors: []\n            }\n          });\n        }\n      case _ACTION_REFRESH:\n        {\n          return _objectSpread(_objectSpread({}, _state), {}, {\n            buildError: null,\n            errors:\n            // Errors can come in during updates. In this case, UNHANDLED_ERROR\n            // and UNHANDLED_REJECTION events might be dispatched between the\n            // BEFORE_REFRESH and the REFRESH event. We want to keep those errors\n            // around until the next refresh. Otherwise we run into a race\n            // condition where those errors would be cleared on refresh completion\n            // before they can be displayed.\n            _state.refreshState.type === \"pending\" ? _state.refreshState.errors : [],\n            refreshState: {\n              type: \"idle\"\n            }\n          });\n        }\n      case _ACTION_UNHANDLED_ERROR:\n      case _ACTION_UNHANDLED_REJECTION:\n        {\n          switch (_state.refreshState.type) {\n            case \"idle\":\n              {\n                return _objectSpread(_objectSpread({}, _state), {}, {\n                  nextId: _state.nextId + 1,\n                  errors: pushErrorFilterDuplicates(_state.errors, {\n                    id: _state.nextId,\n                    event: action\n                  })\n                });\n              }\n            case \"pending\":\n              {\n                return _objectSpread(_objectSpread({}, _state), {}, {\n                  nextId: _state.nextId + 1,\n                  refreshState: _objectSpread(_objectSpread({}, _state.refreshState), {}, {\n                    errors: pushErrorFilterDuplicates(_state.refreshState.errors, {\n                      id: _state.nextId,\n                      event: action\n                    })\n                  })\n                });\n              }\n            default:\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              var _ = _state.refreshState;\n              return _state;\n          }\n        }\n      case _ACTION_VERSION_INFO:\n        {\n          return _objectSpread(_objectSpread({}, _state), {}, {\n            versionInfo: action.versionInfo\n          });\n        }\n      default:\n        {\n          return _state;\n        }\n    }\n  }, _INITIAL_OVERLAY_STATE);\n}\nvar _REACT_REFRESH_FULL_RELOAD_FROM_ERROR = \"[Fast Refresh] performing full reload because your application had an unrecoverable error\";\nif ((typeof exports[\"default\"] === 'function' || typeof exports[\"default\"] === 'object' && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === 'undefined') {\n  Object.defineProperty(exports[\"default\"], '__esModule', {\n    value: true\n  });\n  Object.assign(exports[\"default\"], exports);\n  module.exports = exports[\"default\"];\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3NoYXJlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFBQSxJQUFBQSxlQUFBLEdBQUFDLG1CQUFBO0FBQUEsSUFBQUMsa0JBQUEsR0FBQUQsbUJBQUE7QUFBQSxTQUFBRSxRQUFBQyxDQUFBLEVBQUFDLENBQUEsUUFBQUMsQ0FBQSxHQUFBQyxNQUFBLENBQUFDLElBQUEsQ0FBQUosQ0FBQSxPQUFBRyxNQUFBLENBQUFFLHFCQUFBLFFBQUFDLENBQUEsR0FBQUgsTUFBQSxDQUFBRSxxQkFBQSxDQUFBTCxDQUFBLEdBQUFDLENBQUEsS0FBQUssQ0FBQSxHQUFBQSxDQUFBLENBQUFDLE1BQUEsV0FBQU4sQ0FBQSxXQUFBRSxNQUFBLENBQUFLLHdCQUFBLENBQUFSLENBQUEsRUFBQUMsQ0FBQSxFQUFBUSxVQUFBLE9BQUFQLENBQUEsQ0FBQVEsSUFBQSxDQUFBQyxLQUFBLENBQUFULENBQUEsRUFBQUksQ0FBQSxZQUFBSixDQUFBO0FBQUEsU0FBQVUsY0FBQVosQ0FBQSxhQUFBQyxDQUFBLE1BQUFBLENBQUEsR0FBQVksU0FBQSxDQUFBQyxNQUFBLEVBQUFiLENBQUEsVUFBQUMsQ0FBQSxXQUFBVyxTQUFBLENBQUFaLENBQUEsSUFBQVksU0FBQSxDQUFBWixDQUFBLFFBQUFBLENBQUEsT0FBQUYsT0FBQSxDQUFBSSxNQUFBLENBQUFELENBQUEsT0FBQWEsT0FBQSxXQUFBZCxDQUFBLElBQUFMLGVBQUEsQ0FBQUksQ0FBQSxFQUFBQyxDQUFBLEVBQUFDLENBQUEsQ0FBQUQsQ0FBQSxTQUFBRSxNQUFBLENBQUFhLHlCQUFBLEdBQUFiLE1BQUEsQ0FBQWMsZ0JBQUEsQ0FBQWpCLENBQUEsRUFBQUcsTUFBQSxDQUFBYSx5QkFBQSxDQUFBZCxDQUFBLEtBQUFILE9BQUEsQ0FBQUksTUFBQSxDQUFBRCxDQUFBLEdBQUFhLE9BQUEsV0FBQWQsQ0FBQSxJQUFBRSxNQUFB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QUFZLEVBQUU7SUFBRUMsS0FBSyxFQUFFO0VBQUssQ0FBQyxDQUFDO0VBQ3JFakIsTUFBTSxDQUFDeUQsTUFBTSxDQUFDekMsT0FBTyxXQUFRLEVBQUVBLE9BQU8sQ0FBQztFQUN2Q0UsTUFBTSxDQUFDRixPQUFPLEdBQUdBLE9BQU8sV0FBUTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3NoYXJlZC5qcz9iY2NkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQUNUSU9OX0JFRk9SRV9SRUZSRVNIOiBudWxsLFxuICAgIEFDVElPTl9CVUlMRF9FUlJPUjogbnVsbCxcbiAgICBBQ1RJT05fQlVJTERfT0s6IG51bGwsXG4gICAgQUNUSU9OX1JFRlJFU0g6IG51bGwsXG4gICAgQUNUSU9OX1VOSEFORExFRF9FUlJPUjogbnVsbCxcbiAgICBBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTjogbnVsbCxcbiAgICBBQ1RJT05fVkVSU0lPTl9JTkZPOiBudWxsLFxuICAgIElOSVRJQUxfT1ZFUkxBWV9TVEFURTogbnVsbCxcbiAgICBSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1I6IG51bGwsXG4gICAgdXNlRXJyb3JPdmVybGF5UmVkdWNlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBBQ1RJT05fQkVGT1JFX1JFRlJFU0g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX0JFRk9SRV9SRUZSRVNIO1xuICAgIH0sXG4gICAgQUNUSU9OX0JVSUxEX0VSUk9SOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9CVUlMRF9FUlJPUjtcbiAgICB9LFxuICAgIEFDVElPTl9CVUlMRF9PSzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fQlVJTERfT0s7XG4gICAgfSxcbiAgICBBQ1RJT05fUkVGUkVTSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUkVGUkVTSDtcbiAgICB9LFxuICAgIEFDVElPTl9VTkhBTkRMRURfRVJST1I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1VOSEFORExFRF9FUlJPUjtcbiAgICB9LFxuICAgIEFDVElPTl9VTkhBTkRMRURfUkVKRUNUSU9OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9VTkhBTkRMRURfUkVKRUNUSU9OO1xuICAgIH0sXG4gICAgQUNUSU9OX1ZFUlNJT05fSU5GTzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fVkVSU0lPTl9JTkZPO1xuICAgIH0sXG4gICAgSU5JVElBTF9PVkVSTEFZX1NUQVRFOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIElOSVRJQUxfT1ZFUkxBWV9TVEFURTtcbiAgICB9LFxuICAgIFJFQUNUX1JFRlJFU0hfRlVMTF9SRUxPQURfRlJPTV9FUlJPUjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSRUFDVF9SRUZSRVNIX0ZVTExfUkVMT0FEX0ZST01fRVJST1I7XG4gICAgfSxcbiAgICB1c2VFcnJvck92ZXJsYXlSZWR1Y2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZUVycm9yT3ZlcmxheVJlZHVjZXI7XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBBQ1RJT05fQlVJTERfT0sgPSBcImJ1aWxkLW9rXCI7XG5jb25zdCBBQ1RJT05fQlVJTERfRVJST1IgPSBcImJ1aWxkLWVycm9yXCI7XG5jb25zdCBBQ1RJT05fQkVGT1JFX1JFRlJFU0ggPSBcImJlZm9yZS1mYXN0LXJlZnJlc2hcIjtcbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gXCJmYXN0LXJlZnJlc2hcIjtcbmNvbnN0IEFDVElPTl9WRVJTSU9OX0lORk8gPSBcInZlcnNpb24taW5mb1wiO1xuY29uc3QgQUNUSU9OX1VOSEFORExFRF9FUlJPUiA9IFwidW5oYW5kbGVkLWVycm9yXCI7XG5jb25zdCBBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTiA9IFwidW5oYW5kbGVkLXJlamVjdGlvblwiO1xuZnVuY3Rpb24gcHVzaEVycm9yRmlsdGVyRHVwbGljYXRlcyhlcnJvcnMsIGVycikge1xuICAgIHJldHVybiBbXG4gICAgICAgIC4uLmVycm9ycy5maWx0ZXIoKGUpPT57XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGR1cGxpY2F0ZSBlcnJvcnNcbiAgICAgICAgICAgIHJldHVybiBlLmV2ZW50LnJlYXNvbiAhPT0gZXJyLmV2ZW50LnJlYXNvbjtcbiAgICAgICAgfSksXG4gICAgICAgIGVyclxuICAgIF07XG59XG5jb25zdCBJTklUSUFMX09WRVJMQVlfU1RBVEUgPSB7XG4gICAgbmV4dElkOiAxLFxuICAgIGJ1aWxkRXJyb3I6IG51bGwsXG4gICAgZXJyb3JzOiBbXSxcbiAgICBub3RGb3VuZDogZmFsc2UsXG4gICAgcmVmcmVzaFN0YXRlOiB7XG4gICAgICAgIHR5cGU6IFwiaWRsZVwiXG4gICAgfSxcbiAgICByb290TGF5b3V0TWlzc2luZ1RhZ3M6IFtdLFxuICAgIHZlcnNpb25JbmZvOiB7XG4gICAgICAgIGluc3RhbGxlZDogXCIwLjAuMFwiLFxuICAgICAgICBzdGFsZW5lc3M6IFwidW5rbm93blwiXG4gICAgfVxufTtcbmZ1bmN0aW9uIHVzZUVycm9yT3ZlcmxheVJlZHVjZXIoKSB7XG4gICAgcmV0dXJuICgwLCBfcmVhY3QudXNlUmVkdWNlcikoKF9zdGF0ZSwgYWN0aW9uKT0+e1xuICAgICAgICBzd2l0Y2goYWN0aW9uLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSBBQ1RJT05fQlVJTERfT0s6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uX3N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRFcnJvcjogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQUNUSU9OX0JVSUxEX0VSUk9SOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLl9zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkRXJyb3I6IGFjdGlvbi5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBQ1RJT05fQkVGT1JFX1JFRlJFU0g6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uX3N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQUNUSU9OX1JFRlJFU0g6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uX3N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRFcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogLy8gRXJyb3JzIGNhbiBjb21lIGluIGR1cmluZyB1cGRhdGVzLiBJbiB0aGlzIGNhc2UsIFVOSEFORExFRF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIFVOSEFORExFRF9SRUpFQ1RJT04gZXZlbnRzIG1pZ2h0IGJlIGRpc3BhdGNoZWQgYmV0d2VlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJFRk9SRV9SRUZSRVNIIGFuZCB0aGUgUkVGUkVTSCBldmVudC4gV2Ugd2FudCB0byBrZWVwIHRob3NlIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJvdW5kIHVudGlsIHRoZSBuZXh0IHJlZnJlc2guIE90aGVyd2lzZSB3ZSBydW4gaW50byBhIHJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmRpdGlvbiB3aGVyZSB0aG9zZSBlcnJvcnMgd291bGQgYmUgY2xlYXJlZCBvbiByZWZyZXNoIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSB0aGV5IGNhbiBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUucmVmcmVzaFN0YXRlLnR5cGUgPT09IFwicGVuZGluZ1wiID8gX3N0YXRlLnJlZnJlc2hTdGF0ZS5lcnJvcnMgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaWRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBQ1RJT05fVU5IQU5ETEVEX0VSUk9SOlxuICAgICAgICAgICAgY2FzZSBBQ1RJT05fVU5IQU5ETEVEX1JFSkVDVElPTjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUucmVmcmVzaFN0YXRlLnR5cGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlkbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5fc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IF9zdGF0ZS5uZXh0SWQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKF9zdGF0ZS5lcnJvcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogX3N0YXRlLm5leHRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uX3N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBfc3RhdGUubmV4dElkICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLl9zdGF0ZS5yZWZyZXNoU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKF9zdGF0ZS5yZWZyZXNoU3RhdGUuZXJyb3JzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBfc3RhdGUubmV4dElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfID0gX3N0YXRlLnJlZnJlc2hTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBQ1RJT05fVkVSU0lPTl9JTkZPOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLl9zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb25JbmZvOiBhY3Rpb24udmVyc2lvbkluZm9cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBJTklUSUFMX09WRVJMQVlfU1RBVEUpO1xufVxuY29uc3QgUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SID0gXCJbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvclwiO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWQuanMubWFwIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsInJlcXVpcmUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiQUNUSU9OX0JFRk9SRV9SRUZSRVNIIiwiQUNUSU9OX0JVSUxEX0VSUk9SIiwiQUNUSU9OX0JVSUxEX09LIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fVU5IQU5ETEVEX0VSUk9SIiwiQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04iLCJBQ1RJT05fVkVSU0lPTl9JTkZPIiwiSU5JVElBTF9PVkVSTEFZX1NUQVRFIiwiUkVBQ1RfUkVGUkVTSF9GVUxMX1JFTE9BRF9GUk9NX0VSUk9SIiwidXNlRXJyb3JPdmVybGF5UmVkdWNlciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiX3JlYWN0IiwicHVzaEVycm9yRmlsdGVyRHVwbGljYXRlcyIsImVycm9ycyIsImVyciIsImNvbmNhdCIsImV2ZW50IiwicmVhc29uIiwibmV4dElkIiwiYnVpbGRFcnJvciIsIm5vdEZvdW5kIiwicmVmcmVzaFN0YXRlIiwidHlwZSIsInJvb3RMYXlvdXRNaXNzaW5nVGFncyIsInZlcnNpb25JbmZvIiwiaW5zdGFsbGVkIiwic3RhbGVuZXNzIiwidXNlUmVkdWNlciIsIl9zdGF0ZSIsImFjdGlvbiIsIm1lc3NhZ2UiLCJpZCIsIl8iLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/react-dev-overlay/shared.js\n"));

/***/ })

}]);