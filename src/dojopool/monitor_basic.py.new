import psutil
import time
import logging
import json
import os
import subprocess
import threading
from datetime import datetime
from typing import Dict, List, Optional
from collections import deque

class BasicMonitor:
    def __init__(self, auto_optimize: bool = False):
        # Setup basic logging
        logging.basicConfig(
            filename='performance.log',
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
        self.is_running = False
        self.monitor_thread = None
        self.metrics_history = {
            'cpu': deque(maxlen=60),  # Last 60 readings
            'memory': deque(maxlen=60),
            'disk': deque(maxlen=60)
        }
        self.thresholds = {
            'cpu_percent': 80,
            'memory_percent': 85,
            'disk_percent': 90,
            'process_count': 15,
            'network_bytes_sent': 1000000,  # 1MB/s
            'network_bytes_recv': 1000000   # 1MB/s
        }
        self.previous_network = None
        self.optimization_history = []
        
        # Auto-optimization settings
        self.auto_optimize = auto_optimize
        self.optimization_attempts = {}
        self.max_optimization_attempts = 3
        self.optimization_cooldown = 3600  # 1 hour between optimization attempts
        self.last_optimization = {}

    def start(self):
        """Start monitoring in a separate thread."""
        self.is_running = True
        self.logger.info("Monitoring started")
        self.monitor_thread = threading.Thread(target=self._monitor_loop)
        self.monitor_thread.daemon = True
        self.monitor_thread.start()

    def stop(self):
        """Stop monitoring."""
        self.is_running = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        self.logger.info("Monitoring stopped")

    def _monitor_loop(self):
        """Main monitoring loop."""
        while self.is_running:
            try:
                metrics = self._collect_metrics()
                self._update_history(metrics)
                analysis = self._analyze_metrics(metrics)
                self._check_thresholds(metrics)
                
                # Auto-optimize if enabled
                if self.auto_optimize:
                    self._apply_automatic_optimizations(analysis)
                    
                time.sleep(60)  # Check every minute
            except Exception as e:
                self.logger.error(f"Error in monitoring loop: {str(e)}")

    def _collect_metrics(self) -> Dict:
        """Collect comprehensive system metrics."""
        metrics = {
            'timestamp': datetime.now(),
            'cpu_percent': psutil.cpu_percent(interval=1),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_percent': psutil.disk_usage('/').percent,
            'processes': self._get_process_details()
        }
        
        # Add network metrics
        net_io = psutil.net_io_counters()
        metrics['network'] = {
            'bytes_sent': net_io.bytes_sent,
            'bytes_recv': net_io.bytes_recv,
            'packets_sent': net_io.packets_sent,
            'packets_recv': net_io.packets_recv
        }
        
        return metrics

    def _get_process_details(self) -> List[Dict]:
        """Get detailed information about running processes."""
        processes = []
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
            try:
                pinfo = proc.info
                if pinfo['cpu_percent'] > 0 or pinfo['memory_percent'] > 0:
                    processes.append(pinfo)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return sorted(processes, key=lambda x: x['cpu_percent'], reverse=True)

    def _update_history(self, metrics: Dict):
        """Update metrics history."""
        self.metrics_history['cpu'].append(metrics['cpu_percent'])
        self.metrics_history['memory'].append(metrics['memory_percent'])
        self.metrics_history['disk'].append(metrics['disk_percent'])

    def _analyze_metrics(self, metrics: Dict):
        """Analyze current metrics and detect trends."""
        analysis = {
            'cpu_trend': self._calculate_trend(self.metrics_history['cpu']),
            'memory_trend': self._calculate_trend(self.metrics_history['memory']),
            'disk_trend': self._calculate_trend(self.metrics_history['disk']),
            'top_processes': metrics['processes'][:5],
            'optimization_recommendations': self._generate_optimization_recommendations(metrics)
        }
        
        # Log analysis results
        self.logger.info(f"Performance Analysis: {json.dumps(analysis, default=str)}")
        return analysis

    def _calculate_trend(self, values: deque) -> str:
        """Calculate trend direction based on recent values."""
        if len(values) < 2:
            return "stable"
        
        recent = list(values)[-5:]  # Last 5 values
        if len(recent) < 2:
            return "stable"
        
        avg_change = sum(b - a for a, b in zip(recent[:-1], recent[1:])) / (len(recent) - 1)
        
        if avg_change > 1:
            return "increasing"
        elif avg_change < -1:
            return "decreasing"
        return "stable"

    def _check_thresholds(self, metrics: Dict):
        """Check metrics against thresholds and log warnings."""
        if metrics['cpu_percent'] > self.thresholds['cpu_percent']:
            self.logger.warning(
                f"High CPU usage: {metrics['cpu_percent']}% - "
                f"Top process: {metrics['processes'][0]['name']}"
            )
        
        if metrics['memory_percent'] > self.thresholds['memory_percent']:
            self.logger.warning(
                f"High memory usage: {metrics['memory_percent']}% - "
                f"Top memory process: {sorted(metrics['processes'], key=lambda x: x['memory_percent'], reverse=True)[0]['name']}"
            )
        
        if metrics['disk_percent'] > self.thresholds['disk_percent']:
            self.logger.warning(f"High disk usage: {metrics['disk_percent']}%")
        
        cursor_processes = [p for p in metrics['processes'] if 'cursor' in p['name'].lower()]
        if len(cursor_processes) > self.thresholds['process_count']:
            self.logger.warning(
                f"High number of Cursor processes: {len(cursor_processes)} - "
                "Consider closing unused instances"
            )

    def _generate_optimization_recommendations(self, metrics: Dict) -> List[Dict]:
        """Generate specific optimization recommendations based on metrics."""
        recommendations = []
        
        # CPU Optimizations
        if metrics['cpu_percent'] > self.thresholds['cpu_percent']:
            cpu_hogs = [p for p in metrics['processes'][:5] if p['cpu_percent'] > 20]
            for proc in cpu_hogs:
                recommendations.append({
                    'type': 'cpu',
                    'severity': 'high' if proc['cpu_percent'] > 50 else 'medium',
                    'process': proc['name'],
                    'metric': proc['cpu_percent'],
                    'action': f"Consider optimizing or restarting {proc['name']}",
                    'details': self._get_process_optimization_details(proc)
                })

        # Memory Optimizations
        if metrics['memory_percent'] > self.thresholds['memory_percent']:
            memory_hogs = [p for p in metrics['processes'] if p['memory_percent'] > 5]
            for proc in memory_hogs:
                recommendations.append({
                    'type': 'memory',
                    'severity': 'high' if proc['memory_percent'] > 10 else 'medium',
                    'process': proc['name'],
                    'metric': proc['memory_percent'],
                    'action': f"Consider closing or restarting {proc['name']}",
                    'details': self._get_memory_optimization_details(proc)
                })

        # Cursor-specific optimizations
        cursor_processes = [p for p in metrics['processes'] if 'cursor' in p['name'].lower()]
        if len(cursor_processes) > self.thresholds['process_count']:
            recommendations.append({
                'type': 'cursor',
                'severity': 'medium',
                'process': 'Cursor',
                'metric': len(cursor_processes),
                'action': 'Optimize Cursor instances',
                'details': self._get_cursor_optimization_details(cursor_processes)
            })

        # Network optimizations
        if self.previous_network:
            time_diff = (metrics['timestamp'] - self.previous_network['timestamp']).total_seconds()
            bytes_sent_per_sec = (metrics['network']['bytes_sent'] - self.previous_network['bytes_sent']) / time_diff
            bytes_recv_per_sec = (metrics['network']['bytes_recv'] - self.previous_network['bytes_recv']) / time_diff
            
            if bytes_sent_per_sec > self.thresholds['network_bytes_sent'] or \
               bytes_recv_per_sec > self.thresholds['network_bytes_recv']:
                recommendations.append({
                    'type': 'network',
                    'severity': 'medium',
                    'metric': max(bytes_sent_per_sec, bytes_recv_per_sec),
                    'action': 'Optimize network usage',
                    'details': self._get_network_optimization_details(bytes_sent_per_sec, bytes_recv_per_sec)
                })

        self.previous_network = {
            'timestamp': metrics['timestamp'],
            'bytes_sent': metrics['network']['bytes_sent'],
            'bytes_recv': metrics['network']['bytes_recv']
        }

        # Store optimization history
        if recommendations:
            self.optimization_history.append({
                'timestamp': metrics['timestamp'],
                'recommendations': recommendations
            })

        return recommendations

    def _apply_automatic_optimizations(self, analysis: Dict):
        """Apply automatic optimizations based on analysis."""
        current_time = datetime.now()
        
        for rec in analysis.get('optimization_recommendations', []):
            opt_key = f"{rec['type']}_{rec.get('process', '')}"
            
            # Check if we've tried too many times
            if self.optimization_attempts.get(opt_key, 0) >= self.max_optimization_attempts:
                continue
                
            # Check if we're still in cooldown period
            last_attempt = self.last_optimization.get(opt_key)
            if last_attempt and (current_time - last_attempt).total_seconds() < self.optimization_cooldown:
                continue
            
            # Apply optimization based on type
            success = False
            if rec['type'] == 'cursor':
                success = self._optimize_cursor_automatically(rec)
            elif rec['type'] == 'memory':
                success = self._optimize_memory_automatically(rec)
            elif rec['type'] == 'cpu':
                success = self._optimize_cpu_automatically(rec)
            
            # Update optimization tracking
            if success:
                self.logger.info(f"Successfully applied automatic optimization: {rec['action']}")
                self.last_optimization[opt_key] = current_time
            else:
                self.optimization_attempts[opt_key] = self.optimization_attempts.get(opt_key, 0) + 1

    def _optimize_cursor_automatically(self, recommendation: Dict) -> bool:
        """Apply automatic optimizations for Cursor."""
        try:
            # Optimize Cursor config
            config_path = os.path.expanduser("~/AppData/Roaming/Cursor/config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    config = json.load(f)
                
                # Create backup
                backup_path = f"{config_path}.bak"
                with open(backup_path, 'w') as f:
                    json.dump(config, f)
                
                # Apply optimizations
                optimizations = {
                    "editor.maxTokenizationLineLength": 20000,
                    "editor.suggest.snippetsPreventQuickSuggestions": True,
                    "editor.hover.delay": 1000,
                    "workbench.enablePreview": False,
                    "files.watcherExclude": {
                        "**/.git/objects/**": True,
                        "**/node_modules/**": True,
                        "**/dist/**": True,
                        "**/build/**": True
                    }
                }
                config.update(optimizations)
                
                with open(config_path, 'w') as f:
                    json.dump(config, f)
                
                # Close excess Cursor instances
                cursor_processes = [p for p in psutil.process_iter(['pid', 'name']) 
                                 if 'cursor' in p.info['name'].lower()]
                if len(cursor_processes) > self.thresholds['process_count']:
                    for proc in cursor_processes[self.thresholds['process_count']:]:
                        try:
                            proc.terminate()
                            time.sleep(1)
                        except psutil.NoSuchProcess:
                            pass
                
                return True
            return False
        except Exception as e:
            self.logger.error(f"Error optimizing Cursor: {str(e)}")
            return False

    def _optimize_memory_automatically(self, recommendation: Dict) -> bool:
        """Apply automatic optimizations for memory usage."""
        try:
            process_name = recommendation.get('process')
            if not process_name:
                return False
            
            # Find all instances of the process
            target_processes = [p for p in psutil.process_iter(['pid', 'name', 'memory_percent']) 
                              if p.info['name'] == process_name]
            
            for proc in target_processes:
                if proc.info['memory_percent'] > 10:  # High memory usage
                    # Try to reduce memory usage
                    if 'chrome' in process_name.lower() or 'cursor' in process_name.lower():
                        # Clear browser cache
                        cache_dir = os.path.expanduser("~/AppData/Local/Cursor/User Data/Default/Cache")
                        if os.path.exists(cache_dir):
                            try:
                                subprocess.run(['rd', '/s', '/q', cache_dir], shell=True)
                            except subprocess.SubprocessError:
                                pass
                    
                    # Attempt to reduce memory usage through system calls
                    try:
                        proc.suspend()
                        time.sleep(0.1)
                        proc.resume()
                    except psutil.NoSuchProcess:
                        pass
            
            return True
        except Exception as e:
            self.logger.error(f"Error optimizing memory: {str(e)}")
            return False

    def _optimize_cpu_automatically(self, recommendation: Dict) -> bool:
        """Apply automatic optimizations for CPU usage."""
        try:
            process_name = recommendation.get('process')
            if not process_name:
                return False
            
            # Find all instances of the process
            target_processes = [p for p in psutil.process_iter(['pid', 'name', 'cpu_percent']) 
                              if p.info['name'] == process_name]
            
            for proc in target_processes:
                if proc.info['cpu_percent'] > 50:  # High CPU usage
                    try:
                        # Reduce process priority
                        proc.nice(psutil.BELOW_NORMAL_PRIORITY_CLASS)
                        
                        # If it's still using too much CPU after 5 seconds
                        time.sleep(5)
                        proc.cpu_percent()  # First call to cpu_percent() will return 0.0
                        if proc.cpu_percent() > 50:
                            # Try suspending briefly
                            proc.suspend()
                            time.sleep(0.5)
                            proc.resume()
                    except psutil.NoSuchProcess:
                        pass
            
            return True
        except Exception as e:
            self.logger.error(f"Error optimizing CPU usage: {str(e)}")
            return False

    def _get_process_optimization_details(self, process: Dict) -> List[str]:
        """Get detailed optimization suggestions for a process."""
        details = []
        if process['cpu_percent'] > 50:
            details.extend([
                f"Process {process['name']} is using {process['cpu_percent']}% CPU",
                "Consider the following actions:",
                "- Check for process hanging or infinite loops",
                "- Update to the latest version",
                "- Adjust process priority",
                "- Check for available updates"
            ])
        return details

    def _get_memory_optimization_details(self, process: Dict) -> List[str]:
        """Get detailed memory optimization suggestions."""
        details = []
        if process['memory_percent'] > 5:
            details.extend([
                f"Process {process['name']} is using {process['memory_percent']}% memory",
                "Recommended actions:",
                "- Close unused windows/tabs",
                "- Clear application cache",
                "- Check for memory leaks",
                "- Consider increasing system RAM if issues persist"
            ])
        return details

    def _get_cursor_optimization_details(self, cursor_processes: List[Dict]) -> List[str]:
        """Get Cursor-specific optimization suggestions."""
        total_cpu = sum(p['cpu_percent'] for p in cursor_processes)
        total_memory = sum(p['memory_percent'] for p in cursor_processes)
        
        details = [
            f"Found {len(cursor_processes)} Cursor instances using {total_cpu:.1f}% CPU and {total_memory:.1f}% memory",
            "Optimization suggestions:",
            "- Close unused Cursor windows",
            "- Update Cursor to the latest version",
            "- Clear Cursor cache and temporary files",
            "- Disable unused extensions",
            "- Optimize Cursor configuration settings"
        ]
        
        config_path = os.path.expanduser("~/AppData/Roaming/Cursor/config.json")
        if os.path.exists(config_path):
            details.append("- Review and optimize Cursor config at: " + config_path)
        
        return details

    def _get_network_optimization_details(self, bytes_sent_per_sec: float, bytes_recv_per_sec: float) -> List[str]:
        """Get network optimization suggestions."""
        details = [
            f"Network usage: ↑{bytes_sent_per_sec/1024/1024:.2f}MB/s ↓{bytes_recv_per_sec/1024/1024:.2f}MB/s",
            "Optimization suggestions:",
            "- Check for background downloads/uploads",
            "- Review active network connections",
            "- Consider using offline mode for development",
            "- Optimize IDE indexing settings",
            "- Review version control settings"
        ]
        return details

    def get_optimization_summary(self) -> Dict:
        """Get a summary of recent optimization recommendations."""
        if not self.optimization_history:
            return {"message": "No optimization history available"}
        
        recent_recommendations = self.optimization_history[-10:]  # Last 10 recommendations
        summary = {
            "total_recommendations": len(recent_recommendations),
            "by_type": {},
            "by_severity": {},
            "most_common_processes": {},
            "recent_recommendations": recent_recommendations
        }
        
        for entry in recent_recommendations:
            for rec in entry['recommendations']:
                # Count by type
                summary["by_type"][rec['type']] = summary["by_type"].get(rec['type'], 0) + 1
                # Count by severity
                if 'severity' in rec:
                    summary["by_severity"][rec['severity']] = summary["by_severity"].get(rec['severity'], 0) + 1
                # Count by process
                if 'process' in rec:
                    summary["most_common_processes"][rec['process']] = summary["most_common_processes"].get(rec['process'], 0) + 1
        
        return summary

