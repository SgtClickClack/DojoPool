"""
Automated vulnerability scanning system for DojoPool.

This module provides comprehensive vulnerability scanning capabilities including:
- Dependency scanning
- Code analysis
- Configuration assessment
- Network security checks
"""

import logging
import subprocess
from datetime import datetime
from typing import Dict, List, Optional, Tuple

import requests
import pkg_resources  # For dependency scanning
from bandit.core import manager as bandit_manager

from dojopool.config import SecurityConfig
from dojopool.utils.security import log_security_event

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    def __init__(self):
        self.scan_results: Dict = {}
        self.last_scan_time: Optional[datetime] = None

    def scan_dependencies(self) -> List[Dict]:
        """
        Scan Python dependencies for known vulnerabilities.
        """
        try:
            # Get installed packages
            installed_packages = [
                f"{dist.key}=={dist.version}" for dist in pkg_resources.working_set
            ]

            vulns = []
            for pkg in installed_packages:
                # Here we would integrate with safety-db or similar
                # For now, we'll do basic version checking
                if "==" in pkg and pkg.split("==")[1].startswith("0."):
                    vulns.append(
                        {
                            "package": pkg.split("==")[0],
                            "installed_version": pkg.split("==")[1],
                            "vulnerability": "Using potentially unstable version",
                        }
                    )

            if vulns:
                for vuln in vulns:
                    log_security_event(
                        "dependency_vulnerability_found",
                        "system",
                        {"package": vuln["package"], "vulnerability": vuln["vulnerability"]},
                    )

            return vulns
        except Exception as e:
            logger.error(f"Dependency scan failed: {str(e)}")
            return []

    def scan_code(self) -> List[Dict]:
        """
        Perform static code analysis using bandit.
        """
        try:
            # Configure bandit for scanning
            b_mgr = bandit_manager.BanditManager()
            b_mgr.discover_files([SecurityConfig.PROJECT_ROOT])
            b_mgr.run_tests()

            # Get results
            results = b_mgr.get_issue_list()

            for result in results:
                log_security_event(
                    "code_vulnerability_found",
                    "system",
                    {"file": result.fname, "line": result.lineno, "issue": result.test_id},
                )

            return results
        except Exception as e:
            logger.error(f"Code scan failed: {str(e)}")
            return []

    def check_configuration(self) -> List[Dict]:
        """
        Scan configuration files for security issues.
        """
        issues = []
        try:
            # Check common security misconfigurations
            config_checks = [
                self._check_debug_mode(),
                self._check_secret_key(),
                self._check_secure_headers(),
                self._check_csrf_protection(),
            ]

            issues.extend([issue for issue in config_checks if issue])

            for issue in issues:
                log_security_event("configuration_issue_found", "system", {"issue": issue})

        except Exception as e:
            logger.error(f"Configuration check failed: {str(e)}")

        return issues

    def _check_debug_mode(self) -> Optional[Dict]:
        """Check if debug mode is enabled in production."""
        if SecurityConfig.DEBUG and not SecurityConfig.DEVELOPMENT:
            return {
                "type": "configuration",
                "severity": "high",
                "message": "Debug mode enabled in production",
            }
        return None

    def _check_secret_key(self) -> Optional[Dict]:
        """Verify secret key configuration."""
        if not SecurityConfig.SECRET_KEY or SecurityConfig.SECRET_KEY == "default":
            return {
                "type": "configuration",
                "severity": "critical",
                "message": "Insecure secret key configuration",
            }
        return None

    def _check_secure_headers(self) -> Optional[Dict]:
        """Verify secure headers configuration."""
        required_headers = {
            "X-Frame-Options",
            "X-XSS-Protection",
            "X-Content-Type-Options",
            "Strict-Transport-Security",
        }

        missing_headers = required_headers - set(SecurityConfig.SECURE_HEADERS or {})

        if missing_headers:
            return {
                "type": "configuration",
                "severity": "medium",
                "message": f"Missing secure headers: {', '.join(missing_headers)}",
            }
        return None

    def _check_csrf_protection(self) -> Optional[Dict]:
        """Verify CSRF protection configuration."""
        if not SecurityConfig.WTF_CSRF_ENABLED:
            return {
                "type": "configuration",
                "severity": "high",
                "message": "CSRF protection disabled",
            }
        return None

    def run_full_scan(self) -> Dict:
        """
        Run a complete vulnerability scan.
        """
        self.last_scan_time = datetime.utcnow()

        self.scan_results = {
            "timestamp": self.last_scan_time.isoformat(),
            "dependency_vulnerabilities": self.scan_dependencies(),
            "code_vulnerabilities": self.scan_code(),
            "configuration_issues": self.check_configuration(),
        }

        # Log overall scan results
        log_security_event(
            "vulnerability_scan_completed",
            "system",
            {
                "timestamp": self.last_scan_time.isoformat(),
                "total_issues": sum(
                    len(v) for v in self.scan_results.values() if isinstance(v, list)
                ),
            },
        )

        return self.scan_results

    def get_last_scan_results(self) -> Optional[Dict]:
        """
        Get results from the last scan.
        """
        return self.scan_results if self.last_scan_time else None
