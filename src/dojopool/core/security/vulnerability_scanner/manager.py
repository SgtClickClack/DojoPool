"""
Vulnerability scanner manager.
Coordinates and schedules vulnerability scans.
"""

import asyncio
import json
import logging
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Type

from . import config
from .base import BaseScanner, VulnerabilityFinding
from .dependency_scanner import DependencyScanner


class ScannerManager:
    """Manages vulnerability scanning operations."""

    def __init__(self):
        """Initialize scanner manager."""
        self.logger = logging.getLogger("vulnerability_scanner.manager")
        self.scanners: Dict[str, Type[BaseScanner]] = {
            "dependency": DependencyScanner,
            # Add other scanners as they are implemented
        }

        # Track last scan times
        self.last_scan_times: Dict[str, datetime] = {}

        # Track active scans
        self.active_scans: Dict[str, asyncio.Task] = {}

        # Initialize executor for running scans
        self.executor = ThreadPoolExecutor(
            max_workers=config.SCANNER_CONFIG["parallel_scans"]
        )

    async def start_scheduled_scans(self) -> None:
        """Start scheduled vulnerability scanning."""
        self.logger.info("Starting scheduled vulnerability scanning")

        while True:
            try:
                # Check and start scans for each enabled scanner
                for scanner_type, enabled in config.ENABLED_SCANNERS.items():
                    if enabled and scanner_type in self.scanners:
                        await self._check_and_start_scan(scanner_type)

                # Wait before next check
                await asyncio.sleep(60)  # Check every minute

            except Exception as e:
                self.logger.error(f"Error in scan scheduler: {str(e)}")
                await asyncio.sleep(60)  # Wait before retry

    async def _check_and_start_scan(self, scanner_type: str):
        """Check if scan is needed and start if necessary."""
        try:
            # Skip if scan is already running
            if scanner_type in self.active_scans:
                return

            # Check if scan is due
            last_scan = self.last_scan_times.get(scanner_type)
            scan_frequency = timedelta(hours=config.SCANNER_CONFIG["scan_frequency"])

            if not last_scan or datetime.now() - last_scan > scan_frequency:
                # Start scan
                self.logger.info(f"Starting {scanner_type} scan")
                scan_task = asyncio.create_task(self._run_scan(scanner_type))
                self.active_scans[scanner_type] = scan_task

                # Wait for scan completion
                await scan_task

        except Exception as e:
            self.logger.error(f"Error checking/starting {scanner_type} scan: {str(e)}")

    async def _run_scan(self, scanner_type: str) -> None:
        """Run a vulnerability scan."""
        try:
            # Create scanner instance
            scanner_class = self.scanners[scanner_type]
            scanner = scanner_class()

            # Run scan in thread pool
            findings = await asyncio.get_event_loop().run_in_executor(
                self.executor, scanner.execute_scan
            )

            # Process findings
            await self._process_scan_results(scanner_type, findings)

            # Update last scan time
            self.last_scan_times[scanner_type] = datetime.now()

        except Exception as e:
            self.logger.error(f"Error running {scanner_type} scan: {str(e)}")

        finally:
            # Remove from active scans
            if scanner_type in self.active_scans:
                del self.active_scans[scanner_type]

    async def _process_scan_results(
        self, scanner_type: str, findings: List[VulnerabilityFinding]
    ):
        """Process and store scan results."""
        try:
            # Count findings by severity
            severity_counts = {}
            for finding in findings:
                severity_counts[finding.severity] = (
                    severity_counts.get(finding.severity, 0) + 1
                )

            self.logger.info(
                f"Scan completed - {scanner_type}: "
                f"Found {len(findings)} vulnerabilities"
            )

            # Store summary
            summary = {
                "scanner_type": scanner_type,
                "scan_time": datetime.now().isoformat(),
                "total_findings": len(findings),
                "severity_counts": severity_counts,
            }

            summary_file = (
                config.SCAN_RESULTS_DIR / scanner_type / "latest_summary.json"
            )
            with open(summary_file, "w") as f:
                json.dump(summary, f, indent=2)

            # Create tickets for high-severity findings
            if config.REMEDIATION_CONFIG["auto_create_tickets"]:
                await self._create_tickets(findings)

        except Exception as e:
            self.logger.error(f"Error processing {scanner_type} scan results: {str(e)}")

    async def _create_tickets(self, findings: List[VulnerabilityFinding]) -> None:
        """Create tickets for vulnerability findings."""
        try:
            from ...utils.ticket_system import create_ticket

            for finding in findings:
                # Check severity threshold
                if (
                    config.VULNERABILITY_SEVERITY[finding.severity]
                    >= config.VULNERABILITY_SEVERITY["high"]
                ):

                    # Create ticket
                    ticket_data = {
                        "title": f"Security: {finding.title}",
                        "description": (
                            f"Severity: {finding.severity}\n"
                            f"Component: {finding.affected_component}\n\n"
                            f"Description:\n{finding.description}\n\n"
                            f"Evidence:\n{finding.evidence}\n\n"
                            f"Remediation:\n{finding.remediation}"
                        ),
                        "priority": config.REMEDIATION_CONFIG["priority_mapping"][
                            finding.severity
                        ],
                        "due_date": datetime.now()
                        + timedelta(
                            days=config.REMEDIATION_CONFIG["sla_days"][finding.severity]
                        ),
                    }

                    await create_ticket(ticket_data)

        except Exception as e:
            self.logger.error(f"Error creating tickets: {str(e)}")

    def get_scan_status(self, scanner_type: Optional[str] = None) -> Dict:
        """Get status of vulnerability scans."""
        status = {}

        try:
            # Get status for specific scanner
            if scanner_type:
                if scanner_type not in self.scanners:
                    raise ValueError(f"Unknown scanner type: {scanner_type}")

                last_scan_time = self.last_scan_times.get(scanner_type)
                status[scanner_type] = {
                    "active": scanner_type in self.active_scans,
                    "last_scan": last_scan_time.isoformat() if last_scan_time else None,
                    "enabled": config.ENABLED_SCANNERS.get(scanner_type, False),
                }

                # Get latest summary if available
                summary_file = (
                    config.SCAN_RESULTS_DIR / scanner_type / "latest_summary.json"
                )
                if summary_file.exists():
                    with open(summary_file) as f:
                        status[scanner_type]["latest_summary"] = json.load(f)

            # Get status for all scanners
            else:
                for scanner_type in self.scanners:
                    last_scan_time = self.last_scan_times.get(scanner_type)
                    status[scanner_type] = {
                        "active": scanner_type in self.active_scans,
                        "last_scan": (
                            last_scan_time.isoformat() if last_scan_time else None
                        ),
                        "enabled": config.ENABLED_SCANNERS.get(scanner_type, False),
                    }

            return status

        except Exception as e:
            self.logger.error(f"Error getting scan status: {str(e)}")
            return {"error": str(e)}


# Global scanner manager instance
scanner_manager = ScannerManager()
