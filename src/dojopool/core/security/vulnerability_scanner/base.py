"""
Base scanner class for the vulnerability scanning system.
"""

import json
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

from . import config


@dataclass
class VulnerabilityFinding:
    """Represents a vulnerability finding."""

    timestamp: datetime
    severity: str
    title: str
    description: str
    vulnerability_type: str
    affected_component: str
    evidence: str
    remediation: str
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    references: Optional[List[str]] = None
    tags: Optional[List[str]] = None
    metadata: Optional[Dict[str, Any]] = None


class BaseScanner(ABC):
    """Base class for vulnerability scanners."""

    def __init__(self, scanner_type: str):
        """Initialize scanner."""
        self.scanner_type = scanner_type
        self.logger = logging.getLogger(f"vulnerability_scanner.{scanner_type}")
        self.results_dir = config.SCAN_RESULTS_DIR / scanner_type
        self.results_dir.mkdir(parents=True, exist_ok=True)

        # Load scanner-specific configuration
        self.config = self._load_config()

        # Initialize scan metadata
        self.scan_id = None
        self.scan_start_time = None
        self.findings: List[VulnerabilityFinding] = []

    def _load_config(self) -> Dict[str, Any]:
        """Load scanner-specific configuration."""
        scanner_config = getattr(config, f"{self.scanner_type.upper()}_SCAN_CONFIG", {})
        return {**config.SCANNER_CONFIG, **scanner_config}

    @abstractmethod
    def prepare_scan(self) -> None:
        """Prepare for scanning. Override in subclass."""
        pass

    @abstractmethod
    def run_scan(self) -> List[VulnerabilityFinding]:
        """Run the vulnerability scan. Override in subclass."""
        pass

    @abstractmethod
    def cleanup_scan(self) -> None:
        """Clean up after scanning. Override in subclass."""
        pass

    def execute_scan(self) -> List[VulnerabilityFinding]:
        """Execute the complete scan process."""
        try:
            self.scan_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.scan_start_time = datetime.now()
            self.logger.info(f"Starting {self.scanner_type} scan (ID: {self.scan_id})")

            # Prepare scan
            self.prepare_scan()

            # Run scan
            self.findings = self.run_scan()

            # Process and save results
            self._process_findings()
            self._save_results()

            # Send notifications if needed
            self._send_notifications()

            return self.findings

        except Exception as e:
            self.logger.error(f"Error during {self.scanner_type} scan: {str(e)}")
            raise

        finally:
            # Always attempt cleanup
            try:
                self.cleanup_scan()
            except Exception as e:
                self.logger.error(f"Error during scan cleanup: {str(e)}")

    def _process_findings(self) -> None:
        """Process and enrich vulnerability findings."""
        for finding in self.findings:
            # Add compliance mappings
            self._add_compliance_mappings(finding)

            # Calculate risk score if not present
            if not finding.cvss_score:
                finding.cvss_score = self._calculate_risk_score(finding)

            # Add remediation details if not present
            if not finding.remediation:
                finding.remediation = self._get_remediation_guidance(finding)

    def _save_results(self) -> None:
        """Save scan results to file."""
        results = {
            "scan_id": self.scan_id,
            "scanner_type": self.scanner_type,
            "start_time": self.scan_start_time.isoformat(),
            "end_time": datetime.now().isoformat(),
            "findings": [self._finding_to_dict(f) for f in self.findings],
        }

        # Save JSON results
        json_path = self.results_dir / f"scan_{self.scan_id}.json"
        with open(json_path, "w") as f:
            json.dump(results, f, indent=2)

        self.logger.info(f"Saved scan results to {json_path}")

    def _finding_to_dict(self, finding: VulnerabilityFinding) -> Dict[str, Any]:
        """Convert finding to dictionary."""
        return {
            "timestamp": finding.timestamp.isoformat(),
            "severity": finding.severity,
            "title": finding.title,
            "description": finding.description,
            "vulnerability_type": finding.vulnerability_type,
            "affected_component": finding.affected_component,
            "evidence": finding.evidence,
            "remediation": finding.remediation,
            "cwe_id": finding.cwe_id,
            "cvss_score": finding.cvss_score,
            "references": finding.references,
            "tags": finding.tags,
            "metadata": finding.metadata,
        }

    def _add_compliance_mappings(self, finding: VulnerabilityFinding) -> None:
        """Add compliance standard mappings to finding."""
        if finding.cwe_id:
            # Load compliance mappings
            mapping_file = config.COMPLIANCE_CONFIG["compliance_mapping"]
            if mapping_file.exists():
                with open(mapping_file) as f:
                    mappings = json.load(f)

                # Add mapped standards
                if finding.metadata is None:
                    finding.metadata = {}
                finding.metadata["compliance"] = mappings.get(finding.cwe_id, {})

    def _calculate_risk_score(self, finding: VulnerabilityFinding) -> float:
        """Calculate risk score for finding."""
        # Base score from severity
        base_score = config.VULNERABILITY_SEVERITY.get(finding.severity.lower(), 1)

        # Adjust based on affected component criticality
        # This is a simple example - implement your own scoring logic
        return min(10.0, base_score * 2)

    def _get_remediation_guidance(self, finding: VulnerabilityFinding) -> str:
        """Get remediation guidance for finding type."""
        # Load custom remediation guidance
        guidance_file = config.SCAN_CONFIGS_DIR / "remediation_guidance.json"
        if guidance_file.exists():
            with open(guidance_file) as f:
                guidance = json.load(f)
                return guidance.get(finding.vulnerability_type, "No specific guidance available.")
        return "No remediation guidance available."

    def _send_notifications(self) -> None:
        """Send notifications about scan findings."""
        from ..utils.notifications import send_notification

        # Count findings by severity
        severity_counts = {}
        for finding in self.findings:
            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1

        if self.findings:
            # Prepare notification message
            message = (
                f"Vulnerability Scan Results (ID: {self.scan_id})\n"
                f"Scanner: {self.scanner_type}\n"
                f"Total Findings: {len(self.findings)}\n\n"
                "Findings by Severity:\n"
            )

            for severity, count in severity_counts.items():
                message += f"- {severity}: {count}\n"

            # Send notifications based on configuration
            if config.NOTIFICATION_CONFIG["email"]["enabled"]:
                send_notification(
                    subject=f"Vulnerability Scan Results - {self.scanner_type}",
                    message=message,
                    email=config.NOTIFICATION_CONFIG["email"]["recipients"],
                )

            if config.NOTIFICATION_CONFIG["slack"]["enabled"]:
                send_notification(
                    subject=f"Vulnerability Scan Results - {self.scanner_type}",
                    message=message,
                    slack_webhook=config.NOTIFICATION_CONFIG["slack"]["webhook_url"],
                )
