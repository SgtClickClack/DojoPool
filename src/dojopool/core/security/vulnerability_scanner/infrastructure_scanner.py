"""
Infrastructure vulnerability scanner implementation.
Scans infrastructure components for security vulnerabilities.
"""

import re
import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime
from typing import Any, Dict, List, Set

from . import config
from .base import BaseScanner, VulnerabilityFinding


class InfrastructureScanner(BaseScanner):
    """Scanner for infrastructure vulnerabilities."""

    def __init__(self):
        """Initialize infrastructure scanner."""
        super().__init__("infrastructure")
        self.temp_dir = config.SCAN_RESULTS_DIR / "infrastructure" / "temp"
        self.temp_dir.mkdir(parents=True, exist_ok=True)

        # Track scan progress
        self.scanned_hosts: Set[str] = set()
        self.open_ports: Dict[str, List[int]] = {}
        self.detected_services: Dict[str, Dict[int, str]] = {}

    def prepare_scan(self) -> None:
        """Prepare for infrastructure scanning."""
        self.logger.info("Preparing infrastructure scan")

        # Create scan directory
        scan_dir = self.temp_dir / self.scan_id
        scan_dir.mkdir(parents=True, exist_ok=True)

        # Verify nmap installation
        try:
            subprocess.run(["nmap", "--version"], capture_output=True, check=True)
        except subprocess.CalledProcessError:
            raise RuntimeError("nmap is not installed or not accessible")

    def run_scan(self) -> List[VulnerabilityFinding]:
        """Run infrastructure vulnerability scan."""
        findings = []

        try:
            # Get targets
            hosts = config.SCAN_TARGETS["infrastructure"]["hosts"]
            ports = config.SCAN_TARGETS["infrastructure"]["ports"]

            # Run port scan
            port_findings = self._run_port_scan(hosts, ports)
            findings.extend(port_findings)

            # Run service detection
            if self.config["service_detection"]:
                service_findings = self._run_service_detection()
                findings.extend(service_findings)

            # Run OS detection
            if self.config["os_detection"]:
                os_findings = self._run_os_detection()
                findings.extend(os_findings)

            # Run vulnerability scripts
            if self.config["script_scan"]:
                script_findings = self._run_vulnerability_scripts()
                findings.extend(script_findings)

            return findings

        except Exception as e:
            self.logger.error(f"Error during infrastructure scan: {str(e)}")
            raise

    def cleanup_scan(self) -> None:
        """Clean up after infrastructure scanning."""
        # Remove temporary files
        scan_dir = self.temp_dir / self.scan_id
        if scan_dir.exists():
            for file in scan_dir.glob("*"):
                file.unlink()
            scan_dir.rmdir()

    def _run_port_scan(self, hosts: List[str], ports: str) -> List[VulnerabilityFinding]:
        """Run port scan on target hosts."""
        findings = []

        try:
            # Run nmap scan
            output_file = self.temp_dir / self.scan_id / "port_scan.xml"

            scan_type = "-sS" if self.config["port_scan_type"] == "syn" else "-sT"

            command = ["nmap", scan_type, "-p", ports, "-oX", str(output_file), *hosts]

            if not self.config["aggressive_scan"]:
                command.insert(1, "-T3")

            subprocess.run(command, check=True)

            # Parse results
            tree = ET.parse(output_file)
            root = tree.getroot()

            for host in root.findall(".//host"):
                address = host.find(".//address").get("addr")
                self.scanned_hosts.add(address)
                self.open_ports[address] = []

                for port in host.findall(".//port"):
                    if port.find("state").get("state") == "open":
                        port_num = int(port.get("portid"))
                        self.open_ports[address].append(port_num)

                        # Create finding for each open port
                        findings.append(
                            VulnerabilityFinding(
                                timestamp=datetime.now(),
                                severity="medium",
                                title=f"Open Port {port_num}",
                                description=f"Port {port_num} is open on {address}",
                                vulnerability_type="open_port",
                                affected_component=f"{address}:{port_num}",
                                evidence="Port scan detected open port",
                                remediation="Review if this port needs to be exposed and implement proper access controls",
                                cwe_id="CWE-200",
                            )
                        )

        except Exception as e:
            self.logger.error(f"Error during port scan: {str(e)}")

        return findings

    def _run_service_detection(self) -> List[VulnerabilityFinding]:
        """Run service detection on open ports."""
        findings = []

        try:
            for host, ports in self.open_ports.items():
                if not ports:
                    continue

                # Run service detection
                output_file = self.temp_dir / self.scan_id / f"service_scan_{host}.xml"

                command = [
                    "nmap",
                    "-sV",
                    "-p",
                    ",".join(map(str, ports)),
                    "-oX",
                    str(output_file),
                    host,
                ]

                subprocess.run(command, check=True)

                # Parse results
                tree = ET.parse(output_file)
                root = tree.getroot()

                self.detected_services[host] = {}

                for port in root.findall(".//port"):
                    port_num = int(port.get("portid"))
                    service = port.find("service")

                    if service is not None:
                        service_name = service.get("name", "unknown")
                        product = service.get("product", "")
                        version = service.get("version", "")

                        self.detected_services[host][port_num] = {
                            "name": service_name,
                            "product": product,
                            "version": version,
                        }

                        # Check for known vulnerable services
                        if self._is_vulnerable_service(service_name, product, version):
                            findings.append(
                                VulnerabilityFinding(
                                    timestamp=datetime.now(),
                                    severity="high",
                                    title=f"Vulnerable Service: {service_name}",
                                    description=f"Potentially vulnerable service detected: {product} {version}",
                                    vulnerability_type="vulnerable_service",
                                    affected_component=f"{host}:{port_num}",
                                    evidence=f"Service: {service_name}\nProduct: {product}\nVersion: {version}",
                                    remediation="Update to the latest version and apply security patches",
                                    cwe_id="CWE-1035",
                                )
                            )

        except Exception as e:
            self.logger.error(f"Error during service detection: {str(e)}")

        return findings

    def _run_os_detection(self) -> List[VulnerabilityFinding]:
        """Run OS detection on hosts."""
        findings = []

        try:
            for host in self.scanned_hosts:
                # Run OS detection
                output_file = self.temp_dir / self.scan_id / f"os_scan_{host}.xml"

                command = ["nmap", "-O", "-oX", str(output_file), host]

                subprocess.run(command, check=True)

                # Parse results
                tree = ET.parse(output_file)
                root = tree.getroot()

                for os_match in root.findall(".//osmatch"):
                    os_name = os_match.get("name", "unknown")
                    accuracy = float(os_match.get("accuracy", "0"))

                    if accuracy >= 80:  # Only consider high confidence matches
                        if self._is_vulnerable_os(os_name):
                            findings.append(
                                VulnerabilityFinding(
                                    timestamp=datetime.now(),
                                    severity="high",
                                    title="Vulnerable Operating System",
                                    description=f"Potentially vulnerable OS detected: {os_name}",
                                    vulnerability_type="vulnerable_os",
                                    affected_component=host,
                                    evidence=f"OS: {os_name}\nAccuracy: {accuracy}%",
                                    remediation="Update to a supported OS version and apply security patches",
                                    cwe_id="CWE-1035",
                                )
                            )

        except Exception as e:
            self.logger.error(f"Error during OS detection: {str(e)}")

        return findings

    def _run_vulnerability_scripts(self) -> List[VulnerabilityFinding]:
        """Run vulnerability detection scripts."""
        findings = []

        try:
            for host in self.scanned_hosts:
                # Run vulnerability scripts
                output_file = self.temp_dir / self.scan_id / f"vuln_scan_{host}.xml"

                command = ["nmap", "--script", "vuln", "-oX", str(output_file), host]

                subprocess.run(command, check=True)

                # Parse results
                tree = ET.parse(output_file)
                root = tree.getroot()

                for script in root.findall(".//script"):
                    if script.get("id", "").endswith("vuln"):
                        output = script.get("output", "")

                        # Parse vulnerability information
                        vuln_info = self._parse_vulnerability_output(output)

                        if vuln_info:
                            findings.append(
                                VulnerabilityFinding(
                                    timestamp=datetime.now(),
                                    severity=vuln_info.get("severity", "medium"),
                                    title=vuln_info.get("title", "Unknown Vulnerability"),
                                    description=vuln_info.get("description", ""),
                                    vulnerability_type="infrastructure_vulnerability",
                                    affected_component=host,
                                    evidence=output,
                                    remediation=vuln_info.get("remediation", ""),
                                    cwe_id=vuln_info.get("cwe_id"),
                                    cvss_score=vuln_info.get("cvss_score"),
                                )
                            )

        except Exception as e:
            self.logger.error(f"Error during vulnerability script scan: {str(e)}")

        return findings

    def _is_vulnerable_service(self, name: str, product: str, version: str) -> bool:
        """Check if service version is known to be vulnerable."""
        # This is a simple example - implement your own vulnerability checking logic
        vulnerable_services = {
            "http": {"apache": ["2.4.49", "2.4.50"], "nginx": ["1.18.0"]},
            "ssh": {"openssh": ["7.2p1"]},
        }

        return (
            name in vulnerable_services
            and product.lower() in vulnerable_services[name]
            and version in vulnerable_services[name][product.lower()]
        )

    def _is_vulnerable_os(self, os_name: str) -> bool:
        """Check if OS version is known to be vulnerable."""
        # This is a simple example - implement your own vulnerability checking logic
        vulnerable_os_patterns = [
            r"Windows (XP|Vista|7|2003|2008)",
            r"Debian [1-8]",
            r"Ubuntu 1[0-7]\.04",
            r"CentOS [1-6]",
        ]

        return any(re.search(pattern, os_name, re.I) for pattern in vulnerable_os_patterns)

    def _parse_vulnerability_output(self, output: str) -> Dict[str, Any]:
        """Parse vulnerability information from script output."""
        vuln_info = {}

        # Extract severity
        if "CRITICAL" in output.upper():
            vuln_info["severity"] = "critical"
        elif "HIGH" in output.upper():
            vuln_info["severity"] = "high"
        elif "MEDIUM" in output.upper():
            vuln_info["severity"] = "medium"
        else:
            vuln_info["severity"] = "low"

        # Extract title
        title_match = re.search(r"VULNERABLE:(.+?)(?:\n|$)", output)
        if title_match:
            vuln_info["title"] = title_match.group(1).strip()

        # Extract description
        desc_match = re.search(r"State:(.+?)(?:\n\n|\Z)", output, re.S)
        if desc_match:
            vuln_info["description"] = desc_match.group(1).strip()

        # Extract CVSS score
        cvss_match = re.search(r"CVSS:(\d+\.\d+)", output)
        if cvss_match:
            vuln_info["cvss_score"] = float(cvss_match.group(1))

        # Extract CWE ID
        cwe_match = re.search(r"CWE-(\d+)", output)
        if cwe_match:
            vuln_info["cwe_id"] = f"CWE-{cwe_match.group(1)}"

        # Extract remediation
        if "Solution:" in output:
            solution_match = re.search(r"Solution:(.+?)(?:\n\n|\Z)", output, re.S)
            if solution_match:
                vuln_info["remediation"] = solution_match.group(1).strip()

        return vuln_info
