from multiprocessing import Pool
import gc
from multiprocessing import Pool
import gc
"""
Dependency vulnerability scanner implementation.
Scans project dependencies for known vulnerabilities.
"""

import json
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List

from . import config
from .base import BaseScanner, VulnerabilityFinding


class DependencyScanner(BaseScanner):
    """Scanner for checking dependencies for known vulnerabilities."""

    def __init__(self):
        """Initialize dependency scanner."""
        super().__init__("dependency")
        self.temp_dir = config.SCAN_RESULTS_DIR / "dependency" / "temp"
        self.temp_dir.mkdir(parents=True, exist_ok=True)

        # Track processed dependencies
        self.processed_deps: Dict[str, Dict[str, Any]] = {}

    def prepare_scan(self) -> None:
        """Prepare for dependency scanning."""
        self.logger.info("Preparing dependency scan")

        # Update vulnerability databases
        self._update_vulnerability_db()

        # Create temporary working directory
        scan_dir = self.temp_dir / self.scan_id
        scan_dir.mkdir(parents=True, exist_ok=True)

    def run_scan(self):
        """Run dependency vulnerability scan."""
        findings = []

        # Scan each package manager's dependencies
        for pkg_manager in self.config["package_managers"]:
            self.logger.info(f"Scanning {pkg_manager} dependencies")

            try:
                deps_findings = self._scan_dependencies(pkg_manager)
                findings.extend(deps_findings)
            except Exception as e:
                self.logger.error(
                    f"Error scanning {pkg_manager} dependencies: {str(e)}"
                )

        return findings

    def cleanup_scan(self):
        """Clean up after dependency scanning."""
        # Remove temporary files
        scan_dir = self.temp_dir / self.scan_id
        if scan_dir.exists():
            for file in scan_dir.glob("*"):
                file.unlink()
            scan_dir.rmdir()

    def _update_vulnerability_db(self):
        """Update vulnerability databases."""
        self.logger.info("Updating vulnerability databases")

        try:
            # Update safety-db for Python
            subprocess.run(
                ["safety", "check", "--update"],
                capture_output=True,
                text=True,
                check=True,
            )

            # Update npm audit database
            if "npm" in self.config["package_managers"]:
                subprocess.run(
                    ["npm", "audit", "--update-db"],
                    capture_output=True,
                    text=True,
                    check=True,
                )

            # Update yarn audit database
            if "yarn" in self.config["package_managers"]:
                subprocess.run(
                    ["yarn", "audit", "--update-db"],
                    capture_output=True,
                    text=True,
                    check=True,
                )

        except subprocess.CalledProcessError as e:
            self.logger.error(f"Error updating vulnerability databases: {str(e)}")
            self.logger.error(f"Output: {e.output}")

    def _scan_dependencies(self, pkg_manager: str) -> List[VulnerabilityFinding]:
        """Scan dependencies for a specific package manager."""
        findings = []

        if pkg_manager == "pip":
            findings.extend(self._scan_python_deps())
        elif pkg_manager == "npm":
            findings.extend(self._scan_npm_deps())
        elif pkg_manager == "yarn":
            findings.extend(self._scan_yarn_deps())

        return findings

    def _scan_python_deps(self):
        """Scan Python dependencies using safety."""
        findings = []

        try:
            # Get requirements
            req_files = list(Path().glob("**/requirements*.txt"))

            for req_file in req_files:
                # Run safety check
                result = subprocess.run(
                    ["safety", "check", "-r", str(req_file), "--json"],
                    capture_output=True,
                    text=True,
                )

                if result.returncode != 0:
                    # Parse vulnerabilities
                    vulns = json.loads(result.stdout)

                    for vuln in vulns:
                        finding = VulnerabilityFinding(
                            timestamp=datetime.now(),
                            severity=self._map_safety_severity(
                                vuln.get("severity", "")
                            ),
                            title=f"Vulnerable dependency: {vuln.get('package')}",
                            description=vuln.get("description", ""),
                            vulnerability_type="dependency",
                            affected_component=f"{vuln.get('package')} {vuln.get('installed_version')}",
                            evidence=f"Installed version: {vuln.get('installed_version')}, "
                            f"Vulnerable versions: {vuln.get('vulnerable_versions')}",
                            remediation=f"Upgrade to version {vuln.get('fixed_versions', ['N/A'])[0]}",
                            cwe_id=vuln.get("cwe_id"),
                            references=vuln.get("references", []),
                        )
                        findings.append(finding)

        except Exception as e:
            self.logger.error(f"Error scanning Python dependencies: {str(e)}")

        return findings

    def _scan_npm_deps(self) -> List[VulnerabilityFinding]:
        """Scan npm dependencies."""
        findings = []

        try:
            # Run npm audit
            result = subprocess.run(
                ["npm", "audit", "--json"], capture_output=True, text=True
            )

            if result.returncode != 0:
                # Parse vulnerabilities
                audit_data = json.loads(result.stdout)

                for _vuln_id, vuln in audit_data.get("vulnerabilities", {}).items():
                    finding = VulnerabilityFinding(
                        timestamp=datetime.now(),
                        severity=vuln.get("severity", "").lower(),
                        title=f"Vulnerable dependency: {vuln.get('name')}",
                        description=vuln.get("overview", ""),
                        vulnerability_type="dependency",
                        affected_component=f"{vuln.get('name')} {vuln.get('version')}",
                        evidence=f"Installed version: {vuln.get('version')}, "
                        f"Vulnerable versions: {vuln.get('vulnerable_versions')}",
                        remediation=f"Upgrade to version {vuln.get('recommended_version', 'N/A')}",
                        cwe_id=vuln.get("cwe"),
                        references=vuln.get("references", []),
                    )
                    findings.append(finding)

        except Exception as e:
            self.logger.error(f"Error scanning npm dependencies: {str(e)}")

        return findings

    def _scan_yarn_deps(self) -> List[VulnerabilityFinding]:
        """Scan yarn dependencies."""
        findings = []

        try:
            # Run yarn audit
            result = subprocess.run(
                ["yarn", "audit", "--json"], capture_output=True, text=True
            )

            if result.returncode != 0:
                # Parse vulnerabilities
                for line in result.stdout.splitlines():
                    try:
                        audit_data = json.loads(line)
                        if audit_data.get("type") == "auditAdvisory":
                            advisory = audit_data.get("data", {}).get("advisory", {})

                            finding = VulnerabilityFinding(
                                timestamp=datetime.now(),
                                severity=advisory.get("severity", "").lower(),
                                title=f"Vulnerable dependency: {advisory.get('module_name')}",
                                description=advisory.get("overview", ""),
                                vulnerability_type="dependency",
                                affected_component=f"{advisory.get('module_name')} "
                                f"{advisory.get('vulnerable_versions')}",
                                evidence=f"Vulnerable versions: {advisory.get('vulnerable_versions')}",
                                remediation=f"Upgrade to version {advisory.get('patched_versions', 'N/A')}",
                                cwe_id=advisory.get("cwe"),
                                references=advisory.get("references", []),
                            )
                            findings.append(finding)
                    except json.JSONDecodeError:
                        continue

        except Exception as e:
            self.logger.error(f"Error scanning yarn dependencies: {str(e)}")

        return findings

    def _map_safety_severity(self, severity: str) -> str:
        """Map safety severity to standard severity levels."""
        severity_map = {
            "critical": "critical",
            "high": "high",
            "moderate": "medium",
            "low": "low",
            "": "info",
        }
        return severity_map.get(severity.lower(), "info")
