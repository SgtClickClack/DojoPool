import { pentestConfig } from './config';
import * as dns from 'dns/promises';
import { createHash } from 'crypto';
import { logger } from '../../src/utils/logger';

interface ReconnaissanceResult {
  domainInfo: {
    ipAddresses: string[];
    mxRecords: string[];
    txtRecords: string[];
    subdomains: string[];
  };
  technologyStack: {
    frontend: string[];
    backend: string[];
    database: string[];
    infrastructure: string[];
  };
  endpoints: {
    api: string[];
    websocket: string[];
    static: string[];
  };
  securityHeaders: Record<string, string>;
}

async function performDNSReconnaissance(
  domain: string
): Promise<ReconnaissanceResult['domainInfo']> {
  try {
    const ipAddresses = await dns.resolve4(domain).catch(() => []);
    const mxRecords = await dns.resolveMx(domain).catch(() => []);
    const txtRecords = await dns.resolveTxt(domain).catch(() => []);

    // Common subdomain patterns
    const subdomains = [
      'www',
      'api',
      'staging',
      'dev',
      'test',
      'admin',
      'beta',
      'mail',
      'blog',
      'docs',
    ].map((sub) => `${sub}.${domain}`);

    return {
      ipAddresses,
      mxRecords: mxRecords.map((record) => record.exchange),
      txtRecords: txtRecords.flat(),
      subdomains,
    };
  } catch (error) {
    logger.error('DNS reconnaissance failed:', error);
    // Return empty arrays if DNS lookup fails
    return {
      ipAddresses: [],
      mxRecords: [],
      txtRecords: [],
      subdomains: [],
    };
  }
}

async function identifyTechnologyStack(
  baseUrl: string
): Promise<ReconnaissanceResult['technologyStack']> {
  try {
    const response = await fetch(baseUrl);
    const headers = response.headers;
    const html = await response.text();

    // Initialize arrays with proper types
    const frontend: string[] = [];
    const backend: string[] = [];
    const database: string[] = [];
    const infrastructure: string[] = [];

    // Frontend detection
    if (html.includes('React')) frontend.push('React');
    if (html.includes('Next.js')) frontend.push('Next.js');
    if (html.includes('Material-UI')) frontend.push('Material-UI');

    // Backend detection
    if (headers.get('x-powered-by')?.includes('Express'))
      backend.push('Express');
    if (headers.get('server')?.includes('Node')) backend.push('Node.js');
    if (html.includes('Prisma')) backend.push('Prisma');

    // Database detection
    if (html.includes('PostgreSQL')) database.push('PostgreSQL');
    if (html.includes('MongoDB')) database.push('MongoDB');

    // Infrastructure detection
    if (headers.get('server')?.includes('nginx')) infrastructure.push('Nginx');
    if (headers.get('server')?.includes('AWS')) infrastructure.push('AWS');

    return {
      frontend,
      backend,
      database,
      infrastructure,
    };
  } catch (error) {
    logger.error('Technology stack identification failed:', error);
    // Return empty arrays if connection fails
    return {
      frontend: [],
      backend: [],
      database: [],
      infrastructure: [],
    };
  }
}

async function mapEndpoints(
  baseUrl: string
): Promise<ReconnaissanceResult['endpoints']> {
  try {
    const apiEndpoints = [
      '/api/auth',
      '/api/users',
      '/api/games',
      '/api/tournaments',
      '/api/analytics',
      '/api/settings',
    ];

    const websocketEndpoints = ['/ws/game', '/ws/chat', '/ws/notifications'];

    const staticEndpoints = ['/static', '/images', '/fonts', '/css', '/js'];

    // Initialize arrays with proper types
    const verifiedEndpoints: ReconnaissanceResult['endpoints'] = {
      api: [],
      websocket: [],
      static: [],
    };

    for (const endpoint of apiEndpoints) {
      try {
        const response = await fetch(`${baseUrl}${endpoint}`);
        if (response.status !== 404) {
          verifiedEndpoints.api.push(endpoint);
        }
      } catch (error) {
        logger.warn(`Failed to verify API endpoint ${endpoint}:`, error);
      }
    }

    return verifiedEndpoints;
  } catch (error) {
    logger.error('Endpoint mapping failed:', error);
    // Return empty arrays if connection fails
    return {
      api: [],
      websocket: [],
      static: [],
    };
  }
}

async function checkSecurityHeaders(
  baseUrl: string
): Promise<ReconnaissanceResult['securityHeaders']> {
  try {
    const response = await fetch(baseUrl);
    const headers = response.headers;

    const securityHeaders = {
      'Content-Security-Policy':
        headers.get('content-security-policy') || 'Not set',
      'X-Content-Type-Options':
        headers.get('x-content-type-options') || 'Not set',
      'X-Frame-Options': headers.get('x-frame-options') || 'Not set',
      'X-XSS-Protection': headers.get('x-xss-protection') || 'Not set',
      'Strict-Transport-Security':
        headers.get('strict-transport-security') || 'Not set',
      'Referrer-Policy': headers.get('referrer-policy') || 'Not set',
      'Permissions-Policy': headers.get('permissions-policy') || 'Not set',
    };

    return securityHeaders;
  } catch (error) {
    logger.error('Security headers check failed:', error);
    // Return default values if connection fails
    return {
      'Content-Security-Policy': 'Connection failed',
      'X-Content-Type-Options': 'Connection failed',
      'X-Frame-Options': 'Connection failed',
      'X-XSS-Protection': 'Connection failed',
      'Strict-Transport-Security': 'Connection failed',
      'Referrer-Policy': 'Connection failed',
      'Permissions-Policy': 'Connection failed',
    };
  }
}

export async function performReconnaissance(): Promise<ReconnaissanceResult> {
  const domain = new URL(pentestConfig.environment.baseUrl).hostname;

  logger.info('Starting reconnaissance...');

  const domainInfo = await performDNSReconnaissance(domain);
  const technologyStack = await identifyTechnologyStack(
    pentestConfig.environment.baseUrl
  );
  const endpoints = await mapEndpoints(pentestConfig.environment.baseUrl);
  const securityHeaders = await checkSecurityHeaders(
    pentestConfig.environment.baseUrl
  );

  const result: ReconnaissanceResult = {
    domainInfo,
    technologyStack,
    endpoints,
    securityHeaders,
  };

  logger.info('Reconnaissance completed successfully');
  return result;
}

// Run reconnaissance if executed directly
if (require.main === module) {
  performReconnaissance()
    .then((result) => {
      console.log('Reconnaissance Results:', JSON.stringify(result, null, 2));
    })
    .catch((error) => {
      console.error('Reconnaissance failed:', error);
      process.exit(1);
    });
}
