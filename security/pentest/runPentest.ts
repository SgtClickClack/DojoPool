import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFile } from 'fs/promises';
import { join } from 'path';
import { pentestConfig } from './config';
import { logger } from '../../utils/logger';

const execAsync = promisify(exec);

interface TestResult {
  tool: string;
  status: 'success' | 'failed' | 'warning';
  output: string;
  vulnerabilities: Vulnerability[];
}

interface Vulnerability {
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  description: string;
  location: string;
  recommendation: string;
}

async function runZapScan(): Promise<TestResult> {
  const { zap } = pentestConfig.tools;
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    // Start ZAP daemon
    await execAsync(`zap.sh -daemon -port ${zap.port} -config api.key=${zap.apiKey}`);
    
    // Run spider scan
    const spiderOutput = await execAsync(
      `curl -s "http://localhost:${zap.port}/JSON/spider/action/scan/?apikey=${zap.apiKey}&url=${pentestConfig.environment.baseUrl}&recurse=true"`
    );
    
    // Run active scan
    const activeScanOutput = await execAsync(
      `curl -s "http://localhost:${zap.port}/JSON/ascan/action/scan/?apikey=${zap.apiKey}&url=${pentestConfig.environment.baseUrl}&recurse=true"`
    );
    
    // Get alerts
    const alertsOutput = await execAsync(
      `curl -s "http://localhost:${zap.port}/JSON/core/view/alerts/?apikey=${zap.apiKey}&baseurl=${pentestConfig.environment.baseUrl}"`
    );
    
    const alerts = JSON.parse(alertsOutput.stdout).alerts;
    
    alerts.forEach((alert: any) => {
      vulnerabilities.push({
        severity: alert.risk.toLowerCase(),
        description: alert.name,
        location: alert.url,
        recommendation: alert.solution,
      });
    });
    
    return {
      tool: 'ZAP',
      status: vulnerabilities.length > 0 ? 'warning' : 'success',
      output: spiderOutput.stdout + activeScanOutput.stdout,
      vulnerabilities,
    };
  } catch (error) {
    logger.error('ZAP scan failed:', error);
    return {
      tool: 'ZAP',
      status: 'failed',
      output: error instanceof Error ? error.message : 'Unknown error',
      vulnerabilities: [],
    };
  }
}

async function runNmapScan(): Promise<TestResult> {
  const { nmap } = pentestConfig.tools;
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    const output = await execAsync(
      `nmap -p ${nmap.ports} -s${nmap.scanTypes.join('')} -T${nmap.timing} --script ${nmap.scripts.join(',')} ${pentestConfig.environment.baseUrl}`
    );
    
    // Parse nmap output for vulnerabilities
    const lines = output.stdout.split('\n');
    lines.forEach(line => {
      if (line.includes('VULNERABLE')) {
        vulnerabilities.push({
          severity: 'high',
          description: line.trim(),
          location: pentestConfig.environment.baseUrl,
          recommendation: 'Update server configuration and patch vulnerable services',
        });
      }
    });
    
    return {
      tool: 'Nmap',
      status: vulnerabilities.length > 0 ? 'warning' : 'success',
      output: output.stdout,
      vulnerabilities,
    };
  } catch (error) {
    logger.error('Nmap scan failed:', error);
    return {
      tool: 'Nmap',
      status: 'failed',
      output: error instanceof Error ? error.message : 'Unknown error',
      vulnerabilities: [],
    };
  }
}

async function runSqlmapScan(): Promise<TestResult> {
  const { sqlmap } = pentestConfig.tools;
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    const output = await execAsync(
      `sqlmap -u "${pentestConfig.environment.apiUrl}" --level=${sqlmap.level} --risk=${sqlmap.risk} --technique=${sqlmap.techniques.join('')} --dbms=${sqlmap.dbms.join(',')} --batch`
    );
    
    // Parse sqlmap output for vulnerabilities
    const lines = output.stdout.split('\n');
    lines.forEach(line => {
      if (line.includes('injection') && line.includes('vulnerable')) {
        vulnerabilities.push({
          severity: 'critical',
          description: line.trim(),
          location: pentestConfig.environment.apiUrl,
          recommendation: 'Implement proper input validation and parameterized queries',
        });
      }
    });
    
    return {
      tool: 'SQLMap',
      status: vulnerabilities.length > 0 ? 'warning' : 'success',
      output: output.stdout,
      vulnerabilities,
    };
  } catch (error) {
    logger.error('SQLMap scan failed:', error);
    return {
      tool: 'SQLMap',
      status: 'failed',
      output: error instanceof Error ? error.message : 'Unknown error',
      vulnerabilities: [],
    };
  }
}

async function generateReport(results: TestResult[]): Promise<void> {
  const report = {
    timestamp: new Date().toISOString(),
    environment: pentestConfig.environment,
    results,
    summary: {
      totalVulnerabilities: results.reduce((acc, result) => acc + result.vulnerabilities.length, 0),
      bySeverity: results.reduce((acc, result) => {
        result.vulnerabilities.forEach(vuln => {
          acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
        });
        return acc;
      }, {} as Record<string, number>),
    },
  };
  
  const reportPath = join(pentestConfig.reporting.outputDir, 'pentest-report.json');
  await writeFile(reportPath, JSON.stringify(report, null, 2));
  logger.info(`Penetration test report generated at ${reportPath}`);
}

async function runPentest(): Promise<void> {
  logger.info('Starting penetration tests...');
  
  const results = await Promise.all([
    runZapScan(),
    runNmapScan(),
    runSqlmapScan(),
  ]);
  
  await generateReport(results);
  
  // Send notifications if configured
  if (pentestConfig.notifications.email.enabled) {
    // TODO: Implement email notification
  }
  
  if (pentestConfig.notifications.slack.enabled) {
    // TODO: Implement Slack notification
  }
  
  logger.info('Penetration tests completed');
}

// Run if called directly
if (require.main === module) {
  runPentest().catch(error => {
    logger.error('Penetration test failed:', error);
    process.exit(1);
  });
} 