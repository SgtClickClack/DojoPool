import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFileSync } from 'fs';
import { join, resolve } from 'path';
import { pentestConfig } from './config';
import { logger } from '../../src/utils/logger';
import { performReconnaissance } from './reconnaissance';
import { mkdir } from 'fs/promises';

const execAsync = promisify(exec);

interface TestResult {
  tool: string;
  status: 'success' | 'failed' | 'warning';
  output: string;
  vulnerabilities: Vulnerability[];
}

interface Vulnerability {
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  description: string;
  location: string;
  recommendation: string;
}

async function runZapScan(): Promise<TestResult> {
  const { zap } = pentestConfig.tools;
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    // Start ZAP daemon
    await execAsync(`zap.sh -daemon -port ${zap.port} -config api.key=${zap.apiKey}`);
    
    // Run spider scan
    const spiderOutput = await execAsync(
      `curl -s "http://localhost:${zap.port}/JSON/spider/action/scan/?apikey=${zap.apiKey}&url=${pentestConfig.environment.baseUrl}&recurse=true"`
    );
    
    // Run active scan
    const activeScanOutput = await execAsync(
      `curl -s "http://localhost:${zap.port}/JSON/ascan/action/scan/?apikey=${zap.apiKey}&url=${pentestConfig.environment.baseUrl}&recurse=true"`
    );
    
    // Get alerts
    const alertsOutput = await execAsync(
      `curl -s "http://localhost:${zap.port}/JSON/core/view/alerts/?apikey=${zap.apiKey}&baseurl=${pentestConfig.environment.baseUrl}"`
    );
    
    const alerts = JSON.parse(alertsOutput.stdout).alerts;
    
    alerts.forEach((alert: any) => {
      vulnerabilities.push({
        severity: alert.risk.toLowerCase(),
        description: alert.name,
        location: alert.url,
        recommendation: alert.solution,
      });
    });
    
    return {
      tool: 'ZAP',
      status: vulnerabilities.length > 0 ? 'warning' : 'success',
      output: spiderOutput.stdout + activeScanOutput.stdout,
      vulnerabilities,
    };
  } catch (error) {
    logger.error('ZAP scan failed:', error);
    return {
      tool: 'ZAP',
      status: 'failed',
      output: error instanceof Error ? error.message : 'Unknown error',
      vulnerabilities: [],
    };
  }
}

async function runNmapScan(): Promise<TestResult> {
  const { nmap } = pentestConfig.tools;
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    const output = await execAsync(
      `nmap -p ${nmap.ports} -s${nmap.scanTypes.join('')} -T${nmap.timing} --script ${nmap.scripts.join(',')} ${pentestConfig.environment.baseUrl}`
    );
    
    // Parse nmap output for vulnerabilities
    const lines = output.stdout.split('\n');
    lines.forEach(line => {
      if (line.includes('VULNERABLE')) {
        vulnerabilities.push({
          severity: 'high',
          description: line.trim(),
          location: pentestConfig.environment.baseUrl,
          recommendation: 'Update server configuration and patch vulnerable services',
        });
      }
    });
    
    return {
      tool: 'Nmap',
      status: vulnerabilities.length > 0 ? 'warning' : 'success',
      output: output.stdout,
      vulnerabilities,
    };
  } catch (error) {
    logger.error('Nmap scan failed:', error);
    return {
      tool: 'Nmap',
      status: 'failed',
      output: error instanceof Error ? error.message : 'Unknown error',
      vulnerabilities: [],
    };
  }
}

async function runSqlmapScan(): Promise<TestResult> {
  const { sqlmap } = pentestConfig.tools;
  const vulnerabilities: Vulnerability[] = [];
  
  try {
    const output = await execAsync(
      `sqlmap -u "${pentestConfig.environment.apiUrl}" --level=${sqlmap.level} --risk=${sqlmap.risk} --technique=${sqlmap.techniques.join('')} --dbms=${sqlmap.dbms.join(',')} --batch`
    );
    
    // Parse sqlmap output for vulnerabilities
    const lines = output.stdout.split('\n');
    lines.forEach(line => {
      if (line.includes('injection') && line.includes('vulnerable')) {
        vulnerabilities.push({
          severity: 'critical',
          description: line.trim(),
          location: pentestConfig.environment.apiUrl,
          recommendation: 'Implement proper input validation and parameterized queries',
        });
      }
    });
    
    return {
      tool: 'SQLMap',
      status: vulnerabilities.length > 0 ? 'warning' : 'success',
      output: output.stdout,
      vulnerabilities,
    };
  } catch (error) {
    logger.error('SQLMap scan failed:', error);
    return {
      tool: 'SQLMap',
      status: 'failed',
      output: error instanceof Error ? error.message : 'Unknown error',
      vulnerabilities: [],
    };
  }
}

async function generateReport(results: TestResult[]): Promise<void> {
  const report = {
    timestamp: new Date().toISOString(),
    environment: pentestConfig.environment,
    results,
    summary: {
      totalVulnerabilities: results.reduce((acc, result) => acc + result.vulnerabilities.length, 0),
      bySeverity: results.reduce((acc, result) => {
        result.vulnerabilities.forEach(vuln => {
          acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
        });
        return acc;
      }, {} as Record<string, number>),
    },
  };
  
  const reportPath = join(pentestConfig.reporting.outputDir, 'pentest-report.json');
  await writeFileSync(reportPath, JSON.stringify(report, null, 2));
  logger.info(`Penetration test report generated at ${reportPath}`);
}

async function runPentest(phase: string) {
  try {
    logger.info(`Starting penetration testing phase: ${phase}`);
    
    let results;
    switch (phase) {
      case 'reconnaissance':
        results = await performReconnaissance();
        const outputDir = resolve(process.cwd(), pentestConfig.reporting.outputDir);
        await mkdir(outputDir, { recursive: true });
        const reportPath = join(outputDir, `reconnaissance-${new Date().toISOString().replace(/:/g, '-')}.json`);
        writeFileSync(reportPath, JSON.stringify(results, null, 2));
        break;
      default:
        throw new Error(`Unknown phase: ${phase}`);
    }
    
    logger.info(`Completed penetration testing phase: ${phase}`);
    return results;
  } catch (error) {
    logger.error('Penetration testing failed:', error);
    throw error;
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
const phaseArg = args.find(arg => arg.startsWith('--phase='));
const phase = phaseArg ? phaseArg.split('=')[1] : null;

if (!phase) {
  logger.error('No phase specified. Usage: ts-node runPentest.ts --phase=<phase>');
  process.exit(1);
}

runPentest(phase)
  .then(results => {
    console.log('Results:', JSON.stringify(results, null, 2));
    process.exit(0);
  })
  .catch(error => {
    console.error('Error:', error);
    process.exit(1);
  }); 