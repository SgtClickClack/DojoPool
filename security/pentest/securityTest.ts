import { exec } from 'child_process';
import { promisify } from 'util';
import { logger } from '../../src/utils/logger';
import fs from 'fs';
import path from 'path';

const execAsync = promisify(exec);

interface TestResult {
  endpoint: string;
  vulnerabilities: string[];
  timestamp: string;
  status: 'success' | 'failed' | 'skipped';
  error?: string;
}

const API_ENDPOINTS = [
  '/api/auth',
  '/api/users',
  '/api/games',
  '/api/tournaments',
  '/api/analytics',
  '/api/settings'
];

const BASE_URL = 'http://localhost:3000';

async function checkToolAvailability(tool: string): Promise<boolean> {
  try {
    await execAsync(`${tool} --version`);
    return true;
  } catch {
    return false;
  }
}

async function runSqlMapTest(endpoint: string): Promise<TestResult> {
  const timestamp = new Date().toISOString();
  const outputFile = path.join(__dirname, '../reports', `sqlmap-${timestamp}.json`);
  
  try {
    // Check if SQLMap is available
    const isAvailable = await checkToolAvailability('sqlmap');
    if (!isAvailable) {
      return {
        endpoint,
        vulnerabilities: [],
        timestamp,
        status: 'skipped',
        error: 'SQLMap not found. Please install it using pip: pip install sqlmap'
      };
    }

    const command = `sqlmap -u "${BASE_URL}${endpoint}" --batch --random-agent --level=2 --risk=2 --output-dir="${path.dirname(outputFile)}" --output-file="${outputFile}"`;
    
    await execAsync(command);
    
    // Read and parse the results
    const results = JSON.parse(fs.readFileSync(outputFile, 'utf-8'));
    
    return {
      endpoint,
      vulnerabilities: results.vulnerabilities || [],
      timestamp,
      status: 'success'
    };
  } catch (error) {
    logger.error(`Error testing endpoint ${endpoint}:`, error);
    return {
      endpoint,
      vulnerabilities: [],
      timestamp,
      status: 'failed',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

async function runSecurityTests() {
  logger.info('Starting comprehensive security tests');
  
  const results: TestResult[] = [];
  
  // Check if server is running
  try {
    await execAsync('curl http://localhost:3000/');
  } catch {
    logger.error('Server not running. Please start the server first.');
    process.exit(1);
  }
  
  for (const endpoint of API_ENDPOINTS) {
    logger.info(`Testing endpoint: ${endpoint}`);
    const result = await runSqlMapTest(endpoint);
    results.push(result);
  }
  
  // Generate final report
  const report = {
    timestamp: new Date().toISOString(),
    environment: {
      baseUrl: BASE_URL,
      nodeVersion: process.version,
      platform: process.platform
    },
    results,
    summary: {
      totalVulnerabilities: results.reduce((sum, r) => sum + r.vulnerabilities.length, 0),
      byStatus: {
        success: results.filter(r => r.status === 'success').length,
        failed: results.filter(r => r.status === 'failed').length,
        skipped: results.filter(r => r.status === 'skipped').length
      }
    }
  };
  
  const reportFile = path.join(__dirname, '../reports', `security-report-${new Date().toISOString()}.json`);
  fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));
  
  logger.info('Security tests completed');
  logger.info(`Report generated at: ${reportFile}`);
  
  // Print summary
  console.log('\nSecurity Test Summary:');
  console.log('---------------------');
  console.log(`Total Endpoints Tested: ${results.length}`);
  console.log(`Successful Tests: ${report.summary.byStatus.success}`);
  console.log(`Failed Tests: ${report.summary.byStatus.failed}`);
  console.log(`Skipped Tests: ${report.summary.byStatus.skipped}`);
  console.log(`Total Vulnerabilities Found: ${report.summary.totalVulnerabilities}`);
}

// Run the tests
runSecurityTests().catch(error => {
  logger.error('Security tests failed:', error);
  process.exit(1);
}); 