"""
Tests for the vulnerability scanning system.
"""

import asyncio
import json
from datetime import datetime
from unittest.mock import AsyncMock, patch

import pytest

from dojopool.core.security.vulnerability_scanner import config
from dojopool.core.security.vulnerability_scanner.base import BaseScanner, VulnerabilityFinding
from dojopool.core.security.vulnerability_scanner.dependency_scanner import DependencyScanner
from dojopool.core.security.vulnerability_scanner.manager import ScannerManager


class MockScanner(BaseScanner):
    """Mock scanner for testing."""

    def __init__(self):
        super().__init__("mock")
        self.prepared = False
        self.cleaned = False

    def prepare_scan(self) -> None:
        self.prepared = True

    def run_scan(self) -> list:
        if not self.prepared:
            raise RuntimeError("Scanner not prepared")
        return [
            VulnerabilityFinding(
                timestamp=datetime.now(),
                severity="high",
                title="Test Finding",
                description="Test Description",
                vulnerability_type="test",
                affected_component="test_component",
                evidence="test evidence",
                remediation="test remediation",
            )
        ]

    def cleanup_scan(self) -> None:
        self.cleaned = True


@pytest.fixture
def mock_scanner():
    return MockScanner()


@pytest.fixture
def scanner_manager():
    manager = ScannerManager()
    manager.scanners["mock"] = MockScanner
    return manager


@pytest.fixture
def temp_scan_dir(tmp_path):
    """Create temporary scan directory."""
    scan_dir = tmp_path / "scans"
    scan_dir.mkdir()
    with patch("dojopool.core.security.vulnerability_scanner.config.SCAN_RESULTS_DIR", scan_dir):
        yield scan_dir


def test_base_scanner_initialization(mock_scanner):
    """Test base scanner initialization."""
    assert mock_scanner.scanner_type == "mock"
    assert mock_scanner.findings == []
    assert mock_scanner.scan_id is None


def test_scanner_execution_flow(mock_scanner):
    """Test scanner execution flow."""
    findings = mock_scanner.execute_scan()

    assert mock_scanner.prepared
    assert mock_scanner.cleaned
    assert len(findings) == 1
    assert findings[0].severity == "high"


def test_finding_to_dict(mock_scanner):
    """Test conversion of finding to dictionary."""
    finding = VulnerabilityFinding(
        timestamp=datetime.now(),
        severity="critical",
        title="Test",
        description="Test Description",
        vulnerability_type="test",
        affected_component="component",
        evidence="evidence",
        remediation="fix it",
        cwe_id="CWE-123",
        cvss_score=8.5,
    )

    result = mock_scanner._finding_to_dict(finding)

    assert result["severity"] == "critical"
    assert result["title"] == "Test"
    assert result["cwe_id"] == "CWE-123"
    assert result["cvss_score"] == 8.5


@pytest.mark.asyncio
async def test_scanner_manager_scheduling(scanner_manager):
    """Test scanner manager scheduling."""
    # Mock the run_scan method
    run_called = False

    async def mock_run(*args, **kwargs):
        nonlocal run_called
        run_called = True

    scanner_manager._run_scan = mock_run

    # Start scheduled scans
    task = asyncio.create_task(scanner_manager.start_scheduled_scans())

    # Wait a bit and cancel
    await asyncio.sleep(2)
    task.cancel()

    assert run_called


def test_dependency_scanner_preparation(temp_scan_dir):
    """Test dependency scanner preparation."""
    scanner = DependencyScanner()

    with patch("subprocess.run") as mock_run:
        scanner.prepare_scan()

        # Should update vulnerability databases
        assert mock_run.call_count >= 1
        assert scanner.temp_dir.exists()


@pytest.mark.asyncio
async def test_scan_result_processing(scanner_manager, temp_scan_dir):
    """Test processing of scan results."""
    findings = [
        VulnerabilityFinding(
            timestamp=datetime.now(),
            severity="high",
            title="Test Finding 1",
            description="Description 1",
            vulnerability_type="test",
            affected_component="component1",
            evidence="evidence1",
            remediation="fix1",
        ),
        VulnerabilityFinding(
            timestamp=datetime.now(),
            severity="medium",
            title="Test Finding 2",
            description="Description 2",
            vulnerability_type="test",
            affected_component="component2",
            evidence="evidence2",
            remediation="fix2",
        ),
    ]

    await scanner_manager._process_scan_results("mock", findings)

    # Check if summary file was created
    summary_file = temp_scan_dir / "mock" / "latest_summary.json"
    assert summary_file.exists()

    # Verify summary content
    with open(summary_file) as f:
        summary = json.load(f)
        assert summary["total_findings"] == 2
        assert summary["severity_counts"]["high"] == 1
        assert summary["severity_counts"]["medium"] == 1


def test_compliance_mapping(mock_scanner, temp_scan_dir):
    """Test compliance mapping functionality."""
    # Create mock compliance mapping file
    mapping_file = config.SCAN_CONFIGS_DIR / "compliance_mapping.yaml"
    mapping_file.parent.mkdir(parents=True, exist_ok=True)
    mapping_content = {"CWE-123": {"OWASP": "A1:2021", "PCI-DSS": "Requirement 6.2"}}
    with open(mapping_file, "w") as f:
        json.dump(mapping_content, f)

    finding = VulnerabilityFinding(
        timestamp=datetime.now(),
        severity="high",
        title="Test",
        description="Test",
        vulnerability_type="test",
        affected_component="test",
        evidence="test",
        remediation="test",
        cwe_id="CWE-123",
    )

    mock_scanner._add_compliance_mappings(finding)

    assert finding.metadata["compliance"]["OWASP"] == "A1:2021"
    assert finding.metadata["compliance"]["PCI-DSS"] == "Requirement 6.2"


@pytest.mark.asyncio
async def test_ticket_creation(scanner_manager):
    """Test ticket creation for findings."""
    with patch("dojopool.core.security.vulnerability_scanner.manager.create_ticket") as mock_create:
        mock_create.return_value = AsyncMock()

        findings = [
            VulnerabilityFinding(
                timestamp=datetime.now(),
                severity="critical",
                title="Critical Issue",
                description="Critical Description",
                vulnerability_type="test",
                affected_component="critical_component",
                evidence="critical evidence",
                remediation="critical fix",
            )
        ]

        await scanner_manager._create_tickets(findings)

        assert mock_create.called
        ticket_data = mock_create.call_args[0][0]
        assert "Critical Issue" in ticket_data["title"]
        assert ticket_data["priority"] == "P0"


def test_scanner_error_handling(mock_scanner):
    """Test scanner error handling."""

    def failing_run():
        raise RuntimeError("Scan failed")

    mock_scanner.run_scan = failing_run

    with pytest.raises(RuntimeError):
        mock_scanner.execute_scan()

    # Cleanup should still be called
    assert mock_scanner.cleaned


def test_risk_score_calculation(mock_scanner):
    """Test risk score calculation."""
    finding = VulnerabilityFinding(
        timestamp=datetime.now(),
        severity="critical",
        title="Test",
        description="Test",
        vulnerability_type="test",
        affected_component="test",
        evidence="test",
        remediation="test",
    )

    score = mock_scanner._calculate_risk_score(finding)
    assert 0 <= score <= 10
    assert score > mock_scanner._calculate_risk_score(
        VulnerabilityFinding(
            timestamp=datetime.now(),
            severity="low",
            title="Test",
            description="Test",
            vulnerability_type="test",
            affected_component="test",
            evidence="test",
            remediation="test",
        )
    )
