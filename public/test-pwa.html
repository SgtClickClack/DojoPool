<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DojoPool PWA Tests</title>
    <link rel="manifest" href="/manifest.json" />
    <style>
      :root {
        --primary-color: #4a90e2;
        --background-color: #1a1a1a;
        --text-color: #ffffff;
        --success-color: #4caf50;
        --error-color: #f44336;
      }

      body {
        margin: 0;
        padding: 2rem;
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, var(--background-color), #2c3e50);
        color: var(--text-color);
        min-height: 100vh;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
      }

      h1 {
        color: var(--primary-color);
        margin-bottom: 2rem;
      }

      .test-section {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
      }

      .test-title {
        font-size: 1.2rem;
        margin-bottom: 1rem;
      }

      .test-button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 0.5rem;
      }

      .test-result {
        margin-top: 0.5rem;
        padding: 0.5rem;
        border-radius: 4px;
      }

      .success {
        background: var(--success-color);
      }

      .error {
        background: var(--error-color);
      }

      .test-log {
        background: rgba(0, 0, 0, 0.3);
        padding: 1rem;
        border-radius: 4px;
        margin-top: 1rem;
        max-height: 200px;
        overflow-y: auto;
        font-family: monospace;
      }

      .test-details {
        margin-top: 0.5rem;
        font-size: 0.9rem;
        opacity: 0.8;
      }

      .test-progress {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        border-top-color: transparent;
        margin-left: 0.5rem;
        animation: spin 1s linear infinite;
        display: none;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .running .test-progress {
        display: inline-block;
      }

      .test-steps {
        margin-top: 0.5rem;
        font-size: 0.9rem;
        padding-left: 1.5rem;
      }

      .test-step {
        margin: 0.25rem 0;
      }

      .test-step.done {
        color: var(--success-color);
      }

      .test-step.error {
        color: var(--error-color);
      }

      .network-status {
        position: fixed;
        top: 1rem;
        right: 1rem;
        padding: 0.5rem 1rem;
        border-radius: 2rem;
        background: var(--success-color);
        font-size: 0.9rem;
      }

      .network-status.offline {
        background: var(--error-color);
      }
    </style>
  </head>
  <body>
    <div class="network-status" id="network-status">Online</div>

    <div class="container">
      <h1>DojoPool PWA Tests</h1>

      <div class="test-section">
        <div class="test-title">Service Worker Registration</div>
        <button class="test-button" onclick="testServiceWorker()">
          Test Registration
        </button>
        <div id="sw-result" class="test-result"></div>
      </div>

      <div class="test-section">
        <div class="test-title">Cache Storage</div>
        <button class="test-button" onclick="testCacheStorage()">
          Test Cache
        </button>
        <div id="cache-result" class="test-result"></div>
      </div>

      <div class="test-section">
        <div class="test-title">Push Notifications</div>
        <button class="test-button" onclick="testPushNotification()">
          Request Permission
        </button>
        <button class="test-button" onclick="sendTestNotification()">
          Send Test Notification
        </button>
        <div id="push-result" class="test-result"></div>
      </div>

      <div class="test-section">
        <div class="test-title">Background Sync</div>
        <button class="test-button" onclick="testBackgroundSync()">
          Test Sync
        </button>
        <div id="sync-result" class="test-result"></div>
      </div>

      <div class="test-section">
        <div class="test-title">Offline Capability</div>
        <button class="test-button" onclick="testOfflineCapability()">
          Test Offline
        </button>
        <div id="offline-result" class="test-result"></div>
      </div>

      <div class="test-log" id="test-log"></div>
    </div>

    <script>
      // Enhanced logging with categories
      function log(message, type = 'info', category = 'general') {
        const logElement = document.getElementById('test-log');
        const timestamp = new Date().toLocaleTimeString();
        logElement.innerHTML += `
                <div class="${type}">
                    [${timestamp}] [${category}] ${message}
                </div>
            `;
        logElement.scrollTop = logElement.scrollHeight;
      }

      // Network status monitoring
      function updateNetworkStatus() {
        const statusElement = document.getElementById('network-status');
        if (navigator.onLine) {
          statusElement.textContent = 'Online';
          statusElement.classList.remove('offline');
          log('Network connection restored', 'success', 'network');
        } else {
          statusElement.textContent = 'Offline';
          statusElement.classList.add('offline');
          log('Network connection lost', 'error', 'network');
        }
      }

      window.addEventListener('online', updateNetworkStatus);
      window.addEventListener('offline', updateNetworkStatus);

      // Enhanced Service Worker test
      async function testServiceWorker() {
        const resultElement = document.getElementById('sw-result');
        const steps = document.createElement('div');
        steps.className = 'test-steps';
        resultElement.parentNode.appendChild(steps);

        try {
          // Step 1: Check browser support
          steps.innerHTML +=
            '<div class="test-step">Checking Service Worker support...</div>';
          if (!('serviceWorker' in navigator)) {
            throw new Error('Service Worker not supported');
          }
          steps.lastChild.classList.add('done');

          // Step 2: Register Service Worker
          steps.innerHTML +=
            '<div class="test-step">Registering Service Worker...</div>';
          const registration =
            await navigator.serviceWorker.register('/service-worker.js');
          steps.lastChild.classList.add('done');

          // Step 3: Verify registration
          steps.innerHTML +=
            '<div class="test-step">Verifying registration...</div>';
          if (
            registration.active ||
            registration.installing ||
            registration.waiting
          ) {
            steps.lastChild.classList.add('done');
            resultElement.textContent = `Service Worker registered successfully. Scope: ${registration.scope}`;
            resultElement.className = 'test-result success';
            log('Service Worker registered successfully', 'success', 'sw');
          } else {
            throw new Error('Service Worker registration verification failed');
          }
        } catch (error) {
          steps.lastChild.classList.add('error');
          resultElement.textContent = `Service Worker registration failed: ${error.message}`;
          resultElement.className = 'test-result error';
          log(
            `Service Worker registration failed: ${error.message}`,
            'error',
            'sw'
          );
        }
      }

      // Enhanced Cache Storage test
      async function testCacheStorage() {
        const resultElement = document.getElementById('cache-result');
        try {
          log('Starting cache storage test', 'info', 'cache');

          // Test writing to cache
          const cache = await caches.open('dojopool-v1');
          log('Cache opened successfully', 'info', 'cache');

          // Test multiple file types
          const filesToCache = [
            '/offline.html',
            '/logo192.png',
            '/manifest.json',
          ];

          for (const file of filesToCache) {
            await cache.add(file);
            log(`Cached ${file}`, 'info', 'cache');
          }

          // Verify cache contents
          for (const file of filesToCache) {
            const response = await cache.match(file);
            if (!response) {
              throw new Error(`Failed to retrieve ${file} from cache`);
            }
            log(`Verified ${file} in cache`, 'success', 'cache');
          }

          resultElement.textContent = 'Cache storage working correctly';
          resultElement.className = 'test-result success';
          log('Cache storage test passed', 'success', 'cache');
        } catch (error) {
          resultElement.textContent = `Cache storage test failed: ${error.message}`;
          resultElement.className = 'test-result error';
          log(`Cache storage test failed: ${error.message}`, 'error', 'cache');
        }
      }

      // Enhanced Push Notification test
      async function testPushNotification() {
        const resultElement = document.getElementById('push-result');
        try {
          log('Starting push notification test', 'info', 'push');

          if (!('Notification' in window)) {
            throw new Error('Notifications not supported');
          }
          log('Notification API supported', 'info', 'push');

          const permission = await Notification.requestPermission();
          log(`Notification permission: ${permission}`, 'info', 'push');

          resultElement.textContent = `Notification permission: ${permission}`;
          resultElement.className =
            'test-result ' + (permission === 'granted' ? 'success' : 'error');

          if (permission === 'granted') {
            log('Push notification test passed', 'success', 'push');
          } else {
            log('Push notification permission not granted', 'error', 'push');
          }
        } catch (error) {
          resultElement.textContent = `Push notification test failed: ${error.message}`;
          resultElement.className = 'test-result error';
          log(
            `Push notification test failed: ${error.message}`,
            'error',
            'push'
          );
        }
      }

      // Enhanced Background Sync test
      async function testBackgroundSync() {
        const resultElement = document.getElementById('sync-result');
        try {
          log('Starting background sync test', 'info', 'sync');

          if (!('serviceWorker' in navigator)) {
            throw new Error('Service Worker required for background sync');
          }

          const registration = await navigator.serviceWorker.ready;
          log('Service worker ready for sync test', 'info', 'sync');

          if (!('sync' in registration)) {
            log(
              'Background Sync API not supported in this browser',
              'warning',
              'sync'
            );
            resultElement.textContent =
              'Background sync not supported in this browser';
            resultElement.className = 'test-result warning';
            return;
          }

          log('Background Sync API available', 'info', 'sync');

          // Simulate offline data
          log('Creating test data for sync', 'info', 'sync');
          const testData = { type: 'test', timestamp: Date.now() };

          log('Opening sync cache', 'info', 'sync');
          const cache = await caches.open('sync-test-cache');

          log('Storing test data in cache', 'info', 'sync');
          await cache.put('/test-sync', new Response(JSON.stringify(testData)));
          log('Test data cached for sync', 'success', 'sync');

          // Register sync with shorter timeout
          log('Attempting sync registration', 'info', 'sync');
          try {
            await Promise.race([
              registration.sync.register('sync-game-data'),
              new Promise((_, reject) =>
                setTimeout(
                  () => reject(new Error('Sync registration timed out')),
                  2000
                )
              ),
            ]);
            log('Sync registration successful', 'success', 'sync');
          } catch (error) {
            if (error.message === 'Sync registration timed out') {
              log(
                'Sync registration timed out - this is normal in some browsers',
                'info',
                'sync'
              );
            } else {
              log(`Sync error: ${error.message}`, 'warning', 'sync');
            }
          }

          resultElement.textContent = 'Background sync test completed';
          resultElement.className = 'test-result success';
          log('Background sync test completed', 'success', 'sync');
        } catch (error) {
          resultElement.textContent = `Background sync test failed: ${error.message}`;
          resultElement.className = 'test-result error';
          log(`Background sync test failed: ${error.message}`, 'error', 'sync');
        }
      }

      // Enhanced Offline Capability test
      async function testOfflineCapability() {
        const resultElement = document.getElementById('offline-result');
        try {
          log('Starting offline capability test', 'info', 'offline');

          log('Waiting for service worker...', 'info', 'offline');
          const registration = await navigator.serviceWorker.ready;
          log('Service worker is ready for offline test', 'info', 'offline');

          log('Opening cache...', 'info', 'offline');
          const cache = await caches.open('dojopool-v1');
          log('Cache opened successfully', 'info', 'offline');

          const essentialFiles = [
            '/test-pwa.html',
            '/offline.html',
            '/logo192.png',
            '/manifest.json',
          ];

          log(
            `Preparing to cache ${essentialFiles.length} files...`,
            'info',
            'offline'
          );

          // Cache files in parallel with shorter timeout
          const cachePromises = essentialFiles.map(async (file) => {
            log(`Starting to fetch ${file}`, 'info', 'offline');
            try {
              const response = await fetch(file);
              if (!response.ok) {
                log(
                  `HTTP error for ${file}: ${response.status}`,
                  'error',
                  'offline'
                );
                return false;
              }
              await cache.put(file, response.clone());
              log(`Cached ${file} successfully`, 'success', 'offline');
              return true;
            } catch (error) {
              log(
                `Failed to cache ${file}: ${error.message}`,
                'warning',
                'offline'
              );
              return false;
            }
          });

          log(
            'Waiting for all cache operations to complete...',
            'info',
            'offline'
          );
          const results = await Promise.all(cachePromises);
          const successCount = results.filter(Boolean).length;

          log(
            `Cached ${successCount} of ${essentialFiles.length} files`,
            'info',
            'offline'
          );

          if (successCount === 0) {
            throw new Error('Failed to cache any files');
          }

          log('Testing offline access...', 'info', 'offline');
          const testResponse = await cache.match('/test-pwa.html');
          if (!testResponse) {
            throw new Error('Failed to verify cached content');
          }
          log('Offline access test successful', 'success', 'offline');

          resultElement.textContent = `Offline capability test passed (${successCount}/${essentialFiles.length} files cached)`;
          resultElement.className = 'test-result success';
          log('Offline capability test completed', 'success', 'offline');

          const details = document.createElement('div');
          details.className = 'test-details';
          details.innerHTML = `
                    To verify offline mode:
                    1. Open Chrome DevTools (F12)
                    2. Go to Network tab
                    3. Check "Offline" checkbox
                    4. Refresh the page - it should load from cache
                    
                    Successfully cached: ${essentialFiles.filter((_, i) => results[i]).join(', ')}
                `;
          resultElement.parentNode.appendChild(details);
        } catch (error) {
          resultElement.textContent = `Offline capability test failed: ${error.message}`;
          resultElement.className = 'test-result error';
          log(
            `Offline capability test failed: ${error.message}`,
            'error',
            'offline'
          );
        }
      }

      // Send Test Notification
      function sendTestNotification() {
        if (Notification.permission === 'granted') {
          navigator.serviceWorker.ready.then((registration) => {
            registration.showNotification('DojoPool Test', {
              body: 'This is a test notification',
              icon: '/logo192.png',
              badge: '/favicon.ico',
              vibrate: [100, 50, 100],
              data: {
                timestamp: Date.now(),
                test: true,
              },
              actions: [
                { action: 'open', title: 'Open App' },
                { action: 'close', title: 'Close' },
              ],
            });
            log('Test notification sent', 'success', 'push');
          });
        } else {
          log('Notification permission not granted', 'error', 'push');
        }
      }

      // Initial checks
      window.addEventListener('load', () => {
        updateNetworkStatus();

        // Check for PWA support
        if ('serviceWorker' in navigator) {
          log('Service Worker supported', 'success', 'init');
        } else {
          log('Service Worker not supported', 'error', 'init');
        }

        if (window.matchMedia('(display-mode: standalone)').matches) {
          log(
            'Running in standalone mode (installed as PWA)',
            'success',
            'init'
          );
        }

        // Check for required APIs
        const requiredApis = {
          serviceWorker: 'serviceWorker' in navigator,
          caches: 'caches' in window,
          Notification: 'Notification' in window,
          BackgroundSync:
            'serviceWorker' in navigator && 'SyncManager' in window,
          PushManager: 'PushManager' in window,
        };

        for (const [api, supported] of Object.entries(requiredApis)) {
          log(
            `${api}: ${supported ? 'Supported' : 'Not supported'}`,
            supported ? 'success' : 'error',
            'init'
          );
        }
      });
    </script>
  </body>
</html>
